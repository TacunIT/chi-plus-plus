<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Istruzioni iterative |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="http://localhost:4000" />
    <meta     name="thumbnail"       content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Istruzioni iterative" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    
    <a href="/man/istruzioni-condizionali" 
       title="Vai a: Istruzioni condizionali" 
       class="left">
        <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    
    <a href="/man/algebra-booleana" 
       title="Vai a: Algebra booleana" 
       class="right" >
            <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Istruzioni iterative
            </h1>

            <blockquote class="motto">Dopo di me, il reboot</blockquote>

            <section id="testo">

                <p>Le istruzioni di ciclo sono una delle componenti fondamentali della programmazione.<br />
Ci sono tre tipi di istruzioni di ciclo:</p>

<ul>
  <li><code>for</code></li>
  <li><code>while</code></li>
  <li><code>do while</code>.</li>
</ul>

<p>Queste istruzioni sono composte di due parti: un’istruzione di <em>controllo del ciclo</em>, che ne determina la durata e un <em>corpo del ciclo</em>, composto dalle istruzioni che vengono ripetute ad ogni iterazione.
La ripetizione può protrarsi o per un determinato numero di volte o fino a che non sia raggiunta una determinata condizione.</p>

<h2 id="il-ciclo-for">Il ciclo for</h2>
<p>Questa istruzione viene utilizzata quando vogliamo eseguire il ciclo in numero determinato di volte. 
La forma generale è la seguente:</p>

<pre><code>// controllo del ciclo
for(&lt;stato iniziale&gt; ; &lt;stato finale&gt; ; &lt;variazione&gt;)
{
    // corpo del ciclo
    &lt;istruzioni&gt;
}
</code></pre>

<p>Le tre condizioni all’interno delle parentesi sono utilizzate dall’istruzione <code>for</code> per controllare l’esecuzione delle istruzioni all’interno del corpo del ciclo.<br />
La prima espressione è valutata solo una volta all’inizio del ciclo e, solitamente, serve a inizializzare le variabili utilizzate.<br />
La seconda espressione è una condizione logica o relazionale che viene valutata all’inizio di ogni iterazione: se torna <code>0</code> o <code>false</code> l’esecuzione del ciclo termina, altrimenti posegue.<br />
La terza espressione viene valutata al termine di ogni iterazione e, di solito, è costituita da un’espressione di incremento delle variabili utilizzate per il controllo del ciclo.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

#define POS_NESSUNO -1
#define POS_ERRORE   0
#define POS_MERCURIO 1
#define POS_VENERE   2
#define POS_TERRA    3
#define POS_MARTE    4
#define POS_GIOVE    5
#define POS_SATURNO  6
#define POS_URANO    7
#define POS_NETTUNO  8
#define POS_PLUTONE  9

using namespace std;

/**
 *  mostraPianeta 
 *  Visualizza il nome di un pianeta, data la sua posizione.
 *  @param  int  pianeta Posizione del pianeta.
 *  @return bool esiste  true se il pianeta esiste.
 */
bool mostraPianeta(int pianeta )
{    
    bool esiste = true;
    
    switch( pianeta ) {
        case POS_ERRORE:   cout &lt;&lt; "Valore non valido"; break;
        case POS_MERCURIO: cout &lt;&lt; "Mercurio";          break;
        case POS_VENERE:   cout &lt;&lt; "Venere";            break;
        case POS_TERRA:    cout &lt;&lt; "Terra";             break;
        case POS_MARTE:    cout &lt;&lt; "Marte";             break;
        case POS_GIOVE:    cout &lt;&lt; "Giove";             break;
        case POS_SATURNO:  cout &lt;&lt; "Saturno";           break;
        case POS_URANO:    cout &lt;&lt; "Urano";             break;          
        case POS_NETTUNO:  cout &lt;&lt; "Nettuno";           break;          
        case POS_PLUTONE:  cout &lt;&lt; "Plutone";           break;
        default:
            esiste = false;
            cout &lt;&lt; "Inserire un valore da: " 
                 &lt;&lt; POS_MERCURIO 
                 &lt;&lt; " a " 
                 &lt;&lt; POS_PLUTONE;                    
    } 
    
    return esiste;
}

/**
 *  main
 *  Funzione principale del programma, richiama la funzione
 *  mostraPianeti passandole i valori da 1 a 9.
 */
int main(int argc, char** argv)
{    
    int p = POS_NESSUNO;

    /** Elenca tutti i Pianeti del Sistema Solare */
    for ( p = POS_MERCURIO; p &lt;= POS_PLUTONE; p++ ) {
        cout &lt;&lt; p &lt;&lt; ": "; 
        mostraPianeta( p ); 
        cout &lt;&lt; endl;
    }
        
    return 0;
}

</code></pre>

<p>La prima istruzione inizializza il valore di <code>p</code> a <code>1</code> (il valore della costante <code>POS_MERCURIO</code>) e prosegue, per incrementi successivi di 1, fino a che il valore di <code>p</code>è minore o uguale a <code>9</code> (il valore della costante <code>POS_PLUTONE</code>).
A ogni ripetizione il programma mostra il valore della variabile <code>p</code>, richiama la funzione <code>mostraPianeta</code>, passandole il valore corrente di <code>p</code>, poi aggiunge un a capo.<br />
L’output di questo programma è:</p>

<pre><code>% g++ src/cpp/istruzioni-iterative-for.cpp -o src/out/esempio
% src/out/esempio                                            
1: Mercurio
2: Venere
3: Terra
4: Marte
5: Giove
6: Saturno
7: Urano
8: Nettuno
9: Plutone

</code></pre>

<p>Si può utilizzare un ciclo <code>for</code> anche per effettuare cicli con un numero indefinito di iterazioni, basta omettere le tre espressioni di controllo, mantenendo solo delle <em>istruzioni nulle</em>, composte dal solo terminatore <code>;</code>:</p>

<pre><code>for( ; ; )
{
    // istruzioni
}
</code></pre>

<p>Un ciclo di questo tipo continuerà a ripetersi indefinitamente e, se non viene fermato in qualche maniera, causerà inevitabilmente dei problemi al computer che lo esegue.
È necessario quindi porre un limite al numero di ripetizioni, utilizzando la stessa parola-chiave <code>break</code>che abbiamo usato con le istruzioni <code>switch</code>.
Stavolta, però, cominceremo a fare le cose come vanno fatte e separeremo le tre componenti del programma precedente in tre file distinti: <code>pianeti.h</code>, che conterrà le dichiarazioni delle costanti e della funzione <code>mostraPianeta</code>; <code>pianeti.cpp</code>, contenente la definizione della funzione <code>mostraPianeta</code> e <code>pianeti-main.cpp</code> per la funzione <code>main</code>:</p>

<pre><code>/** 
 * @file pianeti.h
 * Costanti e funzione per la gestione dei Pianeti.
 */

#ifndef _PIANETI
#define _PIANETI 1
 
/** Dichiarazione delle costanti */
#define POS_NESSUNO -1
#define POS_ERRORE   0
#define POS_MERCURIO 1
#define POS_VENERE   2
#define POS_TERRA    3
#define POS_MARTE    4
#define POS_GIOVE    5
#define POS_SATURNO  6
#define POS_URANO    7
#define POS_NETTUNO  8
#define POS_PLUTONE  9

/** Dichiarazione della funzione */
bool mostraPianeta(int pianeta);

#endif /* _PIANETI */

</code></pre>

<pre><code>/** 
 * @file pianeti.cpp
 * Funzione per la gestione dei Pianeti.
 */

#include &lt;iostream&gt;
#include "pianeti.h"

using namespace std;

/**
 *  mostraPianeta 
 *  Visualizza il nome di un pianeta, data la sua posizione.
 *  @param  int  pianeta Posizione del pianeta.
 *  @return bool esiste  true se il pianeta esiste.
 */
bool mostraPianeta(int pianeta)
{    
    bool esiste = true;
    
    switch( pianeta ) {
        case POS_ERRORE:   
            cout &lt;&lt; "Valore non valido"; 
            break;
        case POS_MERCURIO: 
            cout &lt;&lt; "Mercurio";          
            break;
        case POS_VENERE:   
            cout &lt;&lt; "Venere";            
            break;
        case POS_TERRA:    
            cout &lt;&lt; "Terra";             
            break;
        case POS_MARTE:    
            cout &lt;&lt; "Marte";             
            break;
        case POS_GIOVE:    
            cout &lt;&lt; "Giove";             
            break;
        case POS_SATURNO:  
            cout &lt;&lt; "Saturno";           
            break;
        case POS_URANO:    
            cout &lt;&lt; "Urano";             
            break;          
        case POS_NETTUNO:  
            cout &lt;&lt; "Nettuno";           
            break;          
        case POS_PLUTONE:  
            cout &lt;&lt; "Plutone";           
            break;
        default:
            esiste = false;
            cout &lt;&lt; "Inserire un valore da: " 
                 &lt;&lt; POS_MERCURIO 
                 &lt;&lt; " a " 
                 &lt;&lt; POS_PLUTONE;                    
    } 
    
    return esiste;
}

</code></pre>

<pre><code>/** 
 * @file pianeti-main.cpp
 * Funzione princopale per il programma di gestione dei Pianeti.
 */
 
#include &lt;iostream&gt;
#include "pianeti.h"

using namespace std;

int main(int argc, char** argv)
{    
    int p = POS_MERCURIO;

    /** Elenca tutti i Pianeti del Sistema Solare */
    for ( ; ; ) {
        cout &lt;&lt; p &lt;&lt; ": "; 
        /** Se incontra un errore, si ferma */
        if(!mostraPianeta( p++ )) break; 
        cout &lt;&lt; endl;
    }
        
    cout &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>L’incremento della variabile <code>p</code>, in questo caso, avviene all’interno dell’istruzione:
<!-- @todo: parlare dell'operatore di incremento --></p>

<pre><code>if(!mostraPianeta( p++ )) break; 
</code></pre>

<p>Per generare questo programma dovremo passare al compilatore emntrambi i file <em>.cpp</em>:</p>

<pre><code>% g++ src/cpp/pianeti-main.cpp \
      src/cpp/pianeti.cpp \
   -o src/out/esempio
% src/out/esempio 
1: Mercurio
2: Venere
3: Terra
4: Marte
5: Giove
6: Saturno
7: Urano
8: Nettuno
9: Plutone
10: Inserire un valore da: 1 a 9
</code></pre>

<!--
4.3.2   Il ciclo while
Il ciclo while viene principalmente usato nei casi dove non sia preventivamente determinato il numero di iterazioni da effettuare. Questa istruzione valuta un’espressione e quindi esegue il corpo del ciclo zero o piu` volte fino a che l’espressione è valutata pari a zero (false).
La forma generale è la seguente: 

while(espressione)
{
  ...istruzioni...(corpo del ciclo)
}

Anche in questo caso è possibile forzare il numero dei cicli indefinitamente sostituendo l’espressione con una costante nonzero, per esempio:

while(1)
{
  ...istruzioni...(corpo del ciclo)
}

Il ciclo verrà ripetuto un numero indefinito di volte, salvo l’istruzione di interruzione break come per il ciclo for.
Vediamo anche in questo caso un esempio di inizializzazione di array, in particolare prenderemo il programma di esempio istr05.c e sostituiremo le istruzioni for con istruzioni while, inizializzeremo un array di 15 elementi prima con tutti i valori a zero e poi con valori corrispondenti al numero di indice dall’elemento il cui numero è dato in input.

Nel seguente esempio vedremo come sia possibile nidificare una funzione di lettura dello standard input nell’espressione valutata dall’istruzione while.
Il programma effettua una lettura di valori interi fino a quando incontra il carattere ‘#’ che determina la fine del ciclo di input, successivamente vengono presentati in output i numeri in forma tabellare di 5 colonne per n righe.
ISTR07.C - Ciclo while per input numeri
/**********************************************************
 File: istr07.c
 Desc: ciclo while per input numeri
 Comm: 
**********************************************************/
#include <stdio.h>

int main()
{
  int a[100], n=0, i, x;

  printf("\nInput(al massimo 100)interi, seguiti da # :\n");

  while(n<100 && scanf("%d", &x))               /* 001 */
  {
    a[n++] = x;
  }
  printf("\nTermine input");
                  
  printf("\nNumeri in forma tabellare (5 per linea):\n");

  for(i=0; i<n; i++)                            /* 002 */
  {
    printf("%c%9d", i % 5 ? ' ':'\n', a[i]);
  }
  printf("\nFine\n");
  
  return 0;
}
/******* End *********************************************/
001 Ciclo ‘while’ di input, notiamo che l’espressione è composta ed è formata da un’espressione relazionale (n<100) in ‘AND logico’ con una chiamata alla funzione di libreria standard ‘scanf’, tale funzione che riceve come argomenti un formato ed un indirizzo di variabile, legge dallo standard input un valore congruente al formato e lo scrive nella locazione di memoria relativa all’indirizzo. In questo caso se il carattere non è numerico la funzione ritorna il valore 0 (false) determinando così la fine del ciclo. Altrettanto accade nel caso il valore di ‘n’ non sia inferiore a 100. Entrambe queste condizioni debbono essere vere per la prosecuzione del ciclo. Il corpo del ciclo è costituito dall’assegnazione di ‘x’ all’elemento dell’array ‘n’, notiamo come sia utilizzato il post-incremento di ‘n’ per "scorrere" l’array.
002 Ciclo ‘for’ per effettuare l’output dell’array in forma tabellare. Nella funzione ‘printf’ sono nidificati l’operatore modulo (%) e l’operatore ternario (?:). La ‘printf’, dopo aver stampato il valore dell’elemento dell’array valuta il modulo del relativo indice, se non è divisibile per 5, senza resto, stampa un carattere "blank", altrimenti stampa un carattere "new line".

## Il ciclo do-while
Il ciclo do-while si differenzia dal ciclo while che abbiamo visto in precedenza solamente per il fatto di valutare la condizione while alla fine dell’iterazione, questo determina l’esecuzione del corpo del ciclo almeno per una volta. 
La forma generale è la seguente:

do
{
  ...istruzioni...(corpo del ciclo)
} while(espressione)

Il ciclo viene eseguito una prima volta per effettuare l’assegnazione di un valore ad a e quindi viene ripetuto fino a quando la variabile a assume il valore zero (false).

### Istruzioni di interruzione
Queste istruzioni sono usate per controllare l’esecuzione di altre istruzioni. Il loro utilizzo più comune è quello di interrompere cicli o, come abbiamo già visto per break, l’istruzione di switch. Le tre istruzioni di interruzione sono:

break;
continue;
return.

Istruzione break
L’istruzione break termina i cicli for, while e do-while, nonché l’istruzione switch che la includono, passando il controllo all’istruzione immediatamente successiva al blocco istruzioni del ciclo (corpo del ciclo) o dello switch.
Vediamo ora un esempio di interruzione in un ciclo.
INTE01.C - Istruzione break
/**********************************************************
 File: inte01.c
 Desc: istruzione break
 Comm: 
**********************************************************/
#include <stdio.h>

int main()
{
  int i=0;
  
  while(++i)                                    /* 001 */
  {
    if(i == 5) break;                           /* 002 */
    printf("valore di i: %d\n", i);
  }

  return 0;
}
/******* End *********************************************/
001 Ciclo ‘while’ con pre-incremento della variabile ‘i’. Tale ciclo se non fosse interrotto da ‘break’ continuerebbe ad essere eseguito fino al verificarsi della condizione di overflow della variabile ‘i’.
002 Istruzione ‘break’ controllata dalla condizione di ‘i’ uguale a 5. In questo caso il ciclo viene eseguito solamente 4 volte.
Il programma produce il seguente output:
valore di i: 1
valore di i: 2
valore di i: 3
valore di i: 4
4.4.2   Istruzione continue
L’istruzione continue determina il passaggio del controllo alla fine del singolo ciclo di iterazione senza determinare l’uscita dal corpo del ciclo che può riprendere con la successiva iterazione.
Vediamo un esempio di un ciclo for che contiene due istruzioni di stampa a video, di cui una viene eseguita sempre e l’altra solo quando il contatore raggiunge un numero dispari.
INTE02.C - Istruzione continue
/**********************************************************
 File: inte02.c
 Desc: istruzione continue
 Comm: 
**********************************************************/
#include <stdio.h>

int main()
{
  int i;
  
  for(i=1; i<10; i++)                           /* 001 */
  {
    printf("\nciclo numero: %d ", i);
    if(i % 2) continue;                         /* 002 */
    printf("contatore pari");
  }
  printf("\nfine\n");

  return 0;
}
/******* End *********************************************/
001 Ciclo ‘for’ di 9 iterazioni.
002 Istruzione ‘continue’ eseguita solo se ‘i’ è un numero pari, in questo caso il salto alla fine del ciclo corrente determina la non esecuzione dell’ultima istruzione ‘printf’.
Il programma produce il seguente output:
ciclo numero: 1
ciclo numero: 2 contatore pari
ciclo numero: 3
ciclo numero: 4 contatore pari
ciclo numero: 5
ciclo numero: 6 contatore pari
ciclo numero: 7
ciclo numero: 8 contatore pari
ciclo numero: 9
fine
4.4.3   Istruzione return
L’istruzione return consente di terminare l’esecuzione di una funzione e di avere un eventuale valore di ritorno alla funzione chiamante. Vediamone un esempio:
INTE03.C - Istruzione return
/**********************************************************
 File: inte03.c
 Desc: istruzione return
 Comm: 
**********************************************************/
#include <stdio.h>

int  fa(int);
void fb(int);

int main()
{
  int i;
  
  for(i=1; i<10; i++)                            /* 001 */
  {
    printf("\nciclo numero: %d ", i);
    printf("valore ritornato da fa: %d", fa(i)); /* 002 */
  }

  fb(i);
  
  return 0;                                      /* 003 */
}

/* --- funzione fa ------------------------------------- */
int fa(int x)
{
  int a=5;

  if(!(x % 2))
  {
    printf("(pari)    ");
    return a * x;
  }
  printf("(dispari) ");
  return 1;
}

/* --- funzione fb ------------------------------------- */
void fb(int x)
{
  printf("\nfine (valore di i: %d)\n", x);
  return;
}
/******* End *********************************************/
001 Ciclo for di 9 iterazioni.
002 Output del valore ritornato dalla funzione fa.
003 Istruzione ‘return’ della funzione ‘main’. Secondo la direttiva ANSI la funzione ‘main’ restituisce un intero al livello del sistema operativo, il valore 0 costituisce il segnale di corretta terminazione del programma. Se però utilizziamo un compilatore K&R la funzione ‘main’ non dovrà avere valore di ritorno.
funzione fa:
Questa funzione riceve come argomento il numero di ciclo in esecuzione e ritorna il valore pari al numero di ciclo moltiplicato 5 se il numero ricevuto è pari, altrimenti ritorna il valore costante 1. Notiamo come la condizione ‘if’ sia vera (nonzero) applicando in NOT logico (!) al modulo tra ‘i’ e 2 e siano necessarie la parentesi tonde per stabilire la corretta priorità delle operazioni.
funzione fb:
Questa funzione riceve come argomento il valore corrente di ‘i’, ne effettua l’output e non ritorna nulla (finzione void). Notiamo come il valore corrente di ‘i’ sia 10 in quanto il ciclo ‘for’, pur non eseguendo il corpo del ciclo effettua comunque un ultima volta l’incremento di ‘i’ (i++).
Il programma produce il seguente output:
ciclo numero: 1 (dispari) valore ritornato da fa 1
ciclo numero: 2 (pari)    valore ritornato da fa 10
ciclo numero: 3 (dispari) valore ritornato da fa 1
ciclo numero: 4 (pari)    valore ritornato da fa 20
ciclo numero: 5 (dispari) valore ritornato da fa 1
ciclo numero: 6 (pari)    valore ritornato da fa 30
ciclo numero: 7 (dispari) valore ritornato da fa 1
ciclo numero: 8 (pari)    valore ritornato da fa 40
ciclo numero: 9 (dispari) valore ritornato da fa 1
fine (valore di i 10)



<hr id="dottrina">

<!--

@todo - qui va introdotto il concetto di ciclicità dell'Universo.
- introdurre l'idea delle "variazioni" della storia dell'Universo

-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/istruzioni-condizionali" 
           title="Vai a: Istruzioni condizionali" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/algebra-booleana" 
           title="Vai a: Algebra booleana" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
