<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Il preprocessore |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="http://localhost:4000" />
    <meta     name="thumbnail"       content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Il preprocessore" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    
    <a href="/man/funzioni" 
       title="Vai a: Le funzioni" 
       class="left">
        <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    
    <a href="/man/classi" 
       title="Vai a: Le classi" 
       class="right" >
            <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Il preprocessore
            </h1>

            <blockquote class="motto"></blockquote>

            <section id="testo">

                <p>Le direttive al preprocessore sono la caratteristica principale del C++.<br />
Negli esempi precedenti abbiamo visto alcune istruzioni particolari, perché hanno un carattere <code>#</code> all’inizio e non hanno un carattere <code>;</code> alla fine:</p>

<pre><code>#include &lt;iostream&gt;

#define NO_ERRORI    0
#define NO_PARAMETRI 1
</code></pre>

<p>Queste istruzioni sono delle <em>direttive al pre-processore</em> e possono essere di tre tipi:</p>

<ul>
  <li>direttive di inclusione;</li>
  <li>definizioni e macroistruzioni;</li>
  <li>direttive condizionali.</li>
</ul>

<p>Le <a id="inclusione" onclick="history.back()" title="fare click per tornare alla pagina precedente">direttive di inclusione</a> sono quelle che si utilizzano più comunemente e servono a importare nel codice le definizioni delle funzioni di libreria, delle macroistruzioni e dei simboli necessari per la corretta compilazione dei programmi.
Questi elementi, per comodità, sono isolati all’interno di alcuni file, detti <em>file di include</em>.
Quando il preprocessore incontra una direttiva <code>include</code>, la sostituisce con il contenuto del file a cui fa riferimento.
Per esempio, se più di un programma dovesse usare la Classe <code>Colore</code> o la struttura <code>ColoreRGB</code> che abbiamo utilizzato nel programma che visualizza la dimensione dei <a href="/man/tipi-di-dato#principali"> principali tipi di dato del C++</a>, questi dovrebbero essere isolati in un file separato con estensione <code>.h</code>, a indicare che si tratta di un <em>header file</em>:</p>

<pre><code>
#ifndef _CLASS_COLORE
#define _CLASS_COLORE 1

#include &lt;iostream&gt;

using namespace std;

/** Definisce un tipo di dato enumerato di nome RGB */
enum RGB { red = 0xFF0000, green = 0x00ff00, blue = 0x0000ff };

/** Definisce una struttura che contiene un colore RGB e un nome */
struct ColoreRGB {
    RGB  valore;
    const char* nome;        
};

/** 
 * Definisce la classe Colore, che contiene un coloreRGB 
 * e una funzione che ne mostra il nome.
 */
class Colore {
public:
    ColoreRGB coloreRgb;        
    void nome_colore() {
        cout &lt;&lt; "coloreRGB:";
        switch(coloreRgb.valore) {
            case red  : cout &lt;&lt; "red"  ; break;
            case green: cout &lt;&lt; "green"; break;
            case blue : cout &lt;&lt; "blue" ; break;
        }
        cout &lt;&lt; endl;
    }        
};

#endif /* _CLASS_COLORE */

</code></pre>

<p>Il file verrebbe poi incluso nel codice dei programmi che ne fanno uso con una direttiva <code>include</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include "colore.h"

using namespace std;

int main()
{    
    /** Dichiara una serie di variabili */
    bool    booleano = false;
    char    carattere = 'C';
    int     intero = 1234567890;
    float   decimale = 3.14;
    char    array[] = "abcdefghilmnopqrstuvz";
    RGB     enumerato = green;
    
    /** Crea un oggetto di tipo Colore */
    Colore  colore;    
    
    /** 
     * Assegna un valore ai dati della struttura coloreRgb 
     * all'interno dell'oggetto di tipo Colore.
     */
    colore.coloreRgb.valore = enumerato;   
    colore.coloreRgb.nome = "verde";     

    /** Mostra il valore delle variabili */
    cout &lt;&lt; "booleano:"    &lt;&lt; booleano   &lt;&lt; endl;
    cout &lt;&lt; "carattere:"   &lt;&lt; carattere  &lt;&lt; endl;
    cout &lt;&lt; "intero:"      &lt;&lt; intero     &lt;&lt; endl;
    cout &lt;&lt; "decimale:"    &lt;&lt; decimale   &lt;&lt; endl;
    cout &lt;&lt; "array:"       &lt;&lt; array      &lt;&lt; endl;
    
    /** Mostra il nome del colore */
    colore.nome_colore();
    
    return 0;
}

</code></pre>

<p>Questo esempio utilizza due forme distinte per la direttiva <code>include</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include "colore.h" 
</code></pre>

<p>La prima forma serve a includere i file di sistema, come, appunto, <code>iostream</code>, che contiene le definizioni degli <em>stream</em> stadard del C++; la seconda forma si utilizza per i file specifici dell’applicazione; nel nostro caso, <code>colore.h</code>.<br />
I file di include possono includere a loro volta altri file; per esempio, <code>colore.h</code> include <code>iostream</code>, perché utilizza lo <em>stream</em> <code>cout</code>.
Anche il nostro codice di esempio, però, include <code>iostream</code> e questo potrebbe causare un errore di compilazione se il precompilatore effettuasse due volte l’inclusione, perché sarebbbe come se dichiarassimo due volte la stessa funzione.
Per questo motivo, all’inizio del nostro file di include (ma anche di ìostream`) troviamo un altro tipo di diretttive al preprocessore, le cosiddette: 
<a id="condizionali" onclick="history.back()" title="fare click per tornare alla pagina precedente">direttive condizionali</a>:</p>

<pre><code>#ifndef _CLASS_COLORE
#define _CLASS_COLORE 1

...

#endif /* _CLASS_COLORE */
</code></pre>

<p>Le direttive condizionali sono:</p>

<table>
  <thead>
    <tr>
      <th>direttiva</th>
      <th>valore</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>#if</code></td>
      <td>se non zero</td>
    </tr>
    <tr>
      <td><code>#ifdef</code></td>
      <td>se definito</td>
    </tr>
    <tr>
      <td><code>#ifndef</code></td>
      <td>se non definito</td>
    </tr>
    <tr>
      <td><code>#else</code></td>
      <td>altrimenti</td>
    </tr>
    <tr>
      <td><code>#elif</code></td>
      <td>altrimenti se</td>
    </tr>
    <tr>
      <td><code>#endif</code></td>
      <td>fine del blocco condizionale</td>
    </tr>
  </tbody>
</table>

<p>Quando il preprocessore legge la prima direttiva nel file di include, verifica che sia definito un valore per <code>_CLASS_COLORE</code>.
Se <code>_CLASS_COLORE</code> non ha un valore associato, il preprocessore esegue l’istruzione successiva, che gli assegna il valore 1, poi inserisce nel file chiamante tutto il codice fino all’istruzione <code>#endif</code>.
Se invece <code>_CLASS_COLORE</code> ha già un valore associato perché è già stata inclusa da altri file, il preprocessore salta direttamente alla direttiva <code>#endif</code> senza riscrivere le tre dichiarazioni.</p>

<!--


6.3   DEFINIZIONI E MACROISTRUZIONI
È possibile definire degli identificatori correlati a stringhe di sostituzione che il preprocessore provvederà ad inserire nel codice sorgente in luogo di detti identificatori prima del processo di compilazione. Generalmente, tali stringhe sono costituite da valori costanti o istruzioni, nel primo caso sono chiamate costanti simboliche, nel secondo sono chiamate macroistruzioni o più brevemente macro.
Alcuni esempi validi di costanti simboliche sono:
#define FALSE 0
#define TRUE 1
#define NUMERO 0.2
#define STRINGA "Stringa di caratteri" 
Alcuni esempi validi di macroistruzioni sono:
#define INCREMENTO(x) x * 0.2
#define CUBO(x) x * x * x 
È inoltre possibile eliminare una #define precedentemente assegnata per mezzo della direttiva #undef.
Vediamo ora un esempio di uso delle definizioni e delle macroistruzioni:
PRE01.C - Definizioni e macroistruzioni
/**********************************************************
 File: pre1.c
 Desc: definizioni e macroistruzioni
 Comm: 
**********************************************************/
#include <stdio.h>

#define NUMERO 3
#define INCREMENTO(x) x * 1.23
#define CUBO(x) x * x * x

int main()
{
  int x;
  double y;
    
  printf("Numero     : %d \n", NUMERO);
  x = CUBO(NUMERO);
  printf("Cubo       : %d \n", x);
  
#undef NUMERO
#define NUMERO 4

  printf("Numero     : %d \n", NUMERO);
  x = CUBO(NUMERO);
  printf("Cubo       : %d \n", x);
  
  y = INCREMENTO((double)x);
  printf("Incremento : %f \n", y);

  return 0;
}
/******* End *********************************************/
Il programma produrrà il seguente output:
Numero     : 3
Cubo       : 27
Numero     : 4
Cubo       : 64
Incremento : 78.720000
Una macro generalmente è di esecuzione piu` veloce di una funzione che effettua le medesime operazioni, in quanto, operando una pura sostituzione di codice  non richiede la memorizzazione sullo stack di alcun indirizzo di ritorno. Nei file standard di "include" possiamo trovare sovente alcune funzioni implementate come macro, generalmente queste ultime sono riconoscibili dal prefisso _(underscore).
Un esempio tipico è quello della funzione toupper(c) che effettua la conversione a maiuscolo di un carattere minuscolo, una forma tipica della sua implementazione come macro è:
#define _toupper(c)     ((c)- 'a'+'A')
oppure:
#define _toupper(c) ((c)>= 'a'&&(c) <= 'z'?(c)& 0x5F:(c))
Questa seconda forma, a prima vista oscura, può essere facilmente così tradotta: se il parametro c è minuscolo, ovvero una lettera compresa tra a e z, l’espressione restituisce la corrispondente maiuscola per mezzo dell’operatore & (bitwise), altrimenti restituisce il carattere senza alcuna modifica.
6.4   DIRETTIVE CONDIZIONALI
Le direttive condizionali consentono di delimitare una o più istruzioni che verranno compilate in determinate condizioni. Questo tipo di compilazione è definito compilazione condizionale e viene utilizzato in molti casi per la creazione di programmi che debbano funzionare su diversi sistemi operativi.
Direttive condizionali
Direttiva
Descrizione


Vediamo più chiaramente con un esempio gli effetti delle compilazioni condizionali. Consideriamo il seguente programma:
PRE2.C- Compilazione condizionale
/**********************************************************
 File: pre2.c
 Desc: compilazione condizionale
 Comm: 
**********************************************************/
#include <stdio.h>

#define FLAG 1

#if FLAG
#define STRING "Elevazione al cubo"
#define FORMULA(x) x * x * x
#else
#define STRING "Elevazione al quadrato"
#define FORMULA(x) x * x
#endif

int main()
{
  int a = 4, x;
  char s[25];
    
  strcpy(s, STRING);
  printf("Flag : %d  Numero : %d\n", FLAG, a);
  x = FORMULA(a);
  printf("%-25s : %d \n", s, x);

  return 0;
}
/******* End *********************************************/
Compilato ed eseguito darà il seguente output:
Flag : 1  Numero : 4
Elevazione al cubo        : 64
Ora andiamo a sostituire l’istruzione:
#define FLAG 1
con la seguente:

#define FLAG 0
Nuovamente compilato ed eseguito il programma senza altre modifiche produrrà il seguente output:
Flag : 0  Numero : 4
Elevazione al quadrato    : 16
Naturalmente questa direttiva #define può essere contenuta in un file diverso da quello del programma ed incluso con la direttiva #include, la sostituzione di questo file esterno potrà così determinare il differente comportamento del compilatore.
Quest’ultima tecnica viene comunemente usata per le compilazioni condizionali sulla base del sistema operativo, tali compilazioni usano in molti casi lo stato di definizione di una stringa (token-string) mediante la direttiva #ifdef.

-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/funzioni" 
           title="Vai a: Le funzioni" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/classi" 
           title="Vai a: Le classi" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
