<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Le classi |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Le classi" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    <a title="Vai a: Istruzioni iterative" 
        
        href="/man/istruzioni-iterative" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Gli oggetti" 
        
        href="/man/oggetti" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Le classi
            </h1>

            <blockquote class="motto">Ceci n'est pas une |</blockquote>

            <section id="testo">

                <!-- Quando ho cominciato a scrivere questo capitolo, si è rotto il tasto "o" del mio Mac. È Domenica e siamo in clausura da COVID, quindi non posso andare in un centro commerciale a comprarne una esterna, temporanea. Perdonate eventuali refusi -->
<p>La possibilità di definire nuovi tipi di dato grazie alle classi è la caratteristica principale del C++.</p>

<p>I linguaggi di programmazione come il C, il Cobol il Fortran o il Pascal, hanno un insieme limitato di tipi di dato: interi, numeri in virgola mobile, booleani, caratteri e stringhe.. giusto quello che serve a gestire una scheda anagrafica o un conto in banca.
C e Pascal hanno anche la possibilità di accorpare questi tipi di dato in strutture, enumerati o array, ma questi tipi di dato sono solo dei contenitori privi di logica interna.
Inoltre, i dati all’interno di una <code>struct</code> sono accessibili a qualunque componente del programma, quindi, se li si modifica, va modificato anche il codice che li utilizza.
Immagina di definire una struttura per la gestione dell’orario, che contenga tre interi, uno per le ore, uno per i minuti e uno per i secondi:</p>

<pre><code>struct orario {
    int h;
    int m;
    int s;
};
</code></pre>

<p>Per utilizzare questa struttura è necessario conoscerne il contenuto e il rapporto fra un valore e l’altro; in particolare, è necessario sapere (e ricordarsi):</p>

<ul>
  <li>che la variabile <code>h</code> può contenere solo valori da 0 a 23;</li>
  <li>che il valore di <code>m</code> può contenere solo valori da 0 a 59;</li>
  <li>che il valore di <code>s</code> può contenere solo valori da 0 a 59;</li>
  <li>che se <code>s</code> supera il valore di 59, <code>m</code> va incrementato di 1;</li>
  <li>che se <code>m</code> supera il valore di 59, <code>h</code> va incrementato di 1;</li>
</ul>

<p>Questo è l’opposto del <em>low coupling</em> di cui abbiamo parlato <a href="/man/struttura-dei-programmi#coupling" class="xref">tempo fa</a>, perché lega indissolubilmente una funzione alla struttura del dato che deve gestire.
Per capirsi: una funzione di aggiornamento dei minuti dovrà essere qualcosa di simile a:</p>

<pre><code>void aggiornaMinuti(struct orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}
</code></pre>
<p>Se un giorno decidessimo di modificare la struttura <code>orario</code>, dovremmo ricordarci di riscrivere anche questa funzione, adeguandola alle nuove caratteristiche della struttura, con un dispendio di tempo e maggiore possibilità di fare degli errori.
Inoltre, nulla impedirebbe a un programmatore cialtrone di scrivere una funzione che non tiene minimamente conto del rapporto fra i ore, minuti e secondi:</p>

<pre><code>void incrementa_m(struct orario &amp;o, int minuti) 
{
    o.m += minuti;
}
</code></pre>

<p>Se inseriamo queste due funzioni in un programma, otteniamo:</p>

<pre><code>/** 
 * @file classi-struttura-orario.cpp
 * Gestione dei dati membro di una struct.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione di una struttura per gestire un orario */
struct Orario {
    int h;
    int m;
    int s;
};

/** Funzione per l'incremento dei minuti */
void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}

/*  Funzione cialtrona per l'incremento dei minuti */
void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}

int main()
{    
    struct Orario ora;

    /** Definisce dei valori iniziali prossimi al cambio di data */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Visualizza i valri iniziali */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Richiama la funzione di aggiornamento */
    aggiornaMinuti(ora, 20);
    
    /** Visualizza i valori dopo l'aggiornamento */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Reimposta i valori iniziali */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Richiama la funzione cialtrona */
    incrementa_m(ora, 20);
    
    /** Visualizza i valori dopo l'aggiornamento */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    
    return 0;
}

</code></pre>

<p>Compilando ed eseguendo questo codice, ottieni:</p>

<pre><code>&gt; g++ src/cpp/classi-struttura-orario.cpp -o src/out/esempio 
&gt; ./src/out/esempio                                          
23:45:00
00:05:00
23:65:00
</code></pre>
<p>Come puoi vedere, la prima funzione ha aggiornato i dati in maniera corretta, mentre la seconda ha prodotto un valore non valido.</p>

<hr />

<blockquote>
  <p>Per questa ragione il selvaggio non ama dire il suo nome o farsi fotografare, perché per mezzo del suo nome o del ritratto egli è accessibile, e può quindi ricevere danno da chi con questi mezzi è in grado di raggiungerlo<a href="/man/note#selvaggio" class="nota"></a>.</p>
</blockquote>

<p>Questa frase di Lucien Lévy-Bruhl si applica anche alle classi del C++.<br />
Le variabili all’interno di una classe, sono dette <em>dati membro</em> o <em>attributi</em> della classe; le funzioni, invece, sono dette <em>funzioni membro</em> o <em>metodi</em>.
Sia gli attributi che i metodi di una classe possono essere protette da letture o modifiche indebite grazie a delle parole-chiave, dette: <em>modificatori di accesso</em>.
I modificatori di accesso sono tre: <code>private</code>, <code>protected</code> e <code>public</code>.
I metodi o gli attributi dichiarati <em>private</em> sono accessibili solo alla classe stessa; quelli dichiarati come <em>protected</em> sono accessibili alla classe e a eventuali <a href="/man/ereditarieta" class="xref">classi derivate</a>; quelli dichiarati come <em>public</em> sono accessibili a qualunque elemento del programma.<br />
Se convertiamo in classe la struttura <code>Orario</code>, otteniamo:</p>

<pre><code>class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
};
</code></pre>
<p>Gli attributi <code>_h</code>, <code>_m</code> e <code>_s</code> compaiono dopo la parola-chiave <code>private</code> e saranno quindi visibili solo alle funzioni della classe stessa.<br />
La funzione <code>Orario</code>, che ha lo stesso nome della classe, è detta <em>costruttore</em> e viene richiamata ogni volta che si crea una variabile di tipo <code>Orario</code>.
Il suo scopo è di inizializzare le variabili all’interno della classe, in questo caso, impostando tutti e tre i valori a 0.<br />
Una stessa classe può avere più costruttori; la classe <code>Orario</code>, per esempio, potrebbe avere un costruttore privo di parametri, che inizializzi ore, minuti e secondi a zero e uno che permetta invece di assegnare valori specifici a ciascun attributo:</p>

<pre><code>class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
    Orario(int h, int m, int s) 
    : _h(h), _m(m), _s(s){
    }
};
</code></pre>

<p>La forma:</p>

<pre><code>Orario(int h, int m, int s) 
: _h(h), _m(m), _s(s){
}
</code></pre>

<p>è solo un altro modo per inizializzare i dati membro della classe ed equivale a scrivere:</p>

<pre><code>_h = h;
_m = m;
_s = s;
</code></pre>

<p>Un modo più succinto di ottenere lo stesso risultato con un unico costruttore è di utilizzare dei valori di default per i parametri:</p>

<pre><code>Orario(int h = 0, int m = 0, int s = 0) 
: _h(h), _m(m), _s(s) {
}
</code></pre>

<p>Le funzioni membro devono essere dichiarate all’interno della dichiarazione della classe, ma possono essere definite sia dentro che fuori di essa. 
Se le si definisce esternamente alla dichiarazione della classe, vanno identificate aggiungendo il nome della classe prima di quello della funzione:</p>

<pre><code>/** 
 * @file classi-classe-orario-1.cpp
 * Gestione dei dati membro di una classe.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione della classe */
class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario(int h = 0, int m = 0, int s = 0);
};

/** Definizione del costruttore della classe */
Orario::Orario(int h, int m, int s) 
: _h(h), _m(m), _s(s) 
{
}
    
/** La funzione main non fa parte della classe */
int main()
{    
    Orario ora;

    /** Questo codice darà errore */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>Se compili questo codice, però, ottieni un errore: la funzione <code>main</code> può utilizzare il costruttore della classe <code>Orario</code> perché è dichiarato <code>public</code>, ma non può né leggere né modificare gli attributi `private:</p>

<pre><code class="language- ">&gt; g++ src/cpp/classi-classe-orario-1.cpp -o src/out/esempio
src/cpp/classi-classe-orario-1.cpp:34:44: error: '_h' is a protected member of 'Orario'
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
                                           ^
src/cpp/classi-classe-orario-1.cpp:14:9: note: declared protected here
    int _h;
        ^
src/cpp/classi-classe-orario-1.cpp:35:44: error: '_m' is a protected member of 'Orario'
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
                                           ^
src/cpp/classi-classe-orario-1.cpp:15:9: note: declared protected here
    int _m;
        ^
src/cpp/classi-classe-orario-1.cpp:36:44: error: '_s' is a protected member of 'Orario'
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
                                           ^
src/cpp/classi-classe-orario-1.cpp:16:9: note: declared protected here
    int _s;
        ^
3 errors generated.
</code></pre>

<p>Per rendere disponibili gli attributi di una classe, si utilizzano delle funzioni dette: <em>funzioni di interfaccia</em>, che permettono un accesso controllato ai dati sia in lettura che in modifica. 
Nel caso della classe <code>Orario</code>, ne occorrono sei: una la lettura e una per la scrittura di ciascuno dei tre dati membro:</p>

<pre><code>/** Funzioni di lettura inline */
inline int getH() { return _h; }
inline int getM() { return _m; }
inline int getS() { return _s; }

/** Funzioni di scrittura inline */
inline int setH(int h) { return _h = (h % 24); }
inline int setM(int m) { return _m = (m % 60); }
inline int setS(int s) { return _s = (s % 60); }
</code></pre>

<p>Ovviamente, puoi chiamare queste funzioni come preferisci, ma utilizzare i prefissi <code>get</code> e <code>set</code>, seguiti dal nome del parametro su cui operano rende più facile l’utilizzo della classe da parte di altri programmatori.
È lo stesso motivo per cui aggiungo il carattere <em>underscore</em> davanti al nome dei dati membro delle classi, in modo che li si possa distinguere dai  parametri delle funzioni che abbiano lo stesso nome:</p>

<pre><code>return _h = (h % 24);
</code></pre>
<p>Non nemmeno sei obbligato a dichiarare le funzioni di interfaccia come <code>inline</code>; l’ho fatto qui perché erano estremamente semplici, ma valgono sempre le considerazioni fatte <a href="/man/funzioni#inline" class="xref">a suo tempo</a>.<br />
Così come abbiamo fatto per il costruttore della classe, potremmo unificare le funzioni di lettura e scrittura, utilizzando un parametro di default che determini il comportamento del programma:</p>

<pre><code>inline int ore(int h = -1) { 
    return _h = ((h != -1) ? _h = (h % 24) : h); 
}
</code></pre>

<p>Questa sintassi è l’equivalente di:</p>

<pre><code>inline int ore(int h = -1) { 
    if(h != -1) {
        _h = (h % 24);
    }
    return _h; 
}
</code></pre>

<p>Anche se meno evidente, è più comoda perché permette di tenere il codice su una sola riga e ti dà modo di fare un po’ di pratica con gli operatori.<br />
Questo tipo di funzioni, però, ha due difetti: limita i valori che puoi assegnare all’attibuto e limita la granularità dei privilegi sulle funzioni.
Limita il numero di valori che puoi assegnare all’attibuto, perché esclude il valore del parametro di default; cosa che non crea problemi in questo caso, dato che non esiste un’ora <code>-1</code>, ma che potrebbe farlo nel caso di una stringa con parametro di default nullo.
Limita la granularità dei privilegi sulle funzioni, perché ti costringe a rendere pubbliche le funzioni di scrittura dei dati membro e questo, in certi casi potrebbe non essere saggio. 
Ti consiglio perciò di scrivere sempre due funzioni di interfaccia distinte per la lettura e la scrittura: sul momento ti sembrerà uno spreco di tempo, ma, a meno che il tuo programma non sia particolarmente banale, o prima o poi ti accorgerai di aver fatto la scelta corretta.</p>

<!-- 

\[cfr. *Breve storia dell'infinito*, pagg. 30-40\]

Si può dire che esista qualcosa che non ha dimensioni?


parlare degli operatori di cast 
dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)


@todo: parlare della posizione di un certo dato in memoria, che può variare in successive esecuzioni del programma. Allo stesso modo, l'io cosciente di ciascuno di noi non è detto che si manifesterà nello stesso individuo, ma potrà essere "allocato" in altri esseri. In quest'ottica, il: "Cogito ergo sum" di Cartesio è insensato, perché ciò che cogita non è ciò che è. cfr. Ananda, note a capitolo sull'Induismo

@todo: Utlizzare l'operatore `delete` per illustrare il rapporto del C’hi++ con la morte, che non è più considerata un nemico da combattere, ma un fenomeno naturale necessario al buon funzonamento dell’Universo. 
Questo approccio si rirova anche nel precetto:

    Amiamo ciò che ci ucciderà (se tutto va bene) 


-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/istruzioni-iterative" 
           title="Vai a: Istruzioni iterative" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/oggetti" 
           title="Vai a: Gli oggetti" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
