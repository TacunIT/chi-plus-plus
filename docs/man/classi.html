<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Le classi |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Le classi" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    <a title="Vai a: Istruzioni iterative" 
        
        href="/man/istruzioni-iterative" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Gli oggetti" 
        
        href="/man/oggetti" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Le classi
            </h1>

            <blockquote class="motto">Ceci n'est pas une |</blockquote>

            <section id="testo">

                <!-- Quando ho cominciato a scrivere questo capitolo, si è rotto il tasto "o" del mio Mac. È Domenica e siamo in clausura da COVID, quindi non posso andare in un centro commerciale a comprarne una esterna, temporanea. Perdonate eventuali refusi -->
<p>La possibilità di definire nuovi tipi di dato grazie alle classi è la caratteristica principale del C++.</p>

<p>I linguaggi di programmazione “tradizionali”, come il Cobol il Fortran o il Pascal, hanno un insieme limitato di tipi di dato: interi, numeri in virgola mobile, booleani, caratteri e stringhe.. giusto quello che serve a gestire una scheda anagrafica o un conto in banca.
Il C e il Pascal hanno anche la possibilità di accorpare questi dati in strutture, enumerati o array, ma si tratta solo di contenitori, privi di logica interna.
Inoltre, come hai visto, i dati all’interno di una <code>struct</code> sono accessibili a qualunque componente del programma, quindi, se li si modifica, va modificato anche il codice che li utilizza.
Immagina di definire una struttura per la gestione dell’orario, che contenga tre interi, uno per le ore, uno per i minuti e uno per i secondi:</p>

<pre><code>struct Orario {
    int h;
    int m;
    int s;
};
</code></pre>

<p>Per utilizzare questa struttura è necessario conoscerne il contenuto e il rapporto fra un valore e l’altro; in particolare, è necessario sapere (e ricordarsi):</p>

<ul>
  <li>che la variabile <code>h</code> può contenere solo valori da 0 a 23;</li>
  <li>che il valore di <code>m</code> può contenere solo valori da 0 a 59;</li>
  <li>che il valore di <code>s</code> può contenere solo valori da 0 a 59;</li>
  <li>che se <code>s</code> supera il valore di 59, <code>m</code> va incrementato di 1;</li>
  <li>che se <code>m</code> supera il valore di 59, <code>h</code> va incrementato di 1;</li>
</ul>

<p>Questo è l’opposto del <em>low coupling</em> di cui abbiamo parlato <a href="/man/struttura-dei-programmi#coupling" class="xref">tempo fa</a>, perché lega indissolubilmente una funzione alla struttura del dato che deve gestire.
Per capirsi: una funzione di aggiornamento dei minuti dovrà essere qualcosa di simile a:</p>

<pre><code>void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}
</code></pre>
<p>Se un giorno decidessimo di modificare la struttura <code>Orario</code>, dovremmo ricordarci di riscrivere anche questa funzione, adeguandola alle nuove caratteristiche della struttura, con dispendio di tempo e la possibilità di fare degli errori.
Inoltre, nulla impedirebbe a un programmatore cialtrone di scrivere una funzione che non tiene minimamente conto del rapporto fra ore, minuti e secondi:</p>

<pre><code>void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}
</code></pre>

<p>Se inseriamo queste due funzioni in un programma, otteniamo:</p>

<pre><code>/** 
 * @file classi-struttura-orario.cpp
 * Gestione dei dati membro di una struct.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione di una struttura per gestire un orario */
struct Orario {
    int h;
    int m;
    int s;
};

/** Funzione per l'incremento dei minuti */
void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}

/*  Funzione cialtrona per l'incremento dei minuti */
void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}

int main()
{    
    struct Orario ora;

    /** Definisce dei valori iniziali prossimi al cambio di data */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Visualizza i valri iniziali */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Richiama la funzione di aggiornamento */
    aggiornaMinuti(ora, 20);
    
    /** Visualizza i valori dopo l'aggiornamento */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Reimposta i valori iniziali */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Richiama la funzione cialtrona */
    incrementa_m(ora, 20);
    
    /** Visualizza i valori dopo l'aggiornamento */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    
    return 0;
}

</code></pre>

<p>Compilando ed eseguendo questo codice, ottieni:</p>

<pre><code>&gt; g++ src/cpp/classi-struttura-orario.cpp -o src/out/esempio 
&gt; ./src/out/esempio                                          
23:45:00
00:05:00
23:65:00
</code></pre>
<p>Come puoi vedere, la prima funzione ha aggiornato i dati in maniera corretta, mentre la seconda ha prodotto un valore non valido senza alcuna possibilità di controllo da parte del programma.</p>

<hr id="attributi-metodi" />

<p>Le variabili all’interno di una classe, sono dette <em>dati membro</em> o <em>attributi</em> della classe; le funzioni, invece, sono dette <em>funzioni membro</em> o <em>metodi</em>.
Quando si crea una variabile di classe <code>X</code>, si dice che si: <em>istanzia</em> un <em>oggetto</em> di classe <code>X</code> o che si crea una <em>istanza</em> della classe.
I dati e le funzioni membro di una classe sono direttamente accessibili alle funzioni membro della classe, ma per utilizzarli all’interno di funzioni esterne alla classe, si devono utilizzare gli operatori di selezione <code>.</code> e <code>-&gt;</code>. 
Il primo, detto <em>operatore di selezione diretta</em>, viene utilizzato con istanze della classe; il secondo, detto <em>operatore di selezi­one indiretta</em>, con puntatori ad esse:</p>

<pre><code>class Punto
{
public:             
    
    /** Dichiara i dati membro della classe */
    int _x, _y;

    /** 
     *  Le funzioni interne alla classe accedono ai
     *  dati membro con la sintassi ordinaria.
     */  
    Punto(int x, int y) {
        _x = x;
        _y = y;
    }
} ;

int main(int argc, char** argv) 
{
    /** Crea un oggetto di classe Punto */
    Punto p(5,6);       

    /** Assegna l'istanza della classe al puntatore ptr */
    Punto *ptr = &amp;p ;   
    
    /** 
     *  Le funzioni esterne alla classe accedono ai
     *  dati membro tramite gli operatori di selezione.
     */  
    p._x    = 3 ;       // assegna un valore tramite l'oggetto
    ptr-&gt;_y = 2 ;       // assegna un valore tramite il puntatore
    ...
}
</code></pre>

<p>L’etichetta <code>public</code> che vedi all’inizio della dichiarazione della classe è un <em>indicatore di accesso</em> e serve a stabilire quali membri della classe siano accessibili a funzioni esterne e quali invece siano riservati in esclusiva alla classe stessa.</p>

<blockquote>
  <p>il selvaggio non ama dire il suo nome o farsi fotografare, perché per mezzo del suo nome o del ritratto egli è accessibile, e può quindi ricevere danno da chi con questi mezzi è in grado di raggiungerlo<a href="/man/note#selvaggio" class="nota"></a>.</p>
</blockquote>

<p>Questa frase di Lucien Lévy-Bruhl si applica anche alle classi del C++. 
Sia gli attributi che i metodi di una classe possono essere protetti da accessi o modifiche indebite grazie ai modificatori di accesso <code>private</code>, <code>protected</code> e <code>public</code>.
I metodi o gli attributi dichiarati <em>private</em> sono accessibili solo alla classe stessa; quelli dichiarati come <em>protected</em> sono accessibili alla classe e a eventuali <a href="/man/ereditarieta" class="xref">classi derivate</a>; quelli dichiarati come <em>public</em> sono accessibili a qualunque elemento del programma.
In mancanza di specifiche, tutti i dati e le funzioni di una classe verranno considerati:</p>

<ul>
  <li><em>privati</em>, nel caso di una classe;</li>
  <li><em>pubblici</em>, nel caso di <code>struct</code> o <code>union</code>.</li>
</ul>

<p>La visibilità dei dati membro di una  <code>struct</code> può essere modificata con gli indicatori di accesso; i dati delle <code>union</code>, invece, possono essere solo pubblici.<br />
Il C++ permette di suddividere la dichiarazione di una classe in quante sezioni si desidera e nella sequenza <code>private</code>, <code>public</code>, <code>pro­tected</code> che si preferisce, ma un codice scritto in questo modo è sicuramente più difficile da leggere di uno in cui tutti i membri privati stanno da una parte e tutti quelli pubblici da un’altra.
Quindi, a meno che tu non abbia delle buone ragioni per fare altrimenti (e ce ne potrebbero essere, nel caso di classi particolarmente complesse), cerca di raggruppare in tre sole sezioni <code>private</code>, <code>pro­tected</code> e <code>public</code> tutte le funzioni e i dati membro con gli stessi attributi di accesso:</p>

<pre><code>class Persona
{
 private:
    ...
 protected:
    ...
 public:
    ...
};
</code></pre>

<p>Questo tipo di ordinamento della dichiarazione, oltre a garantirti una maggiore leggibilità del codice, ti consentirà, se lo desideri, di omettere l’indicatore di accesso <code>private</code> iniziale (è la soluzione di default, ricordi?).<br />
Mettiamo in pratica tutto ciò, convertendo in classe la struttura <code>Orario</code>:</p>

<pre><code>class Orario {
private:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
};
</code></pre>

<p>La dichiarazione inizia con la parola-chiave <code>class</code>, seguìta dal nome della classe.
Nel blocco di codice fra parentesi graffe che costituisce il corpo della classe, contiene i dati e le funzioni membro, accorpate per visibilità. 
In questo caso abbiamo messo prima i dati membro privati e poi quelli pubblici, ma avremmo potuto fare anche il contrario.
Gli attributi <code>_h</code>, <code>_m</code> e <code>_s</code> compaiono dopo la parola-chiave <code>private</code> e saranno quindi visibili solo alle funzioni della classe stessa.<br />
La funzione <code>Orario</code> compare dopo l’etichetta <code>public</code> e sarà accessibile per ciò a qualsiasi parte del programma.
Questa funzione, che ha lo stesso nome della classe, è detta <em>costruttore</em> e viene richiamata ogni volta che si crea una variabile di tipo <code>Orario</code>.
Il suo scopo è di inizializzare le variabili all’interno della classe, in questo caso, impostando tutti e tre i valori a 0. 
Ne parleremo fra poco.<br />
L’ultima cosa che devi notare, nel codice qui sopra, è la presenza del carattere <code>;</code> alla fine del blocco di codice della classe, così come avviene per le <code>union</code> e le <code>struct</code>.</p>

<hr id="costruttori" />

<p>Quando dichiariamo una variabile di tipo primitivo come <code>int</code>, o <code>double</code>, il compilatore svolge automaticamente tutta una serie di operazioni atte ad allocare lo spazio di memoria necessario a contenerla e a inizializzarlo.
Il compilatore, però, non sa come vada creata e inizializzata una variabile di tipo <code>Orario</code> ed è per questo che la classe dovrà definire delle <em>funzioni di gestione</em> che spieghino sia come creare una nuova variabile, che come distruggerla, se necessario. 
Le funzioni di gestione sono di due tipi: i <em>costruttori</em> e i <em>distruttori</em>.<br />
I costruttori hanno alcune peculiarità che le distin­guono dalle altre funzioni membro:</p>

<ul>
  <li>hanno lo stesso nome della classe;</li>
  <li>non hanno un tipo di ritorno perché è implicito che ritornino una variabile   della classe cui appartengono.</li>
</ul>

<p>Una stessa classe può avere più costruttori; la classe <code>Orario</code>, per esempio, potrebbe avere un costruttore privo di parametri, che inizializzi ore, minuti e secondi a zero e un costruttore che permetta invece di assegnare valori specifici a ciascun attributo:</p>

<pre><code>class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
    Orario(int h, int m, int s) 
    : _h(h % 24), _m(m % 60), _s(s % 60) {
    }
};
</code></pre>

<p>La riga:</p>

<pre><code>: _h(h % 24), _m(m % 60), _s(s % 60) 
</code></pre>

<p>si chiama: <em>lista di inizializzazione</em> e ed equivale a scrivere:</p>

<pre><code>_h = h % 24;
_m = m % 60;
_s = s % 60;
</code></pre>

<p>L’utilizzo dell’operatore modulo <code>%</code> è indispensabile, in questo caso, per evitare che siano assegnati valori non corretti alle variabili.<br />
Quando definisci un costruttore, puoi usare indifferentemente l’una o l’altra sintassi o anche mischiarle, a seconda dei casi.
Un modo più succinto di ottenere lo stesso risultato con un unico costruttore è di utilizzare dei valori di default per i parametri:</p>

<pre><code>Orario(int h = 0, int m = 0, int s = 0) 
: _h(h % 24), _m(m % 60), _s(s % 60) {
}
</code></pre>

<p>Alle volte, può essere utile definire un costruttore che crei delle nuove variabili della classe partendo da variabili esis­tenti, operando quindi una sorta di clonazione. 
Questo tipo di funzioni si chiamano: <em>costruttori di copia</em> o: <em>costruttori di inizializ­zazione</em> e richiedono come argomento un riferimento a una variabile della stessa classe:</p>

<pre><code>/** 
 * Dichiarazione del costruttore di copia 
 * all'interno della classe. 
 * Possiamo copiare il valore delle variabili 
 * così com'è perché è già stato verificato 
 * dal costruttore della variabile o1.  
 */
Orario::Orario(const Orario&amp; )
: _h(o._h), _m(o._m), _s(o._s) {
}

/** Utilizzo */
Orario o2 = o1;
</code></pre>

<p>Il costruttore di copia è un tipo di costruttore molto importante in quanto presiede alla maggior parte delle attività di inizializzazione di oggetti della classe cui appartiene; per questa ragione, nel caso non venga definito dall’utente, è automaticamente generato dal compilatore.</p>

<hr id="distruttori" />

<p>Come è facile intuire, mentre il costruttore di una classe presiede alla creazione di nuove variabili, il distruttore si occupa della loro cancellazione. 
Non sempre è necessario definire un distruttore per una classe.
Una variabile di tipo <code>Orario</code>, che contiene solo tre interi, probabilmente non avrà bisogno di un distruttore, mentre una variabile che faccia uso di memoria dinamica quasi sicuramente sì. 
Il perché risulta più chiaro se si esamina la cosa dal punto di vista del compilatore.
Per creare una variabile di tipo <code>Orario</code> il compilatore deve allocare spazio per:</p>

<pre><code>3 * sizeof(int);
</code></pre>

<p>Quando arriva il momento di distruggere la variabile, il compilatore non farà altro che liberare i <code>3 * sizeof(int)</code> byte successivi all’indirizzo dell’oggetto; un comportamento che in questo caso è corretto, ma che potrebbe dare rivelarsi disastroso con una classe come questa:</p>

<pre><code>class Buffer
{
private:
    char* _dati;
    int   _size;
 public:
    Buffer(int size) 
    : _size(size) {
        _dati = new char[_size];
    }
    ...
};
</code></pre>

<p>In mancanza di istruzioni specifiche, per distruggere una variabile di tipo <code>Buffer</code>, il compilatore libererà <code>sizeof(char*) + sizeof(int)</code> byte dopo il suo indirizzo di memoria, ma così facendo, distruggerà solo l’intero <code>_size</code> e il puntatore a char <code>_dati</code>, senza liberare l’area di memoria a cui quest’ultimo puntava.
Questo, come sai, è un grave errore ed è necessario quindi aggiungere alla classe una funzione che lo istruisca in tal senso. <br />
Come il costruttore, il distruttore di una classe non ha tipo di ritorno, ma mentre ci possono essere più costruttori per una stessa classe, il distrut­tore è sempre unico.
Non ha mai parametri formali e il suo nome è uguale a quello della classe cui appartiene, preceduto da un carattere tilde <code>~</code>:</p>

<pre><code>class Buffer
{
private:
    char* _dati;
    int   _size;
 public:
    Buffer(int size) 
    : _size(size) {
        _dati = new char[_size];
    }
    ~Buffer() {
        delete [] _dati
    }
};
</code></pre>

<p>I distruttori possono essere chiamati in due modi:</p>

<ul>
  <li>
    <p><em>implicitamente</em>, dal programma, ogni volta che un oggetto esce dal suo campo d’azione o, nel caso di oggetti con visibilità globale, al termine della funzione <code>main</code>;</p>
  </li>
  <li>
    <p><em>esplicitamente</em>, dal codice, ma in questi casi dovrai specificare il loro nome per intero, anteponendo il nome della classe e l’operatore di risoluzione <code>::</code>, così come vedremo fra poco.</p>
  </li>
</ul>

<p>Attenzione, però: se a uscire dal campo d’azione è un puntatore, il ditruttore della classe non viene richiamato automaticamente, perciò gli oggetti creati in maniera dinamica con l’operatore <code>new</code> dovranno sempre distrutti per mezzo dell’operatore <code>delete</code>.</p>

<hr id="funzioni-di-interfaccia" />

<p>Le funzioni membro devono essere dichiarate all’interno della dichiarazione della classe e possono essere definite sia dentro che fuori di essa. 
Definirle all’interno della dichiarazione della classe equivale a dichiararle <a href="/man/funzioni#inline" class="xref">inline</a>
Se invece le si definisce esternamente alla dichiarazione della classe, vanno identificate aggiungendo il nome della classe prima di quello della funzione, seguito dall’<a href="/man/operatori#risoluzione" class="xref">operatore di risoluzione</a>:</p>

<pre><code>/** 
 * @file classi-classe-orario.cpp
 * Gestione dei dati membro di una classe.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione della classe */
class Orario {
private:
    int _h;
    int _m;
    int _s;
public:
    Orario(int h = 0, int m = 0, int s = 0);
};

/** Definizione del costruttore della classe */
Orario::Orario(int h, int m, int s) 
: _h(h % 24), _m(m % 60), _s(s % 60) 
{
}
    
/** La funzione main non fa parte della classe */
int main()
{    
    Orario ora;

    /** Questo codice darà errore */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>Se compili questo codice, però, ottieni un errore: la funzione <code>main</code> può utilizzare il costruttore della classe <code>Orario</code> perché è dichiarato <code>public</code>, ma non può né leggere né modificare gli attributi definiti come <code>private</code>:</p>

<pre><code class="language- ">&gt; g++ src/cpp/classi-classe-orario-1.cpp -o src/out/esempio
src/cpp/classi-classe-orario-1.cpp:34:44: error: '_h' is a protected member of 'Orario'
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
                                           ^
src/cpp/classi-classe-orario-1.cpp:14:9: note: declared protected here
    int _h;
        ^
src/cpp/classi-classe-orario-1.cpp:35:44: error: '_m' is a protected member of 'Orario'
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
                                           ^
src/cpp/classi-classe-orario-1.cpp:15:9: note: declared protected here
    int _m;
        ^
src/cpp/classi-classe-orario-1.cpp:36:44: error: '_s' is a protected member of 'Orario'
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
                                           ^
src/cpp/classi-classe-orario-1.cpp:16:9: note: declared protected here
    int _s;
        ^
3 errors generated.
</code></pre>

<p>Il C++ prevede due modi per rendere disponibili gli attributi di una classe anche alle funzioni esterne alla classe stessa:</p>

<ul>
  <li>le classi o le funzioni <code>friend</code>.</li>
  <li>le <em>funzioni di interfaccia</em>;</li>
</ul>

<p>Il modo apparentemente più rapido per accedere ai dati privati di una classe attraverso una funzione o una classe esterna è quello di dichiararle come <code>friend</code>.
In virtù di ciò, la funzione o la classe acquisteranno una visibilità completa sui dati protetti:</p>

<pre><code>class Orario {
private:

    /** Dati membro privati */
    int _h;
    int _m;
    int _s;

public:
    
    /** Costruttore della classe */
    Orario(int h = 0, int m = 0, int s = 0) ;

    /** Costruttore di copia inline */
    Orario(const Orario&amp; o) {
        _h = o._h;
        _m = o._m;
        _s = o._s;
    }

    /** Funzioni di lettura  */
    int getH() { return _h; }
    int getM() { return _m; }
    int getS() { return _s; }

    /** Funzioni di scrittura */
    int setH(int h) { return _h = (h % 24); }
    int setM(int m) { return _m = (m % 60); }
    int setS(int s) { return _s = (s % 60); }

    /** Dichiarazione di una funzione friend */
    friend int aggiornaMinuti(Orario&amp; o, int m);
    friend class Orologio(); 	

};
</code></pre>

<p>Come ho detto, questa soluzione è solo apparentemente più rapida, perché tutta la logica di gestione dei dati della classe <code>Orario</code> dovrà essere replicata sia nella funzione <code>aggiornaMinuti</code> che nella classe <code>Orologio</code>.
Inoltre, se in seguito dovessi apportare delle modifiche alla classe <code>Orario</code>, le stesse modifiche andranno riportate anche nelle funzioni delle classi <code>friend</code> che la utilizzano.<br />
Un metodo più sicuro e più efficiente di gestire gli attributi privati di una classe consiste nel definire delle funzioni membro pubbliche che consentano un accesso controllato ai dati che si vogliono proteggere. 
Nel caso della classe <code>Orario</code>, ne occorrono sei: una per la lettura e una per la scrittura di ciascuno dei tre dati membro:</p>

<pre><code>/** Funzioni di lettura */
int getH() { return _h; }
int getM() { return _m; }
int getS() { return _s; }

/** Funzioni di scrittura */
int setH(int h) { return _h = (h % 24); }
int setM(int m) { return _m = (m % 60); }
int setS(int s) { return _s = (s % 60); }
</code></pre>

<p>Ovviamente, puoi chiamare queste funzioni come preferisci, ma utilizzare i prefissi <code>get</code> e <code>set</code>, seguiti dal nome del parametro su cui operano rende più facile l’utilizzo della classe da parte di altri programmatori.
È lo stesso motivo per cui aggiungo il carattere <em>underscore</em> davanti al nome dei dati membro delle classi, in modo che li si possa distinguere dai  parametri delle funzioni che abbiano lo stesso nome:</p>

<pre><code>return _h = (h % 24);
</code></pre>

<p>L’utilizzo della lista di inzializzazione, all’interno del costruttore, ti permette di utilizzare dei parametri che abbiano lo stesso nome dei dati membro della classe:</p>

<pre><code>class Punto
{
    int x, y;
public:             
    Punto(int x, int y) 
    : x(x), y(y) {
    }
};
</code></pre>
<p>ma il fatto che qualcosa sia possibile non vuol dire che sia una buona scelta, come penso che tu abbia imparato, nel corso della tua vita.<br />
Non sei nemmeno obbligato a dichiarare le funzioni di interfaccia come <code>inline</code>; l’ho fatto qui perché erano estremamente semplici, ma si dovrebbe evitare di aggiungere il codice delle funzioni all’interno della dichiarazione di una classe già di per sé complessa perché la rende più difficile da leggere.
C’è anche chi pensa che ciò sia sbagliato perché, se da un lato rende le cose più facili a chi scrive il codice, complica la vita di chi lo legge perché mischia ciò che la classe fa con il modo in cui lo fa<a href="/man/note#inline" class="nota"></a>.
Io non sono del tutto d’accordo con questa affermazione perché alle volte è più comodo e rapido avere il codice delle funzioni all’interno della dichiarazione della classe, ma essendo un precetto che antepone il bene di tanti (i fruitori del codice) rispetto a quello del singolo (l’autore del codice), mi sono sentito in dovere di riferirtelo.<br />
Così come abbiamo fatto per il costruttore della classe, potremmo unificare le funzioni di lettura e scrittura, utilizzando un parametro di default che determini il comportamento del programma:</p>

<pre><code>int ore(int h = -1) { 
    return _h = ((h != -1) ? _h = (h % 24) : h); 
}
</code></pre>

<p>Questa sintassi è l’equivalente di:</p>

<pre><code>int ore(int h = -1) { 
    if(h != -1) {
        _h = (h % 24);
    }
    return _h; 
}
</code></pre>

<p>Anche se meno evidente, è più comoda perché permette di tenere il codice su una sola riga e ti dà modo di fare un po’ di pratica con gli operatori.<br />
Questo tipo di funzioni, però, ha due difetti: limita i valori che puoi assegnare all’attibuto e limita la granularità dei privilegi che puoi assegnare a chi utilizza la classe.
Limita il numero di valori che puoi assegnare all’attibuto, perché esclude il valore del parametro di default — cosa che non crea problemi in questo caso, dato che non esiste un’ora <code>-1</code>, ma che potrebbe farlo nel caso di una stringa con parametro di default nullo.
Limita la granularità dei privilegi sulle funzioni, perché ti costringe a rendere pubbliche le funzioni di scrittura dei dati membro e questo, in certi casi potrebbe non essere saggio. 
Ti consiglio perciò di scrivere sempre due funzioni di interfaccia distinte per la lettura e la scrittura: sul momento ti sembrerà uno spreco di tempo, ma, a meno che il tuo programma non sia particolarmente banale, o prima o poi ti accorgerai di aver fatto la scelta corretta.</p>

<hr id="static" />

<p>Ogni variabile di una determinata classe possiede delle copie dei dati membro, mentre le funzioni membro di una classe sono condivise da tutte le sue istanze.
Per consentire al programma di sapere quale sia l’istanza che sta richiamando un determinato metodo, il compilatore aggiuge a ogni chiamata a funzione un parametro nascosto chiamato <code>this</code>, che punta all’istanza che ha richiesto la funzione.
Il parametro <code>this</code>, anche se non dichiarato, può essere utilizzato nel corpo delle funzioni membro per riferirsi all’istanza corrente.
Per esempio, il costruttore di copia della classe <code>Orario</code> (così come qualsiasi altra funzione membro della classe) potrebbe essere riscritto così:</p>

<pre><code>Orario(const Orario&amp; o) {
    this-&gt;_h = o._h;
    this-&gt;_m = o._m;
    this-&gt;_s = o._s;
}
</code></pre>

<p>Le uniche funzioni membro che non possono fare uso del puntatore <code>this</code> sono quelle dichiarate come <code>static</code>.<br />
Una classe può avere sia attributi che funzioni membro statiche.
La particolarità di questi elementi è di non essere legati a una specifica variabile, ma di essere condivisi da tutte le istanze della classe; questo fa sì che abbiano un comportamento leggermente diverso da quello dei membri non statici:</p>

<ul>
  <li>
    <p>per inizializzarli all’interno della dichiarazione, li si deve dichiarare come <code>inline static</code><a href="/man/note#cpp17" class="nota"></a>, 
altrimenti, devono essere inizializzati altrove nel programma, come un qualsiasi oggetto a visibilità globale;</p>
  </li>
  <li>
    <p>si può accedere ad essi, oltre che con i normali operatori di selezione, facendo riferimento alla classe stessa.</p>
  </li>
</ul>

<p>Cerco di chiarirti un po’ le idee con un esempio:</p>

<pre><code>/** 
 * @file classi-static.cpp
 * Funzioni e dati membro statici di una classe.
 */
 
#include &lt;iostream&gt;

using namespace std;

/** Classe generica con membri statici */
class Contatore {
private:

    /** Definisce il dato statico */
    static int _nIstanze;     

public:
    
    /** Il costruttore incrementa il numero di istanze */
    Contatore() {
        _nIstanze++;
    }
    
    /** Funzione di interfaccia statica */
    static int nIstanze() {  
        return _nIstanze;
    }
};

/** Inizializza il membro statico  */ 
int Contatore::_nIstanze = 0;

int main()
{    
    /** Crea la prima istanza della classe */
    Contatore c1;

    /** Richiama la funzione statica dall'oggetto */
    cout &lt;&lt; "Da istanza c1: " &lt;&lt; c1.nIstanze() &lt;&lt; endl;

    /** Crea altre due istanze della classe */
    Contatore c2, c3;
   
    /** 
     * Richiama la funzione statica dagli oggetti 
     * e direttamente dalla classe
     */
    cout &lt;&lt; "Da istanza c2: "&lt;&lt; c2.nIstanze()         &lt;&lt; endl;
    cout &lt;&lt; "Da istanza c3: "&lt;&lt; c3.nIstanze()         &lt;&lt; endl;
    cout &lt;&lt; "Dalla classe : "&lt;&lt; Contatore::nIstanze() &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, otterrai:</p>

<pre><code>&gt; g++ src/cpp/classi-static.cpp -o src/out/esempio
&gt; src/out/esempio                                 
Da istanza c1: 1
Da istanza c2: 3
Da istanza c3: 3
Dalla classe : 3
</code></pre>

<p>Come vedi, tutte le istanze della classe condividono lo stesso valore per il dato membro <code>nIstanze</code> e la funzione di interfaccia, dichiarata come <code>static</code>, può essere richiamata anche senza fare riferimento a un’istanza.
Per questo motivo, se utilizzi il puntatore <code>this</code> all’interno di una classe statica:</p>

<pre><code>static int nIstanze() {  
    return this-&gt;_nIstanze;
}
</code></pre>

<p>ottieni l’errore di compilazione:</p>

<pre><code>&gt; g++ src/cpp/classi-static.cpp -o src/out/esempio 
src/cpp/classi-static.cpp:26:16: error: invalid use of 'this' 
 outside of a non-static member function
        return this-&gt;_nIstanze;
               ^
1 error generated.
</code></pre>

<p>perché, se la funzione fosse chiamata direttamente dalla classe, <code>this</code> non puterebbe ad alcun oggetto.</p>

<hr id="dottrina" />

<p>Il più grosso problema che il Maestro Canaro dovette affrontare quando provò a fare il <em>porting</em> dell’<a href="/man/mitopoietica#universo-in-cpp" class="xref">Universo in C++</a> fu di definire una classe per la figura di Dio:</p>

<pre><code>/** 
 * @file classi-dio.cpp
 * Dichiarazione della classe Dio.
 */
 
#include &lt;iostream&gt;

using namespace std;

// Classe astratta da utilizzare come base
// per tutti gli elementi del Creato.
class Creatura {
public:
   // Funzione virtuale pura di verifica.
   virtual bool isGood() = 0;
   
};

// Classi derivate per la gestione degli 
// elementi del Creato.
class Mare   : public Creatura {
    bool isGood() { return true; }; 
};
class Uomo   : public Creatura { 
    bool isGood(); 
};
class Donna  : public Creatura {};
class Padre  : public Uomo     {};
class Figlio : public Uomo     {};
class Popolo : public Creatura {};

class  {
private:

    // Funzioni membro per la generazione degli elementi 
    // del Creato, accessibili solo alla classe. 
    Creatura* creaLuce();
    Creatura* creaStelle();
    Creatura* creaAcquaTerra();
    Creatura* creaPiante();
    Creatura* creaSoleLuna();
    Creatura* creaAnimali();

    // Funzioni per la generazione degli umani.
    Uomo&amp;  creaUomo();
    Donna&amp; creaDonna(Uomo&amp; adamo);

    // Interruzione per il settimo giorno.
    void shabat();
    
    // Funzioni di interfaccia con gli umani.
    bool scacciaDaEden(Uomo&amp; adamp, Donna&amp; eva);
    bool printComandamenti(ostream&amp; tavole);
    bool checkFede(Padre&amp; abramo, Figlio&amp; isacco);
    bool splitAcque(Mare&amp; marRosso, Popolo&amp; ebrei);

private:
    
    // Funzione membro accessibile anche alle 
    // classi figlio.
    bool donaVita(Uomo&amp; lazzaro);
    
public:

     // Funzione membro pubblica.
     // Torna il numero di preghiere da recitare.
    int rimettiPeccati(Creatura* fedele) { return 0;};
                   
} Dio;

</code></pre>
<p>In questo brano di codice, scritto dal Maestro Canaro, ci sono un paio di cose di cui non abbiamo ancora parlato.
La prima è il tipo di classe utilizzato, ovvero la <em>classe anonima</em>; la seconda è la genealogia di <em>classi derivate</em> dalla classe base <code>Creatura</code>.<br />
 Le classi anonime sono un tipo particolare di classe che, come dice il nome (perdonami il gioco di parole), non hanno nome e per ciò non possono avere né un construttore né un distruttore e non possono essere utilizzate né come parametri né come valori di ritorno delle funzioni.</p>

<!--
La:

```
class {
public:
...
private:
...

} Dio;

```


Visibilità delle classi.



parlare degli operatori di cast 
dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)


@todo: parlare della posizione di un certo dato in memoria, che può variare in successive esecuzioni del programma. Allo stesso modo, l'io cosciente di ciascuno di noi non è detto che si manifesterà nello stesso individuo, ma potrà essere "allocato" in altri esseri. In quest'ottica, il: "Cogito ergo sum" di Cartesio è insensato, perché ciò che cogita non è ciò che è. cfr. Ananda, note a capitolo sull'Induismo

@todo: Utlizzare l'operatore `delete` per illustrare il rapporto del C’hi++ con la morte, che non è più considerata un nemico da combattere, ma un fenomeno naturale necessario al buon funzonamento dell’Universo. 
Questo approccio si rirova anche nel precetto:

    Amiamo ciò che ci ucciderà (se tutto va bene) 


-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/istruzioni-iterative" 
           title="Vai a: Istruzioni iterative" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/oggetti" 
           title="Vai a: Gli oggetti" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
