<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Le classi |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Le classi" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    <a title="Vai a: Istruzioni iterative" 
        
        href="/man/istruzioni-iterative" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Gli oggetti" 
        
        href="/man/oggetti" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Le classi
            </h1>

            <blockquote class="motto">Ceci n'est pas une |</blockquote>

            <section id="testo">

                <!-- Quando ho cominciato a scrivere questo capitolo, si è rotto il tasto "o" del mio Mac. È Domenica e siamo in clausura da COVID, quindi non posso andare in un centro commerciale a comprarne una esterna, temporanea. Perdonate eventuali refusi -->
<p>La possibilità di definire nuovi tipi di dato grazie alle classi è la caratteristica principale del C++.</p>

<p>I linguaggi di programmazione “tradizionali”, come il Cobol il Fortran o il Pascal, hanno un insieme limitato di tipi di dato: interi, numeri in virgola mobile, booleani, caratteri e stringhe.. giusto quello che serve a gestire una scheda anagrafica o un conto in banca.
Il C e il Pascal hanno anche la possibilità di accorpare questi tipi di dato in strutture, enumerati o array, ma questi tipi di dato sono solo dei contenitori privi di logica interna.
Inoltre, come hai visto, i dati all’interno di una <code>struct</code> sono accessibili a qualunque componente del programma, quindi, se li si modifica, va modificato anche il codice che li utilizza.
Immagina di definire una struttura per la gestione dell’orario, che contenga tre interi, uno per le ore, uno per i minuti e uno per i secondi:</p>

<pre><code>struct Orario {
    int h;
    int m;
    int s;
};
</code></pre>

<p>Per utilizzare questa struttura è necessario conoscerne il contenuto e il rapporto fra un valore e l’altro; in particolare, è necessario sapere (e ricordarsi):</p>

<ul>
  <li>che la variabile <code>h</code> può contenere solo valori da 0 a 23;</li>
  <li>che il valore di <code>m</code> può contenere solo valori da 0 a 59;</li>
  <li>che il valore di <code>s</code> può contenere solo valori da 0 a 59;</li>
  <li>che se <code>s</code> supera il valore di 59, <code>m</code> va incrementato di 1;</li>
  <li>che se <code>m</code> supera il valore di 59, <code>h</code> va incrementato di 1;</li>
</ul>

<p>Questo è l’opposto del <em>low coupling</em> di cui abbiamo parlato <a href="/man/struttura-dei-programmi#coupling" class="xref">tempo fa</a>, perché lega indissolubilmente una funzione alla struttura del dato che deve gestire.
Per capirsi: una funzione di aggiornamento dei minuti dovrà essere qualcosa di simile a:</p>

<pre><code>void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}
</code></pre>
<p>Se un giorno decidessimo di modificare la struttura <code>Orario</code>, dovremmo ricordarci di riscrivere anche questa funzione, adeguandola alle nuove caratteristiche della struttura, con un dispendio di tempo e la possibilità di fare degli errori.
Inoltre, nulla impedirebbe a un programmatore cialtrone di scrivere una funzione che non tiene minimamente conto del rapporto fra ore, minuti e secondi:</p>

<pre><code>void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}
</code></pre>

<p>Se inseriamo queste due funzioni in un programma, otteniamo:</p>

<pre><code>/** 
 * @file classi-struttura-orario.cpp
 * Gestione dei dati membro di una struct.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione di una struttura per gestire un orario */
struct Orario {
    int h;
    int m;
    int s;
};

/** Funzione per l'incremento dei minuti */
void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}

/*  Funzione cialtrona per l'incremento dei minuti */
void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}

int main()
{    
    struct Orario ora;

    /** Definisce dei valori iniziali prossimi al cambio di data */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Visualizza i valri iniziali */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Richiama la funzione di aggiornamento */
    aggiornaMinuti(ora, 20);
    
    /** Visualizza i valori dopo l'aggiornamento */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Reimposta i valori iniziali */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Richiama la funzione cialtrona */
    incrementa_m(ora, 20);
    
    /** Visualizza i valori dopo l'aggiornamento */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    
    return 0;
}

</code></pre>

<p>Compilando ed eseguendo questo codice, ottieni:</p>

<pre><code>&gt; g++ src/cpp/classi-struttura-orario.cpp -o src/out/esempio 
&gt; ./src/out/esempio                                          
23:45:00
00:05:00
23:65:00
</code></pre>
<p>Come puoi vedere, la prima funzione ha aggiornato i dati in maniera corretta, mentre la seconda ha prodotto un valore non valido senza alcuna possibilità di controllo da parte del programma.</p>

<hr />

<p>Le variabili all’interno di una classe, sono dette <em>dati membro</em> o <em>attributi</em> della classe; le funzioni, invece, sono dette <em>funzioni membro</em> o <em>metodi</em>.
Quando si crea una variabile di classe <code>C</code>, si dice che si: <em>istanzia</em> un <em>oggetto</em> di classe <code>C</code> o che si crea una <em>istanza</em> della classe.
I dati e le funzioni membro di una classe sono direttamente accessibili alle funzioni membro della classe, ma per utilizzarli all’interno di funzioni esterne alla classe, si devono utilizzare gli operatori di selezione <code>.</code> e <code>-&gt;</code>. 
Il primo, detto <em>operatore di selezione diretta</em>, viene utilizzato con istanze della classe; il secondo, detto <em>operatore di selezi­one indiretta</em>, con puntatori ad esse:</p>

<pre><code>class Punto
{
public:             
    
    /** Dichiara i dati membro della classe */
    int _x, _y;

    /** 
     *  Le funzioni interne alla classe accedono ai
     *  dati membro con la sintassi ordinaria.
     */  
    Punto(int x, int y) {
        _x = x;
        _y = y;
    }
} ;

int main(int argc, char** argv) 
{
    /** Crea un oggetto di classe Punto */
    Punto p(5,6);       

    /** Assegna l'istanza della classe al puntatore ptr */
    Punto *ptr = &amp;p ;   
    
    /** 
     *  Le funzioni esterne alla classe accedono ai
     *  dati membro tramite gli operatori di selezione.
     */  
    p._x    = 3 ;       // assegna un valore tramite l'oggetto
    ptr-&gt;_y = 2 ;       // assegna un valore tramite il puntatore
    ...
}
</code></pre>

<p>L’etichetta <code>public</code> che vedi all’inizio della dichiarazione della classe è un <em>indicatore di accesso</em> e serve a stabilire quali membri della classe siano accessibili a funzioni esterne e quali invece siano riservati in esclusiva alla classe stessa.</p>

<blockquote>
  <p>il selvaggio non ama dire il suo nome o farsi fotografare, perché per mezzo del suo nome o del ritratto egli è accessibile, e può quindi ricevere danno da chi con questi mezzi è in grado di raggiungerlo<a href="/man/note#selvaggio" class="nota"></a>.</p>
</blockquote>

<p>Questa frase di Lucien Lévy-Bruhl si applica anche alle classi del C++. 
Sia gli attributi che i metodi di una classe possono essere protetti da letture o modifiche indebite grazie ai modificatori di accesso <code>private</code>, <code>protected</code> e <code>public</code>.
I metodi o gli attributi dichiarati <em>private</em> sono accessibili solo alla classe stessa; quelli dichiarati come <em>protected</em> sono accessibili alla classe e a eventuali <a href="/man/ereditarieta" class="xref">classi derivate</a>; quelli dichiarati come <em>public</em> sono accessibili a qualunque elemento del programma.
In mancanza di specifiche, tutti i dati e le funzioni di una classe verranno considerati:</p>

<ul>
  <li><em>privati</em>, nel caso di una classe;</li>
  <li><em>pubblici</em>, nel caso di <code>struct</code> o <code>union</code>.</li>
</ul>

<p>Per le <code>struct</code>, la visibilità dei dati membro può essere modificata con gli indicatori di accesso; i dati delle <code>union</code>, invece, possono essere solo pubblici.<br />
Il C++ permette di suddividere la dichiarazione di una classe in quante sezioni si desidera e nella sequenza <code>private</code>, <code>public</code>, <code>pro­tected</code> che si preferisce, ma un codice scritto in questo modo è sicuramente più difficile da leggere di uno in cui tutti i membri privati stanno da una parte e tutti quelli pubblici da un’altra.
Quindi, a meno che tu non abbia delle buone ragioni per fare altrimenti (e ce ne potrebbero essere, nel caso di classi particolarmente complesse), cerca di raggruppare in tre sole sezioni <code>private</code>, <code>pro­tected</code> e <code>public</code> tutte le funzioni e i dati membro con gli stessi attributi di accesso:</p>

<pre><code>class Persona
{
 private:
    ...
 protected:
    ...
 public:
    ...
};
</code></pre>

<p>Questo tipo di ordinamento della dichiarazione, oltre a garantirti una maggiore leggibilità del codice, ti consentirà, se lo desideri, di omettere l’indicatore di accesso <code>private</code> iniziale (è la soluzione di default, ricordi?).<br />
Mettiamo in pratica tutto ciò, convertendo in classe la struttura <code>Orario</code>:</p>

<pre><code>class Orario {
private:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
};
</code></pre>
<p>Gli attributi <code>_h</code>, <code>_m</code> e <code>_s</code> compaiono dopo la parola-chiave <code>private</code> e saranno quindi visibili solo alle funzioni della classe stessa.<br />
La funzione <code>Orario</code>, che ha lo stesso nome della classe, è detta <em>costruttore</em> e viene richiamata ogni volta che si crea una variabile di tipo <code>Orario</code>.
Il suo scopo è di inizializzare le variabili all’interno della classe, in questo caso, impostando tutti e tre i valori a 0.</p>

<h3 id="costruttori">Costruttori</h3>
<p>Quando dichiariamo una variabile di tipo primitivo come <code>int</code>, o <code>double</code>, il compilatore svolge automaticamente tutta una serie di operazioni atte ad allocare lo spazio di memoria necessario a contenerla e ad inizializzarlo.
Il compilatore, però, non sa come vada creata e inizializzata una variabile di tipo <code>Orario</code> ed è per questo che la classe dovrà definire delle <em>funzioni di gestione</em> che spieghino sia come creare una nuova variabile, che come distruggerla, se necessario. 
Le funzioni di gestione sono di due tipi: i <em>costruttori</em> e i <em>distruttori</em>.<br />
I costruttori hanno alcune peculiarità che le distin­guono dalle altre funzioni membro:</p>

<ul>
  <li>devono avere lo stesso nome della classe;</li>
  <li>non hanno un tipo di ritorno perché è implicito che ritornino una variabile   della classe cui appartengono.</li>
</ul>

<p>Una stessa classe può avere più costruttori; la classe <code>Orario</code>, per esempio, potrebbe avere un costruttore privo di parametri, che inizializzi ore, minuti e secondi a zero e uno che permetta invece di assegnare valori specifici a ciascun attributo:</p>

<pre><code>class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
    Orario(int h, int m, int s) 
    : _h(h), _m(m), _s(s){
    }
};
</code></pre>

<p>La riga:</p>

<pre><code>: _h(h), _m(m), _s(s){
</code></pre>

<p>si chiama: <em>lista di inizializzazione</em> e ed equivale a scrivere:</p>

<pre><code>_h = h;
_m = m;
_s = s;
</code></pre>

<p>Un modo più succinto di ottenere lo stesso risultato con un unico costruttore è di utilizzare dei valori di default per i parametri:</p>

<pre><code>Orario(int h = 0, int m = 0, int s = 0) 
: _h(h), _m(m), _s(s) {
}
</code></pre>

<p>Alle volte, può essere utile definire un costruttore che crei delle nuove variabili della classe partendo da variabili esis­tenti, operando quindi una sorta di clonazione. 
Questo tipo di funzioni si chiamano: <em>costruttori di copia</em> o: <em>costruttori di inizializ­zazione</em> e richiedono come argomento un riferimento a una variabile della stessa classe:</p>

<pre><code>/** 
 * Dichiarazione del costruttore di copia
 * (all'interno della classe) 
 */
Orario::Orario(const Orario&amp; );	

/** Definizione  */
Orario::Orario(const Orario&amp; o) 
: _h(o._h), _m(o._m), _s(o._s) {
}

/** Utilizzo */
Orario o2 = o1;
</code></pre>

<p>Il costruttore di copia è un tipo di costruttore molto importante in quanto presiede alla maggior parte delle attività di inizializzazione di oggetti della classe cui appartiene; per questa ragione, nel caso non venga definito dall’utente, è automaticamente generato dal compilatore.</p>

<hr />

<p>Come è facile intuire, mentre il costruttore di una classe presiede alla creazione di nuove variabili, il distruttore si occupa della loro cancellazione. 
Non sempre è necessario definire un distruttore per una classe.
Una variabile di tipo <code>Orario</code>, che contiene solo tre interi, probabilmente non avrà bisogno di un distruttore, mentre una variabile che faccia uso di memoria dinamica quasi sicuramente sì. 
Il perché risulta più chiaro se si esamina la cosa dal punto di vista del compilatore.<br />
Per creare una variabile di tipo <code>Orario</code> il compilatore deve allocare spazio per:</p>

<pre><code>3 * sizeof(int);
</code></pre>

<p>Quando arriva il momento di distruggere la variabile, il compilatore non farà altro che liberare i <code>3 * sizeof(int)</code> byte successivi all’indirizzo dell’oggetto; un comportamento che in questo caso è corretto, ma che potrebbe dare rivelarsi disastroso con una classe come questa:</p>

<pre><code>class Buffer
{
private:
    char* _dati;
    int   _size;
 public:
    Buffer(int size) 
    : _size(size) {
        _dati = new char[_size];
    }
};
</code></pre>

<p>Per distruggere una variabile di tipo <code>Buffer</code>, in mancanza di istruzioni specifiche, il compilatore libererà <code>sizeof(char*) + sizeof(int)</code> byte dopo il suo indirizzo di memoria, ma così facendo, distruggerà solo l’intero <code>_size</code> e il puntatore a char <code>_dati</code>, senza liberare l’area di memoria a cui quest’ultimo puntava.
Questo, come sai, è un grave errore.<br />
Come il costruttore, il distruttore di una classe non ha tipo di ritorno, ma mentre ci possono essere più costruttori per una stessa classe, il distrut­tore è sempre unico.
Non ha mai parametri formali e il suo nome è uguale a quello della classe cui appartiene, preceduto da un carattere tilde <code>~</code>:</p>

<pre><code>class Buffer
{
private:
    char* _dati;
    int   _size;
 public:
    Buffer(int size) 
    : _size(size) {
        _dati = new char[_size];
    }
    Buffer::~Buffer() {
        delete [] _dati
    }
};
</code></pre>

<p>I distruttori possono essere chiamati in due modi:</p>

<ul>
  <li>
    <p><em>implicitamente</em>, dal programma, ogni volta che un oggetto esce dal suo campo d’azione o, nel caso di oggetti con visibilità globale, al termine della funzione <code>main</code>;</p>
  </li>
  <li>
    <p><em>esplicitamente</em>, specificando il loro nome per intero, per evitare che l’operazione possa venire scambiata con un complemento bit a bit.</p>
  </li>
</ul>

<p>Attenzione, però: se a uscire dal campo d’azione è un puntatore, il ditruttore della classe non viene richiamato automaticamente, perciò gli oggetti creati in maniera dinamica con l’operatore <code>new</code> dovranno sempre distrutti per mezzo dell’operatore <code>delete</code>.</p>

<hr />

<p>Le funzioni membro devono essere dichiarate all’interno della dichiarazione della classe, ma possono essere definite sia dentro che fuori di essa. 
Definirle all’interno della dichiarazione della classe equivale a dichiararle <a href="/man/funzioni#inline" class="xref">inline</a>
Se invece le si definisce esternamente alla dichiarazione della classe, vanno identificate aggiungendo il nome della classe prima di quello della funzione, seguito dall’<a href="/man/operatori#risoluzione" class="xref">operatore di risoluzione</a>:</p>

<pre><code>/** 
 * @file classi-classe-orario-1.cpp
 * Gestione dei dati membro di una classe.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione della classe */
class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario(int h = 0, int m = 0, int s = 0);
};

/** Definizione del costruttore della classe */
Orario::Orario(int h, int m, int s) 
: _h(h), _m(m), _s(s) 
{
}
    
/** La funzione main non fa parte della classe */
int main()
{    
    Orario ora;

    /** Questo codice darà errore */
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>Se compili questo codice, però, ottieni un errore: la funzione <code>main</code> può utilizzare il costruttore della classe <code>Orario</code> perché è dichiarato <code>public</code>, ma non può né leggere né modificare gli attributi `private:</p>

<pre><code class="language- ">&gt; g++ src/cpp/classi-classe-orario-1.cpp -o src/out/esempio
src/cpp/classi-classe-orario-1.cpp:34:44: error: '_h' is a protected member of 'Orario'
    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
                                           ^
src/cpp/classi-classe-orario-1.cpp:14:9: note: declared protected here
    int _h;
        ^
src/cpp/classi-classe-orario-1.cpp:35:44: error: '_m' is a protected member of 'Orario'
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
                                           ^
src/cpp/classi-classe-orario-1.cpp:15:9: note: declared protected here
    int _m;
        ^
src/cpp/classi-classe-orario-1.cpp:36:44: error: '_s' is a protected member of 'Orario'
         &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
                                           ^
src/cpp/classi-classe-orario-1.cpp:16:9: note: declared protected here
    int _s;
        ^
3 errors generated.
</code></pre>

<p>Il C++ prevede due modi per rendere disponibili gli attributi di una classe anche alle funzioni esterne alla classe stessa:</p>

<ul>
  <li>le classi o le funzioni <code>friend</code>.</li>
  <li>le <em>funzioni di interfaccia</em>;</li>
</ul>

<p>Il modo più rapido per accedere ai dati privati di una classe attraverso una funzione o una classe esterna è quello di dichiararle come <code>friend</code>.
In virtù di ciò, la funzione o la classe acquisteranno una visibilità completa sui dati protetti:</p>

<pre><code>class Orario {
protected:

    /** Dati membro privati */
    int _h;
    int _m;
    int _s;

public:
    
    /** Costruttore della classe */
    Orario(int h = 0, int m = 0, int s = 0) ;

    /** Funzioni di lettura */
    int getH() { return _h; }
    int getM() { return _m; }
    int getS() { return _s; }

    /** Funzioni di scrittura */
    int setH(int h) { return _h = (h % 24); }
    int setM(int m) { return _m = (m % 60); }
    int setS(int s) { return _s = (s % 60); }

    /** Dichiarazione di una funzione e di una classe friend */
    friend int incrementaMinuti(Orario&amp; o, int m);
    friend class Orologio(); 	

};
</code></pre>

<p>Questa soluzione è molto comoda, ma non ne abusare.
Come avviene nella realtà, prima di dare la tua amicizia a qual­cuno verificane l’affidabilità: un <code>friend</code> ha la possibilità di fare grossi danni, altrimenti.<br />
Un metodo più sicuro consiste nel definire delle funzioni membro pubbliche che consentano un accesso controllato ai dati che si vogliono proteggere. 
Nel caso della classe <code>Orario</code>, ne occorrono sei: una la lettura e una per la scrittura di ciascuno dei tre dati membro:</p>

<pre><code>/** Funzioni di lettura */
int getH() { return _h; }
int getM() { return _m; }
int getS() { return _s; }

/** Funzioni di scrittura */
int setH(int h) { return _h = (h % 24); }
int setM(int m) { return _m = (m % 60); }
int setS(int s) { return _s = (s % 60); }
</code></pre>

<p>Ovviamente, puoi chiamare queste funzioni come preferisci, ma utilizzare i prefissi <code>get</code> e <code>set</code>, seguiti dal nome del parametro su cui operano rende più facile l’utilizzo della classe da parte di altri programmatori.
È lo stesso motivo per cui aggiungo il carattere <em>underscore</em> davanti al nome dei dati membro delle classi, in modo che li si possa distinguere dai  parametri delle funzioni che abbiano lo stesso nome:</p>

<pre><code>return _h = (h % 24);
</code></pre>
<p>Non sei nemmeno obbligato a dichiarare le funzioni di interfaccia come <code>inline</code>; l’ho fatto qui perché erano estremamente semplici, ma valgono sempre le considerazioni fatte <a href="/man/funzioni#inline" class="xref">a suo tempo</a>.<br />
Così come abbiamo fatto per il costruttore della classe, potremmo unificare le funzioni di lettura e scrittura, utilizzando un parametro di default che determini il comportamento del programma:</p>

<pre><code>int ore(int h = -1) { 
    return _h = ((h != -1) ? _h = (h % 24) : h); 
}
</code></pre>

<p>Questa sintassi è l’equivalente di:</p>

<pre><code>int ore(int h = -1) { 
    if(h != -1) {
        _h = (h % 24);
    }
    return _h; 
}
</code></pre>

<p>Anche se meno evidente, è più comoda perché permette di tenere il codice su una sola riga e ti dà modo di fare un po’ di pratica con gli operatori.<br />
Questo tipo di funzioni, però, ha due difetti: limita i valori che puoi assegnare all’attibuto e limita la granularità dei privilegi sulle funzioni.
Limita il numero di valori che puoi assegnare all’attibuto, perché esclude il valore del parametro di default; cosa che non crea problemi in questo caso, dato che non esiste un’ora <code>-1</code>, ma che potrebbe farlo nel caso di una stringa con parametro di default nullo.
Limita la granularità dei privilegi sulle funzioni, perché ti costringe a rendere pubbliche le funzioni di scrittura dei dati membro e questo, in certi casi potrebbe non essere saggio. 
Ti consiglio perciò di scrivere sempre due funzioni di interfaccia distinte per la lettura e la scrittura: sul momento ti sembrerà uno spreco di tempo, ma, a meno che il tuo programma non sia particolarmente banale, o prima o poi ti accorgerai di aver fatto la scelta corretta.<br />
A ogni modo, questo metodo, garantendo un numero limitato di accessi ai membri della classe, è preferibile a una soluzione in cui tutti i membri dato siano accessibili.</p>

<hr />

<!--

Oltre a quelli definiti dall’utente, poi, la lista dei membri di una classe comprende sempre anche un clandestino, che viene dichiarato implicitamente. Si chiama this ed è utilizzato, in maniera implicita o esplicita, per riferirsi all’istanza cui appartiene, ovvero, se C è una classe di cui Ist è un’istanza, this di Ist sarà un puntatore a oggetti di tipo C che punta all’indirizzo di Ist o, se preferite:
X * this = &x ;
NOTA: 
Questa istruzione ha unicamente valore di esempio: non è possibile inserire una simile linea di codice in un programma senza ricevere un messaggio da parte del compilatore con l'avviso che this è una parola chiave e non può essere usata come identificatore.
Non capita molto spesso di dover utilizzare this in maniera esplicita, mentre è sempre passato come membro nascosto nelle funzioni membro, per specificare su quale istanza della classe la funzione debba operare. 
2.4.1 Dati membro statici
Le uniche funzioni membro che non possono fare uso di this sono quelle dichiarate come static, che si comportano in maniera molto particolare: 
·	mentre di tutti gli oggetti non statici della lista dei membri, dati o funzi­oni che siano, viene fatta una copia distinta in ciascuna nuova istanza della classe, i membri dichiarati come static sono unici e vengono per­ciò condivisi dalle diverse istanze;
·	non è possibile inizializzare membri static all’interno della dichiarazione e si deve quindi farlo altrove nel programma come per un qualsiasi oggetto a visibilità globale;
·	si può accedere ad essi, oltre che con i normali operatori di selezione, facendo riferimento alla classe stessa.
Cerchiamo di spiegarci meglio con un esempio. Immaginiamo di voler tenere nota in una variabile del numero di oggetti della classe Punto che sono stati creati: nessun modo migliore per farlo di aggiungere alla nostra classe un membro static:

fare esempio di classe con attributi binarii

\[cfr. *Breve storia dell'infinito*, pagg. 30-40\]

Si può dire che esista qualcosa che non ha dimensioni?


parlare degli operatori di cast 
dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)


@todo: parlare della posizione di un certo dato in memoria, che può variare in successive esecuzioni del programma. Allo stesso modo, l'io cosciente di ciascuno di noi non è detto che si manifesterà nello stesso individuo, ma potrà essere "allocato" in altri esseri. In quest'ottica, il: "Cogito ergo sum" di Cartesio è insensato, perché ciò che cogita non è ciò che è. cfr. Ananda, note a capitolo sull'Induismo

@todo: Utlizzare l'operatore `delete` per illustrare il rapporto del C’hi++ con la morte, che non è più considerata un nemico da combattere, ma un fenomeno naturale necessario al buon funzonamento dell’Universo. 
Questo approccio si rirova anche nel precetto:

    Amiamo ciò che ci ucciderà (se tutto va bene) 


-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/istruzioni-iterative" 
           title="Vai a: Istruzioni iterative" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/oggetti" 
           title="Vai a: Gli oggetti" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
