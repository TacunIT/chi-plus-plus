<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Gli stream |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="http://localhost:4000" />
    <meta     name="thumbnail"       content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Gli stream" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">
    <div class="page capitolo">
        <header><nav class="menu-top">
    
    <a title="Vai a: Il polimorfismo" 
        
        href="/man/polimorfismo" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Il debug" 
        
        href="/man/debug" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>
        <main class="corpo pubblicato">
        
            <h1><a href="#dottrina">
                Gli stream</a>
            </h1>
            <blockquote class="motto">Non puoi immergere i tuoi byte due volte nello stesso stream</blockquote>
            <section class="testo">
                <p>Oggi ti parlerò degli <em>stream</em> che, com’è noto, sono la componente più importante del C++.</p>

<p>Il C++ eredita dal C l’assenza di parole chiave per la gestione dell’I/O.
Al posto di istruzioni come la <code>print</code> del BASIC, utilizza delle librerie di classi e funzioni che permettono di convertire in testo stampabile gli oggetti gestiti dal programma o di convertire degli elementi testuali in oggetti.
Non potrebbe essere altrimenti: il C++ non deve gestire solo stringhe e numeri, come il BASIC, ma anche numeri in virgola mobile, puntatori e soprattutto i tipi di dato definiti dall’utente, per i quali non sarebbe possibile definire un comportamento standard e che quindi dovrebbero essere trattati in maniera differente dai dati primitivi, con tanti saluti alla coerenza del linguaggio.<br />
Oltre a poter sfruttare le librerie di funzioni del <em>C</em>, il C++ ha una propria libreria di I/O, ba­sata sulla gerarchia delle classi <code>stream</code>, che permette di gestire anche i tipi di dato definiti dall’utente.
Abbiamo visto degli esempii di questa caratteristica quando abbiamo parlato di <a href="/man/c-plus-plus#polimorfismo" class="xref">polimorfismo</a> e di <a href="/man/polimorfismo#overload-operatori" class="xref">overload degli operatori</a>:</p>

<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; "Specie:" &lt;&lt; animale.getSpecie() &lt;&lt; "\t"
        &lt;&lt; "Razza:"  &lt;&lt; animale.getRazza()  &lt;&lt; "\t"
        &lt;&lt; "Sesso:"  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}
</code></pre>

<p>Questo codice “insegna” all’operatore <code>&lt;&lt;</code> come comportarsi per visualizzare un oggetto di classe <code>Animale</code>. 
Lo stesso si può fare (e lo abbiamo fatto) per qualsiasi altro tipo definito dall’utente. 
È la sintassi del linguaggio che si adatta alle esigenze del programmatore, e non viceversa.<br />
Alcuni concetti chiave per la comprensione degli stream sono:</p>

<ul>
  <li>uno <em>stream</em> è un’astrazione che rappresenta la sorgente o la destinazione di un insieme di dati di lunghezza variabile: l’input da tastiera, l’output su schermo, i buffer di memoria, le stringhe, i file;</li>
  <li>l’output su stream verso una qualsiasi destinazione, viene definito <em>scrit­tura</em> o <em>inserimento</em> e si effettua per mezzo dell’operatore <code>&lt;&lt;</code>;</li>
  <li>con i termini <em>lettura</em> o <em>estrazione</em>, invece, si intende l’operazione di acquisizione da una sorgente, effettuata dall’operatore <code>&gt;&gt;</code>.</li>
</ul>

<p>La libreria <code>iostream</code> del C++ permette di gestire le operazioni di I/O su stream per mezzo di classi derivate da due classi base: <code>streambuf</code> e <code>iosbase</code>.
La libreria ha due diverse “linee genealogiche”: una destinata alla gestione dei caratteri di un byte e una destinata ai caratteri multi-byte.
Le classi della libreria multi-byte hanno lo stesso nome delle classi ordinarie, con l’aggiunta del prefisso: “w”.<br />
Questo è lo schema di ereditarietà delle classi della libreria <code>iostream</code>:</p>

<pre><code>                              ios_base
                                 |
                             basic_ios
                                 |
               __________________|_________________       
              |                                    | 
              |                                    | 
        basic_istream                         basic_ostream
             | |                                  | |   
             | |                                  | |  
             | |__________________________________| |  
             |                   |                  |   
      _______|______             |         _________|_______       
     |              |            |        |                 | 
basic_istringstream |            |   basic_ostringstream    |
                    |            |                          |
                    |            |                          |
               basic_ifstream    |                  basic_ofstream
                                 |
                            basic_iostream
                         ________|________
                        |                 |
               basic_stringstream    basic_fstream
          
</code></pre>

<p>A parte <code>ios_base</code>, queste sono tutte classi template che sono poi istanziate con parametri differenti per gestire la gestione dei tipi di carattere <code>char</code> and <code>wchar_t</code>. 
Per esempio, la classe <code>ostream</code> è una specializzazione della classe <code>basic_ostream</code>:</p>

<pre><code>typedef basic_ostream&lt;char&gt; ostream;
</code></pre>

<p>Il suo corrispettivo multi-byte è la classe <code>wostream</code>:</p>

<pre><code>typedef basic_ostream&lt;wchar_t&gt; wostream;
</code></pre>

<p>La classe template <code>basic_ostream</code>, a sua volta, deriva da <code>basic_ios</code>:</p>

<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ostream 
: virtual public std::basic_ios&lt;CharT, Traits&gt;
</code></pre>
<p>che, a sua volta, deriva da <code>ios_base</code>:</p>

<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ios 
: public std::ios_base	
</code></pre>

<p>In sostanza: se davanti al nome c’è il prefisso <code>basic_</code>, si tratta della classe template; se c’è c’è la lettera “w”, si tratta della versione multi-byte, altrimenti è la classe ordinaria.<br />
Oltre alle classi derivate da <code>iosbase</code>, la libreria comprende anche delle classi per la gestione dei buffer di dati:</p>

<pre><code>                       basic_streambuf
                      ________|________
                     |                 |
               basic_stringbuf     basic_filebuf
</code></pre>

<p>La classe template virtuale <code>basic_streambuf</code>, che fa parte della libreria, ma non della discendenza da <code>ios_base</code>, contiene i dati e le funzioni necessarie alla gestione di un buffer di caratteri.
Le sue classi derivate <code>basic_stringbuf</code> e <code>basic_filebuf</code> sono invece specializzate, rispettivamente, nella gestione di buffer in memoria e su file.
Anche in questo caso, la libreria comprende due versioni di ciascuna classe, specializzate per la gestione di <code>char</code> and <code>wchar_t</code>.</p>

<pre><code>typedef streambuf  basic_streambuf&lt;char&gt;
typedef wstreambuf basic_streambuf&lt;wchar_t&gt;
typedef filebuf    basic_filebuf&lt;char&gt;
typedef wfilebuf   basic_filebuf&lt;wchar_t&gt;
</code></pre>

<p>Come forse avrai intuito, esaminare le singole classi della libreria <code>iostream</code> è un’attività che rivaleggia, in quanto a tedio, con l’epigrafia classica, ma ci permetterà di vedere applicati tutta una serie di principii di cui abbiamo parlato nelle lezioni precedenti, perciò, facciamoci forza e andiamo a incominciare.</p>

<hr />

<p>La classe <code id="ios-base">ios_base</code> e la sua prima discendente <code id="basic-ios">basic_ios</code> sono classi generiche che forniscono le funzioni di base per la gestione degli stream, indipendentemente dal fatto che si tratti di stream di input o di output.<br />
Una peculiarità di <code>ios_base</code> è che non possiede un costruttore pubblico, quindi non è possibile utilizzarla per creare oggetti, ma solo come base per delle classi derivate.<br />
Le istanze specializzate di <code>basic_ios</code> sono:</p>

<pre><code>typedef basic_ios&lt;char&gt;    ios;
typedef basic_ios&lt;wchar_t&gt; wios;
</code></pre>

<p>Tramite i metodi di queste classi è possibile verificare o modificare lo stato interno dello stream, la sua formattazione o definire delle funzioni callback per la gestione dei dati.<br />
Il dato membro <code>openmode</code>, per esempio, definisce il modo in cui debba essere aperto lo stream:</p>

<table>
  <tbody>
    <tr>
      <td><em>app</em></td>
      <td>Fa sì che ogni operazione di output avvenga alla fine dello stream.</td>
    </tr>
    <tr>
      <td><em>ate</em></td>
      <td>In apertura dello stream, sposta il punto di inserimento al termine  (<em><strong>at e</strong>nd</em>) del buffer di I/O.</td>
    </tr>
    <tr>
      <td><em>binary</em></td>
      <td>Gestisce il contenuto dello stream come un flusso di dati binario.</td>
    </tr>
    <tr>
      <td><em>in</em></td>
      <td>Permette operazioni di input.</td>
    </tr>
    <tr>
      <td><em>out</em></td>
      <td>Permette operazioni di output.</td>
    </tr>
    <tr>
      <td><em>trunc</em></td>
      <td>Azzera il contenuto dello stream all’apertura.</td>
    </tr>
  </tbody>
</table>

<p>Il dato membro <code>iostate</code>, che utilizzeremo in uno dei prossimi esempii, contiene le informazioni sullo stato corrente dello stream:</p>

<table>
  <tbody>
    <tr>
      <td><em>goodbit</em></td>
      <td>Nessun errore</td>
    </tr>
    <tr>
      <td><em>eofbit</em></td>
      <td>È stata raggiunta la fine dello stream.</td>
    </tr>
    <tr>
      <td><em>failbit</em></td>
      <td>L’ultima operazione di I/O è fallita.</td>
    </tr>
    <tr>
      <td><em>badbit</em></td>
      <td>L’ultima operazione di I/O non era valida.</td>
    </tr>
    <tr>
      <td><em>hardfail</em></td>
      <td>Si è verificato un errore irrecuperabile.</td>
    </tr>
  </tbody>
</table>

<p>Entrambi questi dati membro sono delle bitmask<a class="nota" href="/man/note#bitmask" id="bitmask"></a>, quindi possono contenere più di un valore.
L’istruzione seguente, per esempio, apre uno stream su file combinando in <code>OR</code> tre possibili valori per <code>openmode</code>:</p>

<pre><code>fstream file_io("io.txt"
               , ios_base::in | ios_base::out | ios_base::app);
</code></pre>

<p>Dopo <code>basic_ios</code>, le classi della libreria si specializzano nell’input o nell’output: da un lato <code>basic_istream</code>, da cui derivano i due stream standard di input <code>cin</code> e <code>wcin</code>; dall’altro <code>basic_ostream</code>, da cui derivano gli stream standard di output <code>cout</code>, <code>cerr</code>, <code>clog</code> e le loro controparti “wide”: <code>wcout</code>, <code>wcerr</code>, <code>wclog</code>.<br />
Da queste due classi generiche derivano delle classi template specializzate nell’input o nell’output su file o in memoria:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ifstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_istringstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ofstream 
: public basic_ostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_ostringstream 
: public basic_ostream&lt;Elem, Tr&gt;
</code></pre>

<p>e una classe capace di gestire entrambe le operazioni:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_iostream 
: public basic_istream&lt;Elem, Tr&gt;
, public basic_ostream&lt;Elem, Tr&gt;
</code></pre>

<p>anche questa, con due specializzazioni per la gestione di file e memoria:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_stringstream 
: public basic_iostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_fstream 
: public basic_iostream&lt;Elem, Tr&gt;
</code></pre>

<p>Prima che ci assalga un attacco di narcolessia, vorrei mettere in atto tutto questo con qualche esempio.<br />
Abbiamo già visto diversi esempii di output su stream:</p>

<pre><code>cout &lt;&lt; "Hello World!"  // stringhe
     &lt;&lt; 12              // interi
     &lt;&lt; 0.35            // float
     &lt;&lt; argv[1]         // puntatori
     &lt;&lt; endl;               
</code></pre>

<p>Non abbiamo ancora parlato dell’input da stream, che però ha un funzionamento piuttosto simile:</p>

<pre><code>/** 
 * @file src/stream-input.cpp
 * Programma di esempio per la gestione dell'input da stream.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    string stringa;
    
    /** Scrive un messaggio sullo schermo */
    cout &lt;&lt; "Inserire una stringa: ";
    
    /** Legge una stringa da tastiera */
    cin &gt;&gt; stringa;

    /** La scrive sullo schermo */
    cout &lt;&lt; stringa &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>Questo codice legge una stringa dallo standard input e la scrive sullo schermo, ma ci mostra una peculiarità dell’input da stream:</p>

<pre><code>&gt; g++ src/cpp/stream-input-1.cpp -o src/out/esempio
&gt; src/out/esempio                                
Inserire una stringa: Penso, quindi sono.
Penso,
</code></pre>

<p>Come vedi, le operazioni di lettura con l’operatore » si arrestano al primo carattere di spaziatura; perciò, se vogliamo leggere tutta la stringa, dobbiamo modificare il codice:</p>

<pre><code>/** 
 * @file src/stream-input-2.cpp
 * Programma di esempio per la gestione dell'input da stream.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    char   buffer[256];
    string stringa;
    
    /** 
    *   Legge una stringa da tastiera tramite
    *   la funzione membro della classe istream.
    */
    cout &lt;&lt; "Inserire una stringa: ";
    cin.getline(buffer, 256);
    cout &lt;&lt; buffer &lt;&lt; endl;


    /** 
    *   Legge una stringa da tastiera tramite
    *   la funzione globale getline.
    */
    cout &lt;&lt; "Inserire una stringa: ";
    getline(cin, stringa);
    cout &lt;&lt; stringa &lt;&lt; endl;

    return 0;
}

</code></pre>

<pre><code>&gt; g++ src/cpp/stream-input-2.cpp -o src/out/esempio
&gt; src/out/esempio                                  
Inserire una stringa: Penso, quindi sono.
Penso, quindi sono.
Inserire una stringa: Cogito ergo sum.
Cogito ergo sum.
</code></pre>

<p>Un’altra caratteristica degli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code> è che la loro precedenza è minore di quasi tutti gli altri operatori, il che vi consente di scrivere delle istruzioni come questa:</p>

<pre><code>cout &lt;&lt; "Due più due fa: " &lt;&lt; 2 + 2 &lt;&lt; '\n' ;
</code></pre>

<p>Gli operatori logici di AND <code>|</code>, di OR inclusivo <code>&amp;</code> e di XOR esclusivo <code>^</code>, hanno una precedenza minore degli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code>  e, se non vengono isolate tra parentesi, le operazioni che li coinvolgono possono essere causa di errori. 
Per esempio, in un’istruzione come la seguente, l’operatore <code>&amp;</code> verrebbe interpretato come un riferimento a un oggetto, con conseguenze diverse da quelle attese:</p>

<pre><code>cout &lt;&lt; "Il valore è: " &lt;&lt; 2 &amp; 2 &lt;&lt; '\n' ;	// ERRORE! 
</code></pre>

<p>la sintassi corretta è, invece:</p>

<pre><code>cout &lt;&lt; "Il valore è: " &lt;&lt; (2 &amp; 2) &lt;&lt; '\n' ;	// OK
</code></pre>

<p>Il comportamento di default degli operatori di input da stream prevede anche delle convenzioni di for­mattazione: <!-- @todo:verificare --></p>
<ul>
  <li><strong>il formato di conversione della base è decimale</strong>;</li>
  <li><strong>il carattere di riempimento è lo spazio</strong>;</li>
  <li><strong>la precisione delle cifre a virgola mobile è la stessa utilizzata da print­f()</strong>, con arrotondamento della sesta cifra decimale;</li>
  <li><strong>la larghezza del campo ha valore di default 0</strong>, il che significa che lo stream di output utilizzerà tutti i caratteri necessari alla visualizzazione dell’intero valore o stringa.</li>
</ul>

<p>Le prime tre modifiche sono per­manenti: una volta impostati, i nuovi valori saranno validi fino a che un’altra istruzione non torni a modificarli; le modifiche alla larghezza del campo di input, invece, valgono solo per l’istruzione che le richiede.<br />
In alcuni esempii precedenti abbiamo visto che è possibile modificare il formato di output di default di uno stream tramite dei <em>maipolatori</em>:</p>

<pre><code>cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
     &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
     &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
</code></pre>

<p>Lo stesso risultato si può ottenere per mezzo di apposite funzioni delle classi <code>ios_base</code> e <code>basic_ios</code>, che permettono di alterare il carattere di riempimento, la precisione delle cifre decimali e la larghezza del campo:</p>

<pre><code>/** 
 * @file src/stream-format.cpp
 * Formattazione dell'I/O con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;


int main(int argc, char** argv)
{    
    double d = 123.456789 ;

    /** Mostra i valori di default */
    cout &lt;&lt; endl;
    cout &lt;&lt; "Valori di default" &lt;&lt; endl;
    cout &lt;&lt; "  width:     "  &lt;&lt; cout.width()        &lt;&lt; endl;
    cout &lt;&lt; "  precision: "  &lt;&lt; cout.precision()    &lt;&lt; endl; 	
    cout &lt;&lt; "  fill:      '" &lt;&lt; cout.fill()  &lt;&lt; "'" &lt;&lt; endl;	
    cout &lt;&lt; "  output:    "  &lt;&lt; d                   &lt;&lt; endl;

    /** Modifica il formato e mostra il nuovo output */
    cout &lt;&lt; endl;
    cout &lt;&lt; "Modifica formato" &lt;&lt; endl;
    cout &lt;&lt; "  output:    "  ;
    cout.precision(4) ;
    cout.fill('#') ;
    cout.width(10) ;
    cout &lt;&lt; d &lt;&lt; endl;
    
    /** Mostra la persistenza dei valori */
    cout &lt;&lt; endl;
    cout &lt;&lt; "Valori correnti" &lt;&lt; endl;
    cout &lt;&lt; "  width:     "  &lt;&lt; cout.width()        &lt;&lt; endl;
    cout &lt;&lt; "  precision: "  &lt;&lt; cout.precision()    &lt;&lt; endl; 	
    cout &lt;&lt; "  fill:      '" &lt;&lt; cout.fill()  &lt;&lt; "'" &lt;&lt; endl;	
    cout &lt;&lt; "  output:    "  &lt;&lt; d                   &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, ottieni:</p>

<pre><code>&gt; src/out/esempio                                 

Valori di default
  precision: 6
  fill:      ' '
  width:     0
  output:    123.457

Valori modificati
  output:    #####123.5

Valori correnti
  precision: 4
  fill:      '#'
  width:     0
  output:    123.5
</code></pre>

<hr id="iostate" />

<p>Quando un’operazione di lettura o scrittura su stream fallisce, il valore del dato membro <code>iostate</code> assume un valore differente da zero.
La classe basic_ios ha delle funzioni membro booleane che tornano <code>true</code> o <code>false</code> se il valore <code>iostate</code> indica un determinato evento e la funzione <code>rdstate</code> che torna il valore assoluto di <code>iostate</code>:</p>

<table>
  <tbody>
    <tr>
      <td>good</td>
      <td>nessun errore: il valore di <code>iostate</code> è 0</td>
    </tr>
    <tr>
      <td>eof</td>
      <td>è stata raggiunta la fine del file</td>
    </tr>
    <tr>
      <td>fail</td>
      <td>c’è stato un errore di I/O non bloccante</td>
    </tr>
    <tr>
      <td>bad</td>
      <td>c’è stato un errore di I/O bloccante</td>
    </tr>
    <tr>
      <td>rdstate</td>
      <td>torna il valore corrente di <code>iostate</code></td>
    </tr>
  </tbody>
</table>

<p>Queste funzioni permettono di interrompere la lettura o la scrittura di uno stream quando si verifica un errore o se si è raggiunta la fine del file.
Una cosa che non devi fare mai, però, è di utilizzare la funzione <code>eof</code> all’interno di un ciclo <code>while</code> per la lettura di un file:</p>

<pre><code>/** 
 * @file src/stream-eof.cpp
 * Gestione dell'I/O su file con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;
    int      n;
    
    /** apre il file in lettura */
    testo.open(argv[1]);
    
    /** Verifica che il file sia aperto */
    if(testo.is_open()) {
        
        /** Utilizza eof per gestire il ciclo */
        while(!testo.eof()) {

            /** Legge un numero dal file */
            testo &gt;&gt; n;

            /** Lo scrive a video */
            cout &lt;&lt; n &lt;&lt; endl;
        }
        
    }
        
    /** Chiude il file di input */
    testo.close();
    
    return 0;
}

</code></pre>

<p>Se fai leggere a questo programma un file che contenga i numeri: 10, 20 e 30, otterrai questo output:</p>

<pre><code>&gt; g++ src/cpp/stream-eof.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/stream-eof.txt       
10
20
30
30
</code></pre>

<p>L’errore si verifica perché il controllo della funzione <code>eof</code> avviene prima della quarta operazione di lettura, quando lo stream è ancora in stato <code>good</code>.
Un modo migliore di gestire questi casi è di utilizzare la funzione <code>good</code>, che ci permette di verificare anche la corretta apertura del file:</p>

<pre><code>/** 
 * @file src/stream-good.cpp
 * Gestione dell'I/O su file con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;
    int      n;
    
    /** apre il file in lettura */
    testo.open(argv[1]);
    
    /** 
    *   Il ciclo si ripete fino a che non 
    *   si verifica un errore
    */
    while(testo.good()) {

        /** Legge un numero dal file */
        testo &gt;&gt; n;

        /** Si interrompe se il file è finito */
        if(testo.eof()) break;
        
        /** Altrimenti, scrive il numero */
        cout &lt;&lt; n &lt;&lt; endl;
    }
                
    /** Chiude il file di input */
    testo.close();
    
    return 0;
}

</code></pre>
<p>Se compili ed esegui questo programma, ottieni il risultato corretto:</p>

<pre><code>&gt; g++ src/cpp/stream-good.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/stream-eof.txt        
10
20
30
</code></pre>

<hr id="eccezioni" />

<p>Le <em>eccezioni</em> permettono di gestire gli errori che avvengono durante l’esecuzione del programma. 
Quando succede qualcosa di anormale, il sistema <em>lancia</em> un’eccezione, ovvero trasferisce il controllo del processo dalla funzione corrente a blocchi di istruzioni specifici, chiamati <em>exception handler</em>. 
Perché tutto questo avvenga, il codice che genera l’errore deve essere racchiuso in un blocco <code>try</code>/<code>catch</code>:</p>

<pre><code>try {
    
    // codice che potrebbe dare errore
    
} catch (...) {

    //  istruzioni per la gestione dell'errore
}
</code></pre>

<p>Le eccezioni possono essere lanciate e gestite sia da codice specifico all’interno del programma, sia dai meccanismi automatici del C++:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-1.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    ifstream testo;

    /** 
    *   Fa sì che, se sia generata un'eccezione 
    *   in caso di errore nella gestione del file.
    */
    testo.exceptions ( ios_base::failbit );

    /** Questa istruzione genererà un'eccezione */
    testo.open("fileinesistente.txt");
    
    testo.close();
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, causerai un errore che, non essendo gestito dal programma, è gestito dalla funzione standard del C++:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-1.cpp -o src/out/esempio
&gt; src/out/esempio
libc++abi: terminating with uncaught exception of type
std::__1::ios_base::failure: ios_base::clear
: unspecified iostream_category error
zsh: abort      src/out/esempio
</code></pre>

<p>Se però inseriamo il codice che apre il file in un blocco <code>try</code>/<code>catch</code> e definiamo un <em>handler</em> per la gestione degli errori in apertura dei file, il risultato sarà più controllato:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-2.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        testo.exceptions ( ios_base::failbit );
        testo.open("fileinesistente.txt");        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; "Errore in esecuzione" &lt;&lt; endl;      
   
    }    
   
    return 0;
}

</code></pre>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-2.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Errore in esecuzione
</code></pre>

<p>Possiamo addirittura prevenire gli errori in apertura del file facendo sì che sia lo stesso programma a lanciare un’eccezione se si accorge che manca il nome del file nei parametri di avvio:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-3.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        /** Verifica che esista il nome del file da aprire */
        if(argc &lt; 2)
            throw "Nome file mancante";
            
        testo.exceptions ( ios_base::failbit );
        testo.open(argv[1]);        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; "Errore in esecuzione" &lt;&lt; endl;      
   
    } catch(char const* msg) {
        
        cerr &lt;&lt; msg &lt;&lt; endl;
    }
   
    return 0;
}

</code></pre>

<p>In questo modo, il programma è in condizione di gestire tutti i possibili errori di esecuzione:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-3.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Nome file mancante
&gt; src/out/esempio nomefile.txt
Errore in esecuzione
</code></pre>

<p>La libreria standard del C++ ha una classe specifica per la gestione delle eccezioni:</p>

<pre><code>class exception {
public:
    exception () throw();
    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();
    virtual ~exception() throw();
    virtual const char* what() const throw();
}
</code></pre>

<p>Definendo una classe derivata da <code>exception</code> con altri dati membro e una funzione <code>what</code> specializzate, è possibile gestire in maniera più strutturata le segnalazioni di errore.
È quello che faremo nel prossimo esempio.</p>

<pre><code>/** 
 * @file src/stream-eccezioni-4.cpp
 * Programma di esempio per la gestione delle eccezioni.
 * Richiede, in input, il numero di caratteri da leggere 
 * e il path del file di input:
 *
 *    src/out/esempio &lt;n caratteri da leggere&gt; &lt;file di input&gt;
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;exception&gt;

using namespace std;

/** Codici e stringhe di errore */
#define ERR_NONE          0
#define ERR_PARAMETRI   -10
#define ERR_FILE_OPEN   -20
#define S_SINTASSI      "USO: esempio &lt;n caratteri&gt; &lt;path file&gt;"
#define S_ERR_PARAMETRI "Errore nei parametri di input."
#define S_ERR_FILE_OPEN "Impossibile aprire il file di input"

/**
*   Definisce una classe derivata da exception
*   per la gestione degli errori.
*/
class Eccezione: public exception
{
private:
    int         _codice;
    const char* _errore;
public:

    /** Costruttore */
    Eccezione(int codice, const char* errore) 
    : _codice(codice), _errore(errore) {        
    }
    
    /** Funzione virtuale pura: va ridefinita */
    virtual const char* what() const throw() {
        return _errore;
    }

    /** Funzioni di interfaccia */
    int getCodice() { return _codice; }
    const char* getErrore() { return _errore; }

    /** Ridefinizione dell'operatore di output */
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, Eccezione e){
        os &lt;&lt; e._codice &lt;&lt; ": " &lt;&lt; e._errore &lt;&lt; endl;
        return os;
    }
};

int main(int argc, char** argv)
{    
    ifstream testo;
    testo.exceptions ( ios_base::badbit );

    try {

        char c     = 0;
        int  letti = 0;
                    
        /** 
        *   Verifica che ci siano sia il nome del file di input 
        *   che il numero di caratteri da leggere.
        */
        if (argc &lt; 3) 
            throw Eccezione(ERR_PARAMETRI, S_ERR_PARAMETRI);
            
        /** Definisce il numero di caratteri da leggere */
        int da_leggere = atoi(argv[1]);
        
        /** 
        *   Imposta la exception mask dello stream per fare
        *   sì che un errore di I/O generi un'eccezione,
        *   poi apre il file in lettura.
        *   Usa un blocco try/catch per intercettare una
        *   eventuale eccezione e gestirla in maniera
        *   omogenea al resto del codice.
        */
        try {
            testo.exceptions ( ios_base::badbit 
                             | ios_base::failbit );
            testo.open(argv[2]);            
        } catch(ifstream::failure e) {
            throw Eccezione(ERR_FILE_OPEN, S_ERR_FILE_OPEN);      
        }

        /**
        *   Re-imposta la exception mask per evitare
        *   eccezioni a fine file.
        */
        testo.exceptions ( ios_base::goodbit);

        /** 
        *   Legge il testo e lo stampa a video 
        *   Se è stato definito un numero massimo di 
        *   caratteri, si ferma lì.
        */
        while(testo.good()) {
            if((c = testo.get()) != EOF) {     
                letti++;
                cout &lt;&lt; c;
            } 
            if((da_leggere != 0) &amp;&amp; (letti &gt;= da_leggere)) {
                cout &lt;&lt; endl;
                break;
            }
        } 
                
        /** Chiude il file di input */
        testo.close();
            
    } catch (Eccezione e) {

        /** Stampa a video l'eccezione */
        cerr &lt;&lt; e &lt;&lt; endl;

        /** Mostra la sintassi di chiamata **/
        cerr &lt;&lt; S_SINTASSI &lt;&lt; endl;
        
        /** Esce con un codice di errore */
        exit(e.getCodice());
    }
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, otterrai il seguente output, a seconda dei parametri forniti:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-4.cpp -o src/out/esempio
&gt; src/out/esempio                                      
-10: Errore nei parametri di input.
USO: esempio &lt;n caratteri&gt; &lt;path file&gt;

&gt; src/out/esempio 41                                   
-10: Errore nei parametri di input.
USO: esempio &lt;n caratteri&gt; &lt;path file&gt;

&gt; src/out/esempio 41 src/cpp/stream-input.txt          
Nacqui da famiglia ricca, ma troppo tardi

&gt; src/out/esempio 0 src/cpp/stream-input.txt 
Nacqui da famiglia ricca, ma troppo tardi.  
Secondogenito, vidi la florida impresa paterna andare in dote  
per diritto di nascita, ma anche per naturale inclinazione
ai miei monozigotici fratelli maggiori e, com'è consuetudine 
per i figli cadetti, fui avviato alla vita monastica.
Entrai in seminario all'età di nove anni e presi i voti il 
giorno del mio diciottesimo compleanno.
Conobbi il Maestro quattro anni dopo.  
</code></pre>

<hr id="dottrina" />

<p>Il Maestro Canaro diceva che una filosofia, per spingere i suoi seguaci a comportarsi in maniera corretta, deve possedere due caratteristiche: <em>trascendenza</em> e <em>permanenza</em>.<br />
Se, per un caso o per volere del Cielo, gli esempii che ti ho fatto finora prendessero coscienza di sé, senza però sapere di far parte di una serie di lezioni, probabilmente si sentirebbero inutili e sciocchi.
Perfino l’ultimo esempio che abbiamo visto, che è il più complesso di tutti, non potrebbe fare a meno di chiedersi quale sia il senso della sua esistenza, dato che lo stesso risultato si può ottenere con una semplice istruzione da riga di comando:</p>

<pre><code>head -c 41 src/cpp/stream-input.txt
</code></pre>

<p>Qualche esempio riuscirebbe comunque a fare il proprio dovere, ma ce ne sarebbero altri che reagirebbero male a questa epifania: i più deboli si deprimerebbero, mentre i più ambiziosi cercherebbero una compensazione nell’accumulo eccessivo di risorse di sistema: RAM, spazio disco o cicli CPU.<br />
Al contrario, se gli esempii sapessero di essere parte integrante di una serie di lezioni, tutto ciò che altrimenti appare insensato o inutile, dai commenti pleonastici fino al parametro numerico dell’ultimo esempio, acquisterebbe il giusto significato e ciascun esempio saprebbe di essere non solo utile, ma necessario.<br />
Se c’è una cosa che sappiamo per certa dell’Universo in cui viviamo è che si sta espandendo. 
Se nulla interverrà a mutare questo stato di cose, tutto ciò che esiste, dagli esseri viventi alle stelle, è destinato o prima o poi a spegnersi nella vittoria di Pirro dell’Entropia come un computer portatile a cui si scarichi la batteria.<br />
Al contrario, se la Gravità riuscirà a invertire il moto delle galassie, tutto ciò che esiste, dalle stelle agli esseri viventi, è destinato o prima o poi ad annichilirsi nell’Uno in attesa di un nuovo ciclo di esistenza.<br />
Questo, però, non basterà da solo a dare un senso alle nostre esistenze, perché, senza persistenza, le nostre azioni saranno come degli oggetti di classe <code>streambuf</code>: una volta spento il computer, non esisteranno più e tutto ciò che abbiamo fatto, giusto o sbagliato che sia, non avrà alcuna influenza su ciò che accadrà successivamente.<br />
L’unica cosa che può salvarci dall’oblio e dall’insensatezza sono i <code>Post-It</code>, la persistenza.<br />
Per dare un senso alla nostra esistenza abbiamo bisogno di un <em>hard-disk</em> su cui salvare gli stream delle nostre vite, in modo che ogni ciclo di esistenza possa fare tesoro delle esperienze passate.
Senza di esso, Hitler varrà quanto Ghandi e Albert Schweitzer quanto Ted Bundy.
Dovrà essere però un <em>hard-disk</em> meta-fisico, per sfuggire al <em>Big Crunch</em>, e questo ci riporta all’importanza della trascendenza.<br />
Se mi guardo indietro, per il mezzo secolo su cui ho visibilità diretta, vedo una lunga serie di fallimenti ideologici.
Il Sessantotto ha spazzato via delle parti sicuramente rivedibili, ma fondamentali della nostra Società senza darci nulla in cambio, tranne la minigonna.
La lotta armata degli anni settanta ha sparato alle persone sbagliate, mentre la <em>reaganomics</em> è crollata alla fine degli anni ‘80 insieme al muro di Berlino.
Le speranze degli anni ‘90 si sono schiantate l’11 Settembre 2001 sulle Torri Gemelle e anche Internet, che nelle intenzioni iniziali sarebbe dovuta essere un mezzo per dare a tutti la possibilità di esprimere le proprie idee si è trasformata, nel tempo, in un sistema di controllo e di dis-informazione di massa.<br />
Quel poco che restava dei nostri valori e delle nostre idee è stato annichilito dagli <em>smart-phone</em> e dai <em>social-network</em>.<br />
Esiste un fattore comune alle ideologie degli ultimi cinquant’anni che ne ha accelerato l’obsolescenza e le ha rese incapaci di sopravvivere alla prima sconfitta: il rifiuto più o meno accanito di ogni forma non strumentale di spiritualità.<br />
Se si definisce uno schema di valori negando allo stesso tempo qualsiasi forma di trascendenza, si è costretti a ricercare i valori e le motivazioni della propria etica all’interno dello schema stesso. 
Si può fare, ma è sbagliato e limitativo. 
È sbagliato, perché le regole che si definiscono sono sempre una conseguenza di esigenze contingenti (guerre, sopraffazioni, disparità sociali), venendo a mancare le quali lo schema logico del sistema perde di significato e si disgrega.
È limitativo, perché restringe il numero dei possibili obiettivi da perseguire a un insieme finito di azioni o traguardi, raggiunti i quali non esiste più possibilità di migliorare.<br />
Pensa al gioco degli Scacchi: non esiste nessun motivo, all’interno della scacchiera, che costringa ciascun pezzo a muoversi solo in una specifica maniera.
Le torri si muovono in orizzontale, gli alfieri in diagonale e il cavallo salta con una traiettoria a “L” in ossequio a delle regole definite al di fuori della scacchiera<a class="nota" href="/man/note#scacchi" id="scacchi"></a>, ma è proprio da queste limitazioni che deriva il fascino del gioco. 
Al contrario, la Società moderna è una scacchiera in cui ciascun pezzo si muove nella maniera che preferisce perché, in ossequio a un malinteso senso di libertà, sono state eliminate tutte le regole. 
Le persone di successo che si privano della vita sono pedoni che, arrivati alla fine della scacchiera grazie alla loro abilità, hanno scoperto che non esiste alcuna forma di promozione, perché insieme alle regole sono stati aboliti anche i giocatori.</p>

<hr id="canaro" />

<p>Il Maestro Canaro una volta mi disse:</p>

<blockquote>
  <p>Io non credo alla storia della conversione. David Chapman ha ucciso John Lennon perché pensava che sopra di lui ci fosse “only sky” e che solo così, avrebbe potuto dare un senso alla sua esistenza.</p>
</blockquote>

<!--

@todo: decidere se spiegare che gli esempii del testo sono studiati per essere progressivamente migliorati, per dimostrare come la scrittura di codice sia un'attività in continua evoluzione.

-->

            </section>
        
        </main>
        <footer>
    <nav>
        
        
        <a href="/man/polimorfismo" 
           title="Vai a: Il polimorfismo" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/debug" 
           title="Vai a: Il debug" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>

    </div>
  </body>
</html>
