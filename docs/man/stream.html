<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Gli stream |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Gli stream" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    <a title="Vai a: Il polimorfismo" 
        
        href="/man/polimorfismo" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Il debug" 
        
        href="/man/debug" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Gli stream
            </h1>

            <blockquote class="motto">Non puoi immergere i tuoi byte due volte nello stesso stream</blockquote>

            <section id="testo">

                <p>Oggi ti parlerò degli <em>stream</em> che, com’è noto, sono la componente più importante del C++.</p>

<p>Il C++ eredita dal C l’assenza di parole chiave per la gestione dell’I/O.
Al posto di istruzioni come la <code>print</code> del BASIC, utilizza delle librerie di classi e funzioni che permettono di convertire in testo stampabile gli oggetti gestiti dal programma o di convertire degli elementi testuali in oggetti.
Non potrebbe essere altrimenti: il C++ non deve gestire solo stringhe e numeri, come il BASIC, ma anche numeri in virgola mobile, puntatori e soprattutto i tipi di dato definiti dall’utente, per i quali non sarebbe possibile definire un comportamento standard e che quindi dovrebbero essere trattati in maniera differente dai dati primitivi, con tanti saluti alla coerenza del linguaggio.<br />
Oltre a poter sfruttare le librerie di funzioni del <em>C</em>, il C++ ha una propria libreria di I/O, ba­sata sulla gerarchia delle classi <code>stream</code>, che permette di gestire anche i tipi di dato definiti dall’utente.
Abbiamo visto degli esempii di questa caratteristica quando abbiamo parlato di <a href="/man/c-plus-plus#polimorfismo" class="xref">polimorfismo</a> e di <a href="/man/polimorfismo#overload-operatori" class="xref">overload degli operatori</a>:</p>

<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; "Specie:" &lt;&lt; animale.getSpecie() &lt;&lt; "\t"
        &lt;&lt; "Razza:"  &lt;&lt; animale.getRazza()  &lt;&lt; "\t"
        &lt;&lt; "Sesso:"  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}
</code></pre>

<p>Questo codice “insegna” all’operatore <code>&lt;&lt;</code> come comportarsi per visualizzare un oggetto di classe <code>Animale</code>. 
Lo stesso si può fare (e lo abbiamo fatto) per qualsiasi altro tipo definito dall’utente. 
È la sintassi del linguaggio che si adatta alle esigenze del programmatore, e non viceversa.<br />
Alcuni concetti chiave per la comprensione degli stream sono:</p>

<ul>
  <li>uno <em>stream</em> è un’astrazione che rappresenta la sorgente o la destinazione di un insieme di dati di lunghezza variabile: l’input da tastiera, l’output su schermo, i buffer di memoria, le stringhe, i file;</li>
  <li>l’output su stream verso una qualsiasi destinazione, viene definito <em>scrit­tura</em> o <em>inserimento</em> e si effettua per mezzo dell’operatore <code>&lt;&lt;</code>;</li>
  <li>con i termini <em>lettura</em> o <em>estrazione</em>, invece, si intende l’operazione di acquisizione da una sorgente, effettuata dall’operatore <code>&gt;&gt;</code>.</li>
</ul>

<p>La libreria <code>iostream</code> del C++ permette di gestire le operazioni di I/O su stream per mezzo di classi derivate da due classi base: <code>streambuf</code> e <code>iosbase</code>.
La libreria ha due diverse “linee genealogiche”: una destinata alla gestione dei caratteri di un byte e una destinata ai caratteri multi-byte.
Le classi della libreria multi-byte hanno lo stesso nome delle classi ordinarie, con l’aggiunta del prefisso: “w”.<br />
Questo è lo schema di ereditarietà delle classi della libreria <code>iostream</code>:</p>

<pre><code>                              ios_base
                                 |
                             basic_ios
                                 |
               __________________|_________________       
              |                                    | 
              |                                    | 
        basic_istream                         basic_ostream
             | |                                  | |   
             | |                                  | |  
             | |__________________________________| |  
             |                   |                  |   
      _______|______             |         _________|_______       
     |              |            |        |                 | 
basic_istringstream |            |   basic_ostringstream    |
                    |            |                          |
                    |            |                          |
               basic_ifstream    |                  basic_ofstream
                                 |
                            basic_iostream
                         ________|________
                        |                 |
               basic_stringstream    basic_fstream
          
</code></pre>

<p>A parte <code>ios_base</code>, queste sono tutte classi template che sono poi istanziate con parametri differenti per gestire la gestione dei tipi di carattere <code>char</code> and <code>wchar_t</code>. 
Per esempio, la classe <code>ostream</code> è una specializzazione della classe <code>basic_ostream</code>:</p>

<pre><code>typedef basic_ostream&lt;char&gt; ostream;
</code></pre>

<p>Il suo corrispettivo multi-byte è la classe <code>wostream</code>:</p>

<pre><code>typedef basic_ostream&lt;wchar_t&gt; wostream;
</code></pre>

<p>La classe template <code>basic_ostream</code>, a sua volta, deriva da <code>basic_ios</code>:</p>

<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ostream 
: virtual public std::basic_ios&lt;CharT, Traits&gt;
</code></pre>
<p>che, a sua volta, deriva da <code>ios_base</code>:</p>

<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ios 
: public std::ios_base	
</code></pre>

<p>In sostanza: se davanti al nome c’è il prefisso <code>basic_</code>, si tratta della classe template; se c’è c’è la lettera “w”, si tratta della versione multi-byte, altrimenti è la classe ordinaria.<br />
Oltre alle classi derivate da <code>iosbase</code>, la libreria comprende anche delle classi per la gestione dei buffer di dati:</p>

<pre><code>                       basic_streambuf
                      ________|________
                     |                 |
               basic_stringbuf     basic_filebuf
</code></pre>

<p>La classe template virtuale <code>basic_streambuf</code>, che fa parte della libreria, ma non della discendenza da <code>ios_base</code>, contiene i dati e le funzioni necessarie alla gestione di un buffer di caratteri.
Le sue classi derivate <code>basic_stringbuf</code> e <code>basic_filebuf</code> sono invece specializzate, rispettivamente, nella gestione di buffer in memoria e su file.
Anche in questo caso, la libreria comprende due versioni di ciascuna classe, specializzate per la gestione di <code>char</code> and <code>wchar_t</code>.</p>

<pre><code>typedef streambuf  basic_streambuf&lt;char&gt;
typedef wstreambuf basic_streambuf&lt;wchar_t&gt;
typedef stringbuf  basic_stringbuf&lt;char&gt;
typedef wstringbuf basic_stringbuf&lt;wchar_t&gt;
typedef filebuf    basic_filebuf&lt;char&gt;
typedef wfilebuf   basic_filebuf&lt;wchar_t&gt;
</code></pre>

<p>Come forse avrai intuito, esaminare le singole classi della libreria <code>iostream</code> è un’attività che rivaleggia, in quanto a tedio, con l’epigrafia classica, ma ci permetterà di vedere applicati tutta una serie di principii di cui abbiamo parlato nelle lezioni precedenti, perciò, facciamoci forza e andiamo a incominciare.</p>

<hr />

<p>La classe <code id="ios-base">ios_base</code> e la sua prima discendente <code id="basic-ios">basic_ios</code> sono classi generiche che forniscono le funzioni di base per la gestione degli stream, indipendentemente dal fatto che si tratti di stream di input o di output.<br />
Una peculiarità di <code>ios_base</code> è che non possiede un costruttore pubblico, quindi non è possibile utilizzarla per creare oggetti, ma solo come base per delle classi derivate.<br />
Le istanze specializzate di <code>basic_ios</code> sono:</p>

<pre><code>typedef basic_ios&lt;char&gt;    ios;
typedef basic_ios&lt;wchar_t&gt; wios;
</code></pre>

<p>Tramite i metodi di queste classi è possibile verificare o modificare lo stato interno dello stream, la sua formattazione o definire delle funzioni callback per la gestione dei dati.<br />
Il dato membro <code>openmode</code>, per esempio, definisce il modo in cui debba essere aperto lo stream:</p>

<table>
  <tbody>
    <tr>
      <td><em>app</em></td>
      <td>Fa sì che ogni operazione di output avvenga alla fine dello stream.</td>
    </tr>
    <tr>
      <td><em>ate</em></td>
      <td>In apertura dello stream, sposta il punto di inserimento al termine  (<em><strong>at e</strong>nd</em>) del buffer di I/O.</td>
    </tr>
    <tr>
      <td><em>binary</em></td>
      <td>Gestisce il contenuto dello stream come un flusso di dati binario.</td>
    </tr>
    <tr>
      <td><em>in</em></td>
      <td>Permette operazioni di input.</td>
    </tr>
    <tr>
      <td><em>out</em></td>
      <td>Permette operazioni di output.</td>
    </tr>
    <tr>
      <td><em>trunc</em></td>
      <td>Azzera il contenuto dello stream all’apertura.</td>
    </tr>
  </tbody>
</table>

<p>Il dato membro <code>iostate</code>, che utilizzeremo in uno dei prossimi esempii, contiene le informazioni sullo stato corrente dello stream:</p>

<table>
  <tbody>
    <tr>
      <td><em>goodbit</em></td>
      <td>Nessun errore</td>
    </tr>
    <tr>
      <td><em>eofbit</em></td>
      <td>È stata raggiunta la fine dello stream.</td>
    </tr>
    <tr>
      <td><em>failbit</em></td>
      <td>L’ultima operazione di I/O è fallita.</td>
    </tr>
    <tr>
      <td><em>badbit</em></td>
      <td>L’ultima operazione di I/O non era valida.</td>
    </tr>
    <tr>
      <td><em>hardfail</em></td>
      <td>Si è verificato un errore irrecuperabile.</td>
    </tr>
  </tbody>
</table>

<p>Quando un’operazione di lettura o scrittura su stream fallisce, <code>iostate</code> assume un valore differente da zero; quindi, esaminandone il valore, possiamo risalire al tipo di errore occorso. 
Entrambi questi dati membro sono delle <a href="/man/note#bitmask" class="xref">bitmask</a>, quindi possono contenere più di un valore.
L’istruzione seguente, per esempio, apre uno stream su file combinando in <code>OR</code> tre possibili valori per <code>openmode</code>:</p>

<pre><code>fstream file_io("io.txt"
               , ios_base::in | ios_base::out | ios_base::app);
</code></pre>

<p>Dopo <code>basic_ios</code>, le classi della libreria si specializzano nell’input o nell’output: da un lato <code>basic_istream</code>, da cui derivano i due stream standard di input <code>cin</code> e <code>wcin</code>; dall’altro <code>basic_ostream</code>, da cui derivano gli stream standard di output <code>cout</code>, <code>cerr</code>, <code>clog</code> e le loro controparti “wide”: <code>wcout</code>, <code>wcerr</code>, <code>wclog</code>.<br />
Da queste due classi generiche derivano delle classi template specializzate nell’input o nell’output su file o in memoria:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ifstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_istringstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ofstream 
: public basic_ostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_ostringstream 
: public basic_ostream&lt;Elem, Tr&gt;
</code></pre>

<p>e una classe capace di gestire entrambe le operazioni:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_iostream 
: public basic_istream&lt;Elem, Tr&gt;
, public basic_ostream&lt;Elem, Tr&gt;
</code></pre>

<p>anche questa, con due specializzazioni per la gestione di file e memoria:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_stringstream 
: public basic_iostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_fstream 
: public basic_iostream&lt;Elem, Tr&gt;
</code></pre>

<p>Prima che ci assalga un attacco di narcolessia, vorrei mettere in atto tutto questo con un esempio, ma prima devo spiegarti cosa sono le <em>eccezioni</em>.</p>

<hr id="eccezioni" />

<p>Le <em>eccezioni</em> permettono di gestire gli errori che avvengono durante l’esecuzione del programma. 
Quando succede qualcosa di anormale, il sistema <em>lancia</em> un’eccezione, ovvero trasferisce il controllo del processo dalla funzione corrente a blocchi di istruzioni specifici, chiamati <em>exception handler</em>. 
Perché tutto questo avvenga, il codice che genera l’errore deve essere racchiuso in un blocco <code>try</code>/<code>catch</code>:</p>

<pre><code>try {
    
    // codice che potrebbe dare errore
    
} catch (...) {

    //  istruzioni per la gestione dell'errore
}
</code></pre>

<p>Le eccezioni possono essere lanciate e gestite sia da codice specifico all’interno del programma, sia dai meccanismi automatici del C++:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-1.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    /** 
    *   Fa sì che, se sia generata un'eccezione 
    *   in caso di errore nella gestione del file.
    */
    testo.exceptions ( ios_base::failbit );

    /** Questa istruzione genererà un'eccezione */
    testo.open("fileinesistente.txt");
    
    testo.close();
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, causerai un errore che, non essendo gestito dal programma, è gestito dalla funzione standard del C++:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-1.cpp -o src/out/esempio
&gt; src/out/esempio
libc++abi: terminating with uncaught exception of type
std::__1::ios_base::failure: ios_base::clear
: unspecified iostream_category error
zsh: abort      src/out/esempio
</code></pre>

<p>Se però inseriamo il codice che apre il file in un blocco <code>try</code>/<code>catch</code> e definiamo un handler per la gestione degli errori in apertura dei file, il risultato sarà più controllato:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-2.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        testo.exceptions ( ios_base::failbit );
        testo.open("fileinesistente.txt");        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; "Errore in esecuzione" &lt;&lt; endl;      
   
    }    
   
    return 0;
}

</code></pre>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-2.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Errore in esecuzione
</code></pre>

<p>Possiamo addirittura prevenire gli errori in apertura del file facendo sì che sia lo stesso programma a lanciare un’eccezione se si accorge che manca il nome del file nei parametri di avvio:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-3.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        /** Verifica che esista il nome del file da aprire */
        if(argc &lt; 2)
            throw "Nome file mancante";
            
        testo.exceptions ( ios_base::failbit );
        testo.open(argv[1]);        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; "Errore in esecuzione" &lt;&lt; endl;      
   
    } catch(char const* msg) {
        
        cerr &lt;&lt; msg &lt;&lt; endl;
    }
   
    return 0;
}

</code></pre>

<p>In questo modo, il programma è in condizione di gestire tutti i possibili errori di esecuzione:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-3.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Nome file mancante
&gt; src/out/esempio nomefile.txt
Errore in esecuzione
</code></pre>

<p>La libreria standard del C++ ha una classe specifica per la gestione delle eccezioni:</p>

<pre><code>class exception {
public:
    exception () throw();
    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();
    virtual ~exception() throw();
    virtual const char* what() const throw();
}
</code></pre>

<p>Definendo una classe derivata da <code>exception</code> con altri dati membro e una funzione <code>what</code> specializzate, è possibile gestire in maniera più strutturata le segnalazioni di errore.
È quello che faremo nel prossimo esempio.</p>

<pre><code>/** 
 * @file src/stream-eccezioni-4.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;exception&gt;

using namespace std;

/** Codici e stringhe di errore */
#define ERR_NONE          0
#define ERR_FILE_NONE   -10
#define ERR_FILE_OPEN   -20
#define S_ERR_FILE_NONE "Definire un file di input"
#define S_ERR_FILE_OPEN "Impossibile aprire il file di input"

/**
*   Definisce una classe derivata da exception
*   per la gestione degli errori.
*/
class Eccezione: public exception
{
private:
    int         _codice;
    const char* _errore;
public:

    /** Costruttore */
    Eccezione(int codice, const char* errore) 
    : _codice(codice), _errore(errore) {        
    }
    
    /** Funzione virtuale pura: va ridefinita */
    virtual const char* what() const throw() {
        return _errore;
    }

    /** Funzioni di interfaccia */
    int getCodice() { return _codice; }
    const char* getErrore() { return _errore; }

    /** Ridefinizione dell'operatore di output */
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, Eccezione e){
        os &lt;&lt; e._codice &lt;&lt; ": " &lt;&lt; e._errore &lt;&lt; endl;
        return os;
    }
};

int main(int argc, char** argv)
{    
    ifstream testo;
    testo.exceptions ( ios_base::badbit );

    try {

        char c     = 0;
        int  letti = 0;
                    
        /** 
        *   Verifica che ci siano sia il nome del file di input 
        *   che il numero di caratteri da leggere.
        */
        if (argc &lt; 3) 
            throw Eccezione(ERR_FILE_NONE, S_ERR_FILE_NONE);
            
        /** Definisce il numero di caratteri da leggere */
        int da_leggere = atoi(argv[1]);
        
        /** 
        *   Imposta la exception mask dello stream per fare
        *   sì che un errore di I/O generi un'eccezione,
        *   poi apre il file in lettura.
        *   Usa un blocco try/catch per intercettare una
        *   eventuale eccezione e gestirla in maniera
        *   omogenea al resto del codice.
        */
        try {
            testo.exceptions ( ios_base::badbit 
                             | ios_base::failbit );
            testo.open(argv[2]);            
        } catch(ifstream::failure e) {
            throw Eccezione(ERR_FILE_OPEN, S_ERR_FILE_OPEN);      
        }

        /**
        *   Re-imposta la exception mask per evitare
        *   eccezioni a fine file.
        */
        testo.exceptions ( ios_base::goodbit);

        /** 
        *   Legge il testo e lo stampa a video 
        *   Se è stato definito un numero massimo di 
        *   caratteri, si ferma lì.
        */
        while(testo.good()) {
            if((c = testo.get()) != EOF) {     
                letti++;
                cout &lt;&lt; c;
            } 
            if((da_leggere != 0) &amp;&amp; (letti &gt;= da_leggere)) {
                cout &lt;&lt; endl;
                break;
            }
        } 
                
        /** Chiude il file di input */
        testo.close();
            
    } catch (Eccezione e) {

        /** Stampa a video l'eccezione */
        cerr &lt;&lt; e;

        /** Esce con un codice di errore */
        exit(e.getCodice());
    }
    
    return 0;
}

</code></pre>

<!--

Attenzione, poi ad una caratteristica sinistra degli operatori << e >>: la loro precedenza è minore di quasi tutti gli altri operatori, il che vi consente di scrivere delle istruzioni come questa:
cout << "Due più due fa: " << 2 + 2 << '\n' ;
Sfortunatamente, però, gli operatori logici di AND |, di OR inclusivo & e di XOR esclusivo ^, hanno una precedenza minore degli operatori di shift su bit << e >>, e se non vengono isolate tra parentesi, le operazioni che li coinvolgono possono essere causa di errori. Per esempio, in un’istruzione come la seguente, l’ampersand verrebbe interpretato come un riferimento ad un oggetto, con conseguenze tutt’altro che piacevoli:
cout << "Il valore è: " << 2 & 2 << '\n' ;	// ERRORE! 
la sintassi corretta è invece:
cout << "Il valore è: " << (2 & 2) << '\n' ;	// OK

Altra cosa da dire è che le operazioni di lettura con l’operatore >> si arrestano al primo carattere di spaziatura e perciò l’output del codice:

#include "iostream.h"

void main()
{
 char * stringa[30] ;
	
	cin >> stringa ;		// legge la stringa 
	
	cout << stringa ;		// la visualizza
};

non riprodurrà tutta la stringa che voi passerete in input, ma solo i caratteri precedenti uno spazio bianco, ovvero, se per caso la stringa fosse.
Penso, quindi sono.
l’output che otterreste sarebbe:
Penso,
un po’ poco, purtroppo, ma così vanno le cose con gli operatori standard di inserimento e lettura, il cui comportamento di default prevede anche le seguenti convenzioni di for­mattazione:
	il formato di conversione della base è decimale. Nel caso questo set­taggio venga modificato, resterà così fino a nuovo ordine;
	il carattere di riempimento è lo spazio. Come avviene per le modifiche al formato di conversione, anche qui le modifiche sono mantenute fino a che una nuova istruzione non torni a modificarle;
	la precisione delle cifre a virgola mobile è la stessa utilizzata da print­f(), con arrotondamento della sesta cifra decimale (anche questo set­taggio è permanente);
	la larghezza del campo ha valore di default 0, il che significa che lo stream di output utilizzerà tutti i caratteri necessari alla visualizzazione dell’intero valore o stringa. La modifica di questo settaggio non è per­manente, quindi ad ogni operazione di output, la larghezza del campo verrà riportata a 0, quale che fosse il suo precedente valore.
    
Le gestione standard dell I/O della libreria iostream va bene per la maggior parte dei casi comuni di input ed output, ma si possono verificare delle situazioni particolari (come quella vista precedentemente) in cui potremmo aver bisogno di leggere o scrivere un’intera stringa di caratteri, compresi i caratteri di spaziatura, o di visualizzare un nu­mero in una base o una precisione differenti da quelle di default. Entrambe sono esigenze legittime ed anche abbastanza frequenti, che non possiamo però gestire con gli operatori di estrazione ed inserimento, ma per mezzo di apposite funzioni membro che la libreria iostream fornisce. Di seguito illustreremo i metodi di lettura e scrittura su stream che permettono la gestione di stringhe contenenti caratteri di spaziatura o dati binari, nel prossimo capitolo ci occuperemo invece dei diversi metodi di formattazione dell’input e dell’output.

5.5	funzioni di i/o a basso livello
Le funzioni membro della classe ios che permettono una gestione a basso livello delle operazioni di input ed output sono:

Funzioni per l’I/O di basso livello con gli stream

Il loro funzionamento è il seguente:
int get () ;
legge un singolo carattere (indifferentemente binario o di tipo testo) dallo stream di in­put e ne ritorna il valore. Se viene utilizzato con cin, attende la pressione del tasto Return prima di valutare il carattere e, contrariamente a quanto avviene con gli stream associati con files, legge la sequenza di caratteri Control-C come un break di sistema.
istream &  get (char & ) ;
istream &  get (unsigned char & ) ;
Entrambe queste funzioni leggono un carattere di tipo binario o testo dallo stream e lo scrivono all’indirizzo passato come parametro.
istream &  get (char *, int len, char = '\n') ;
istream &  get (unsigned char *, int len, char = '\n') ;
Leggono caratteri dallo stream di input fino a che non si verifica una di queste condizi­oni:
	sono stati letti (len-1) caratteri;
	è stato letto il carattere delimitatore (specificato dal terzo parametro);
	è stato letto il carattere di fine file EOF.
Nella stringa di output viene sempre aggiunto il carattere NULL finale. 
istream &  getline (char* , int, char = '\n') ;
istream &  getline (unsigned char* , int, char = '\n') ;
Il funzionamento di queste funzioni è simile al precedente solo che in questo caso il carattere terminatore viene letto ed inserito nella stringa prima del carattere NULL finale.
istream &  read (char * , int len) ;
istream &  read (unsigned char * , int len) ;
Similmente alla funzione get(), legge da uno stream len caratteri di testo binari, e li copia in un buffer. Contrariamente a quanto fa la funzione get(), non riconosce nessun carattere terminatore e non aggiunge caratteri NULL al termine del buffer.
int  peek () ;
Legge il carattere successivo dello streambuf associato, senza estrarlo. Per quanto riguarda l’utilizzo con stream associati a file, non ci sono problemi, ma consideriamo il seguente esempio:
PEEKTEST.CPP - Comportamento della funzione Peek()
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	PEEKTEST.CPP - Comportamento della funzione Peek()
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
/////////////////////////////////////////////////////////////
void main()
{
 char c ;	

	cin >> c ;							 //001
	cout << "Il primo carattere è: " << c  << '\n' ;	 //002

	c = cin.peek() ;						 //003
	cout << "Il prossimo sarà: " << c  << '\n' ; 	 //004
}
/////////////////////////////////////////////////////////////
001  Legge un carattere dallo stream di input.
002  Lo visualizza.
003  Legge il carettere successivo dallo streambuf assegnandolo alla variabile c.
004  Visualizza il valore di c.
Vi chiederete (spero) come sia possibile che peek() possa leggere un carattere da cin se l’istruzione 001 prevede l’input di un solo carattere. Il fatto è che qualsiasi operazione di input dallo standard stream cin legge tutti i caratteri inseriti dall’utente prima della pressione del tasto Return, li immagazzina nello streambuf associato per estrarre poi solo i caratteri richiesti. Se in risposta all’istruzione 001 avessimo quindi dato al pro­gramma precedente un input del tipo:
Test
nello streambuf associato a cin sarebbero finiti tutti e quattro i caratteri digitati, ma il programma, fedele ai suoi ordini, avrebbe considerato solo il primo, e l’istruzione 002 avrebbe prodotto questo output:
Il primo carattere è: T
ovviamente, l’output dell’istruzione 004 sarebbe stato:
Il prossimo sarà: e
Come tutte le altre funzioni precedentemente esaminate, anche peek() gestisce indiffer­entemente caratteri di tipo testo o binari, quindi nel caso l’imput fosse stato di un solo carattere, l’istruzione 004 avrebbe letto e visualizzato il carattere di newline '\n'.
istream &  putback (char) ;
Questa funzione permette di reinserire un carattere, precedentemente letto, in uno stream. Se invece il carattere lo volete deliberatamente ignorare, allora la prossima funzi­one fa al caso vostro.
istream &  ignore ( int dim = 1, int = EOF) ;
Permette di evitare la lettura di dim caratteri. Si interrompe se viene letto il carattere de­finito come terminatore (di default EOF). 
ostream &  put (char) ;
È la versione speculare dell’istruzione get(char) e permette di inserire un carattere in uno stream. Gestisce testo o dati binari e si può utilizzare tanto con gli stream standard che con quelli associati a file.
ostream &  write (const char* , int n) ;
ostream &  write (const unsigned char* , int n) ;
Legge n caratteri dal buffer passato come parametro e li scrive nello stream di output. Attenzione perché, come del resto read(), write() non fa nulla di più e se volete un terminatore alla fine del buffer ce lo dovete mettere voi.
5.6	gestione degli errori con la classe ios
Abbiamo appena visto che esistono delle funzioni che consentono di leggere o scrivere un numero predeterminato di caratteri in uno stream:
char buffer[256] ;
is.read (buffer, 256) ;
Le ipotesi considerate prima, però, prevedevano situazioni ideali, in cui ciò che una parte richiedeva era esattamente quello che l’altra parte aveva da offrire, ma cosa succederebbe se per una qualsiasi ragione la funzione read() dell’esempio non riuscisse a leggere tutti i 256 caratteri previsti? Più in generale, possiamo sapere se una funzione o un’operazione di inserimento o estrazione ha avuto successo o è fallita? La risposta è sì, lo possiamo fare grazie ad alcune funzioni che ritornano o settano il valore delle variabile di stato dello stream.

Quando un’operazione di lettura o scrittura su stream fallisce, un bit di un dato membro della classe ios, chiamato ios::state, assume un valore differente da zero quindi, esaminando il valore di state, possiamo risalire al tipo di errore occorso. I valori che state può assumere sono elencati in un’enumerazione propria della classe ios, chiamata ios::io_state:

class ios
{
 protected:
			...
			int state ;		// variabile di stato
			...
 public:
			...

 enum io_state
 {
  goodbit = 0x00 ; // nessun errore
  eofbit  = 0x01 ; // raggiunta la fine del file
  failbit = 0x02 ; // l'ultima operazione di I/O è fallita
  badbit  = 0x04 ; // l'ultima operazione non era valida
  hardfail = 0x08; // errore irrecuperabile
 }
		...
} ;
Come vedete da quest’estratto della dichiarazione della classe ios, l’enumerazione io_state è pubblica, e quindi potete avere dei riferimenti ad essa nel vostro codice, mentre la variabile di stato è dichiarata come membro protected della classe, e quindi qualunque tentativo di accedere ad essa direttamente causerà un errore di compilazione:
int flagEOF  = ios::eofbit ;	// OK, è pubblica
int varStato = ios::status ;	// ERRORE! È privata
Questo è un tipico esempio di protezione dei dati membro: dichiarando state come suo membro protected, la classe ios evita che accessi arbitrari possano pregiudicarne l’affidabilità. Eventuali valutazioni e modifiche della variabile sono permesse a funzioni esterne alla classe (o alle sue discendenti) solo attraverso alcune funzioni pubbliche di interfaccia che comprendono anche la sovrapposizione di un operatore ed una funzione di conversione:
Funzioni di interfaccia per la verifica dello stato dello stream

La ridefinizione dei due operatori di cast a void e di NOT logico sono estremamente utili perché permettono di utilizzare l’identificatore di un oggetto di classe derivata da ios in una istruzione booleana per verificare il corretto svolgimento delle operazioni di inseri­mento o estrazione:

while( is.get(c) )	
{
	cout.put( c ) ;						
}
Il prossimo esempio mostra le possibilità di verifica e correzione degli errori di I/O con le classi stream:
IOERROR.CPP - Verifica e correzione degli errori di I/O su stream
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	IOERROR.CPP - Verifica e correzione degli errori di I/O
//
/////////////////////////////////////////////////////////////
#include <fstream.h>
/////////////////////////////////////////////////////////////
void main()
{
 char c ;
 ifstream is("test.dat") ;                            // 001

	while(is)                                        // 002
	{
		is >> c ;                                       // 003

		if( ! is.good() )                               // 004
		{
			if( is.eof())
				cerr << "\nRaggiunta la fine del file" ;	

			if( is.fail())
				cerr << "\nErrore irrecuperabile" ;

			if( is.bad() )                            // 005
			{
				cerr << "\nOperazione non valida" ;
				is.clear() ;                        // 006
			}
		}
		else	cout << c ;	                              // 007
	}
}
/////////////////////////////////////////////////////////////
001  Apre in lettura uno stream associandolo al file  test.dat (fidatevi, per ora...).
002  Ripete il ciclo finché non si verifica un errore.
003  Legge un carattere dallo stream di input.
004  Se ci sono problemi, verifica la gravità dell’errore.
005  Se si tratta di un errore lieve.
006  Resetta la variabile ios::state a 0.
007  Se non ci sono errori di input, scrive il carattere sullo standard output.
TEST.DAT - File per la verifica degli errori di I/O su stream
123
1.234
abcdefg
Così com’e, il programma non va in errore che a fine file. Sostituendo il tipo della vari­abile c da char a double, va in errore alla terza linea, definendo c come int, l’errore arriva al numero decimale. In tutti e tre i casi l’interruzione del programma è causata dalla linea 002 che, andando a controllare lo stato dello stream, lo troverà alterato dall’operazione fallita.
5.7	formattazione dei dati con le classi stream
Abbiamo visto precedentemente che le classi stream operano una formattazione di de­fault sui diversi tipi di dato. Possono esserci dei casi, però, in cui questo comportamento predefinito risulta insufficiente o inadeguato alle nostre necessità. Potremmo voler visu­alizzare un intero in formato esadecimale o un carattere come intero decimale, non ci sarebbe nulla di strano, ma la formattazione standard delle classi stream non ce lo per­metterebbe.
In compenso, però, la classe ios possiede dei membri dati di tipo protected il cui valore definisce la formattazione delle funzioni di I/O. Modificando il valore di questi dati mem­bro si modifica di conseguenza il comportamento dello stream, adattandolo alle necessità del caso. I dati membro di ios che determinano con il loro valore le caratteristiche dell’ I/O sono:
	x_fill : intero, definisce il carattere di riempimento per l’output;
	x_precision: intero, definisce la precisione in virgola mobile per l’output;
	x_width: intero, definisce la dimensione del campo in input;
In quanto membri protetti, questi valori non sono modificabili direttamente da un oggetto di classe derivata (ostream, istream ecc.). Qualunque modifica o verifica di stato va fatta per mezzo di una delle apposite funzioni di interfaccia elencate di seguito: 
Funzioni di interfaccia per la modifica della formattazione

Per mezzo di queste funzioni è possibile modificare il formato di conversione della base, il carattere di riempimento, la precisione delle cifre decimali e la larghezza del campo. Come abbiamo visto, le prime tre modifiche sono permanenti (ovvero, se si modifica il formato di output di uno stream, questo resterà nel nuovo stato fino alla prossima istruzione di modifica), mentre la quarta no: ad ogni operazione di output il valore della lunghezza del campo viene resettato a zero.
Vediamole all’opera tutte insieme queste funzioni nel prossimo esempio che mostra anche come il settaggio dell’ampiezza del campo non sia permanente:
FORMOUT.CPP - Modifica della formattazione dell’ouput
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	FORMOUT.CPP - Modifica dellla formattazione dell'output
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
/////////////////////////////////////////////////////////////
void main()
{
 double d = 123.456789 ;

  cout << "\nPrecisione = "<< cout.precision() ; 	// 001
  cout << "\nRiempimento = '"<< cout.fill() << "'";	// 001
  cout << "\nLarghezza = " << cout.width() ;		// 001

  cout << "\nVisualizzazione = "<< d ;			// 002
  cout << "\nCon i nuovi settaggi = " ;			// 003
  cout.precision(3) ;						// 004
  cout.fill('#') ;						// 004
  cout.width(10) ;						// 004
  cout << d ;							// 005

 cout << "\nVia precision() e fill() = " ;
 cout.width(10) ;							// 006
 cout << d ;							// 007

 cout << "\nVia anche width() = " << d ;			// 008

 cout << "\nPrecisione = " << cout.precision() ;	// 009
 cout << "\nRiempimento = '"<< cout.fill() << "'" ;	// 009
 cout << "\nLarghezza = " << cout.width() ;		// 009
};
/////////////////////////////////////////////////////////////
001  Visualizza i settaggi di default.
002  Visualizza la variabile con i settaggi di default.
003  Vediamo se indovinate perché questa stringa va visualizzata separatamente...
004  Modifica i settaggi di default.
005  Visualizza la variabile con i nuovi settaggi.
006  Ripete solo la modifica della dimensione del campo.
007  Visualizza la variabile con i nuovi settaggi.
008  Visualizza la variabile senza effettuare settaggi.
009  Visualizza il valore delle variabili dopo i settaggi.
L’ouput di questo esempio è:

Precisione = 6
Riempimento = ' '
Larghezza = 0
Visualizzazione = 123.456789
Con i nuovi settaggi = ###123.457
Via precision() e fill() = ###123.457
Via anche width() = 123.457
Precisione = 3
Riempimento = '#'
Larghezza = 0
Come potrete vedere, le modifiche apportate con precision() e fill() rimangono at­tive anche dopo una prima operazione di output, mentre quelle conseguenti a width() no. Per questa ragione, le intestazioni delle righe 005 e 007 sono visualizzate prima delle modifiche. Se così non fosse stato, e cioè se la riga 005 fosse stata:
cout << "\nCon i nuovi settaggi = " << d ;		// 005
l’operazione di output della stringa avrebbe resettato il valore di x_width e l’output sarebbe quindi stato:

Con i nuovi settaggi = 123.457
5.8	modifica dei flags di formattazione
Ma la larghezza del campo, la precisione ed il carattere di riempimento non sono le uniche formattazioni modificabili. Un altro modo di modificare le convenzioni di format­tazione standard è quello di alterare la variabile membro x_flags che contiene i flags per la formattazione. 
La dichiarazione della variabile è:

class ios
{
			...
 protected:
			...
			long x_flags ;
			...
Anche la variabile x_flags, come x_state è un membro protected di ios, quindi anche in questo caso non sarà possibile nessuna modifica diretta da parte di funzioni esterne alla classe, ma solo quelle previste e concesse dalle funzio­ni di interfaccia:
long ios::flags() 
long ios::flags(long flags)
long ios::setf(long flags)
long ios::setf(long group, long bits)
long ios::unsetf(long flags)
I flags che vengono utilizzati con queste funzioni sono definiti in un’enumerazione prop­ria della classe ios:

enum    
{
 skipws    	= 0x0001, 
 left      	= 0x0002,
 right     	= 0x0004,
 internal  	= 0x0008,
 dec 		= 0x0010,
 oct 		= 0x0020,
 hex 		= 0x0040,
 showbase  	= 0x0080,
 showpoint 	= 0x0100,
 uppercase 	= 0x0200,
 showpos   	= 0x0400,
 scientific	= 0x0800,
 fixed     	= 0x1000,
 unitbuf   	= 0x2000,
 stdio     	= 0x4000 
};
La tabella seguente mostra il modo in cui riferirsi ai diversi flag nei programmi e le con­seguenze della loro alterazione sul comportamento della classe:
Funzioni di interfaccia per la modifica della variabile x_flags

Le costanti che invece definiscono i campi di bit su cui operare sono:
Costanti per la modifica della variabile x_flags

Vediamo ora in dettaglio il funzionamento delle diverse funzioni:
long ios::flags() 
long ios::flags(long flags)

La prima versione della funzione flags() è innocua: semplicemente ritorna il valore della variabile x_flags; un po’ più di attenzione va rivolta invece all’utilizzo della secon­da versione, che sostituisce la variabile con quella passatale come parametro, ritornando il vecchio valore. Se per esempio voleste modificare solo il flag ios::hex senza andare ad intaccare lo stato degli altri flag di formattazione, dovreste scrivere qualcosa di simile:
FLAGSTST.CPP - Test della funzione ios::flags()

/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	FLAGSTST.CPP - Test della funzione ios::flags()
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
/////////////////////////////////////////////////////////////
void main()
{
 ostream os(2) ;							  // 001
 long flgs = os.flags() ;					  // 002

 os << "flgs  : " << flgs << "\n" ;				  // 003
 os.flags(flgs ^ ios::dec | ios::hex | ios::showbase); // 004
 os << "flgs  : " << flgs << "\n" ;				  // 005
 os << "flags : " << os.flags() << "\n" ;			  // 006

 os.flags(0) ;							  // 007
 os << "flags : " << os.flags() << "\n" ;			  // 008
};
/////////////////////////////////////////////////////////////
001  Invia l’output a stdout.
002  Salva il valore iniziale di x_flags.
003  Visualizza il valore iniziale di x_flags.
004  Esegue un’operazione di XOR esclusivo sulla variabile per annullare il bit di controllo del formato decimale, quindi, con due operazioni di OR inclusivo, setta i nuovi bit di controllo ed infine passa la variabile alla funzione flags.
005  Visualizza il valore iniziale di x_flags con i nuovi settaggi.
006  Visualizza il nuovo valore della variabile x_flags.
007  Reimposta il formato standard dei flags di formattazione.
008  Visualizza il nuovo valore della variabile x_flags.
L’output di questo programma su una macchina MS-DOS è stato:

flgs  : 1
flgs  : 0x1
flags : 0xd1
flags : 0 
long ios::setf(long flags)
long ios::setf(long flags, long mask)
L’utilizzo della funzione setf() è meno problematico di quello della sua collega: la prima versione modifica i bit di formattazione settati ad 1 in flags e ritorna il vecchio valore della variabile; la seconda versione in­vece assegna ai bit di formattazione specificati da mask il valore dei bit corrispondenti in flags, ritornando il vecchio valore della variabile.
long ios::unsetf(long flags)
Questa funzione di formattazione azzera i flag di formattazione settati ad 1 in flags e ritorna il valore precedente della variabile. La caratteristica di setf() (in tutte e due le sue ver­sioni) di impedire il settaggio di flag in opposizione, fa sì che il suo uso non sia partico­larmente frequente.
5.9	manipolatori
Esiste anche un altro modo per modificare la formattazione dell’I/O delle classi stream e consiste nell’utilizzare particolari funzioni membro, dette manipolatori o gestori e defi­nite nel file iomanip.h. 
La differenza fra i manipolatori e le funzioni di gestione della formattazione che abbiamo appena esaminato, è che i manipolatori restituiscono un riferimento allo stream sul quale intervengono, quindi possono essere utilizzati in cascata, esattamente come gli operatori di inserimento ed estrazione. Attenzione, però, perché, anche se la loro sintassi è la stessa degli operatori << e >>, i manipolatori non effettuano nessun tipo di operazione di in­serimento o estrazione, bensì alterano le variabili di formattazione dello stream, modifi­candone il comportamento nel modo descritto nella tabella seguente:
Manipolatori 

Come vedete, esistono sette gestori non parametrizzati e sei che invece prevedono degli argomenti. I primi sono dichiarati nel file header iostream.h e non necessitano quindi di nessun’altra inclusione per poter essere utilizzati. I gestori parametrizzati, invece, hanno una struttura più complessa, dichiarata nel file header iomanip.h che deve essere perciò incluso in qualunque programma ne faccia uso. 
Nel caso vi stiate chiedendo a cosa mai possa servire un altro metodo di formattazione dell’output, eccovi un breve ma significativo esempio sull’utilizzo dei manipolatori:

MANIPTST.CPP - Utilizzo dei manipolatori
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	MANIPTST.CPP - Utilizzo dei manipolatori
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
#include <iomanip.h>						// 001
/////////////////////////////////////////////////////////////
void main()
{
 int num = 29 ;

	cout.fill('#') ;						// 002
	cout.width(8) ;						// 003
	cout << num << "\n";					// 004

	cout << setfill('.') << setw(7) << num ;		// 005
};
/////////////////////////////////////////////////////////////
001  Inclusione necessaria per utilizzare le versioni parametrizzate.
002  Definisce un carattere di riempimento.
003  Definisce una larghezza di output.
004  Visualizza il numero.
005  La stessa cosa, tutta in una linea di codice.
Come vedete, si ritorna sempre al solito discorso di rendere la vita il più facile possibile al programmatore. E per semplificarvela ancora di più (o complicarvela...), potete scriv­ere voi stessi i vostri manipolatori. 
Questa è la dichiarazione di un manipolatore che in­serisce nello standard stream di ouput il carattere ASCII 7:

ostream & beep (ostream & os)
{
	return os << '\a' ; 	//codice di escape per BELL
}
per scoprire a cosa serve, compilate ed eseguite il seguente esempio:
MANIPDU.CPP - Manipolatori definiti dall’utente
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	MANIPDU.CPP - Manipolatori definiti dall'utente
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
#include <iomanip.h>						
/////////////////////////////////////////////////////////////
ostream & beep (ostream & os)
{
	return os << '\07' ;
}
/////////////////////////////////////////////////////////////
void main()
{
	cout << "\nCosa succede?" << beep ;			
}
/////////////////////////////////////////////////////////////
Crearsi i propri manipolatori personalizzati può essere piuttosto utile e non è un compito particolarmente complesso se si tengono a mente alcune regole di base (ed a patto che ci si ricordi di includere nel codice il file iomanip.h ):
	i gestori hanno associatività da sinistra a destra, quindi per potere modificare la formattazione di una variabile, debbono precederla nell’istruzione di I/O:

int n = 33 ;
cout << n << hex ;	// ERRORE! non succede nulla
cout << hex << n ;	// OK
	il tipo di ritorno dev’essere un riferimento allo stream su cui si intervi­ene. Se state scrivendo un manipolatore che agisce su oggetti di classi derivate da istream  il tipo di ritorno dev’essere di tipo istream & ;
	il primo argomento dev’essere un riferimento allo stream che si deve manipolare (valgono le stesse considerazioni fatte sopra) ;
	oltre al riferimento allo stream, la funzione può avere solo un altro ar­gomento, che dev’essere obbligatoriamente o un int o un long .
5.10 stream per I/O su file
Come avevamo detto all’inizio del capitolo, le classi derivate da ios non permettono solo la gestione dell I/O standard da tastiera e su terminale, ma consentono di estendere i benefici dell’approccio orientato agli stream anche alla gestione dei files. 
Concettualmente, i files possono essere assimilati a degli stream: un file da cui si leggono dei dati è un caso particolare di stream di input, un file sul quale invece i dati vengono scritti è a tutti gli effetti un caso particolare di stream di output. Allo stesso modo, la classe ifstream, che si occupa dell’input da file è una specializzazione di istream, mentre la classe ofstream, che gestisce invece l’output, è derivata da ostream. Entrambe poi ereditano da fstreambase, una classe diretta discendente di ios, che fornisce metodi comuni per la gestione dei files e che, insieme ad iostream, serve da base per fstream. Quest’ultima è una classe che, com’è facilmente prevedibile, dati i natali, permette tanto operazioni di input che di output su file. 
Detto così è complicato come l’intreccio di una soap opera, ma forse lo schema seguente vi può aiutare un po’:

In quanto derivazioni di istream ed ostream, la maggior parte delle regole che si applicano agli stream di I/O su file sono sostanzialmente le stesse che abbiamo finora esaminato per gli stream di input ed output standard, qualche differenza però c’è. 
La prima è che, per per poter utilizzare queste classi, è necessario includere nel vostro sorgente il file fstream.h, le altre riguardano invece il modo in cui gli stream vengono dichiarati e collegati ai files. I metodi possibili sono (diamo per scontato che i nostri ven­tisei lettori siano abbastanza astuti da capire che quando ci riferiamo ad oggetti fstream intendiamo una qualunque delle tre classi per la gestione dei files):
	dichiarare un oggetto fstream senza parametri: in questo modo otten­tete uno stream privo di connessione a file (la connessione verrà fatta in seguito per mezzo della funzione membro open());

fstream unFile ;	// nessuna connessione con files
	dichiarare un oggetto fstream con un inizializzatore intero: l’intero dev’essere ovviamente una handle ad un file DOS aperto precedente­mente ;

ofstream aVideo(2); // associa lo stream con lo stdout
	dichiarare un oggetto fstream passando come parametri al costruttore una stringa ed una modalità di apertura: la stringa conterrà il nome del file da aprire, le modalità di apertura è un elemento dell’enumerazione ios::open_mode, che esamineremo tra breve.

ifstream is("a.dat", ios::in); // apre a.dat in lettura
In quest’ultimo caso, il secondo parametro passato al costruttore dell’oggetto, ios::in, definisce il modo in cui verrà aperto il file da associare allo stream. I valori possibili, così come sono dichiarati all’interno della classe ios, sono:

enum open_mode  
{
 in         = 0x01, // apre il file in lettura
 out        = 0x02, // apre il file in scrittura
 ate        = 0x04, // apre il file, quindi va alla sua fine
 app        = 0x08, // apre il file in modalità append
 trunc      = 0x10, // azzera il file se già esiste
 nocreate   = 0x20, // apre solo un file già esistente
 noreplace	= 0x40, // non apre un file esistente
 binary     = 0x80  // apre il file in modalità binaria
};
Le modalità ios::in è quella di default per la classe ifstream; ios::out, è il de­fault per ofstream. Per ottenere delle modalità particolari come, ad esempio, l’apertura di un file in input binario o in input ed output di un file che non dev’essere però sovras­critto se già esistente, si possono combinare fra loro i valori di open_mode con delle operazioni di OR logico:
fstream fs( "pippo.dat", ios::in | ios::binary);
fstream fs( "pippo.dat", ios::in | ios::out | ios::nocreate);
L’ultimo costruttore delle classi fstream ha anche un terzo parametro che defiisce la modalità di protezione per il file. La sua dichiarazione è infatti():
ifstream(const char* nome, int mode, int prot=ios::openprot);
Come noterete, però, il parametro prot ha un suo valore di default, ios::openprot, che, almeno per ora, è anche l’unico possibile, quindi potete tranquillamente ignorarlo. 
Orbene, dopo aver tanto parlato, eccovi un esempio che mostra tutti questi nostri nuovi amici all’opera:
FSTRTEST.CPP - Utilizzo delle classi fstream
/////////////////////////////////////////////////////////////
//
//  Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//  FSTRTEST.CPP - Utilizzo delle classi fstream
//
/////////////////////////////////////////////////////////////
#include "fstream.h"
#include "stdlib.h"
/////////////////////////////////////////////////////////////
void main()
{
 ifstream is ;                                        // 001
 fstream fs("iofile.dat",
            ios::out|ios::trunc|ios::binary ) ;       // 002

    if( ! fs )
	   cerr << "\nErrore in apertura file di output" ;

    is.open("fstrtest.cpp", ios::nocreate ) ;         // 003

    if( ! is )
        cerr << "\nErrore in apertura file di input" ;

    while(is)                                         // 004
    {
	unsigned char c ;
        
        is.get(c) ;                                   // 005
        if( ! is.good() )                             // 006
        {
		      if( is.eof())
			    cerr << "\nRaggiunta la fine del file" ;

			if( is.fail())
                cerr << "\nErrore irrecuperabile" ;

            if( is.bad() )                           // 007
            {
                cerr << "\nOperazione non valida" ;
	           is.clear() ;                         // 008
            }
        }
        else if( ! fs.put(c) )                       // 009
        {
            cerr << "\nErrore in scrittura" ;
            cerr << " posizione " << fs.tellg() ;
        }
}
/////////////////////////////////////////////////////////////
001  Apre un file stream di input senza associarlo a nessun file.
002  Apre un file stream generico in output binario. Se il file già esiste, lo azzera.
003  Associa l’oggetto ifstream con un file preesistente e lo apre.
004  Ripete il ciclo finché non ci sono errori.
005  Legge un carattere dal file di input.
006  Verifica che non ci siano problemi.
007  Se si è verificato un errore lieve...
008  ...resetta la variabile di stato.
009  Copia il carattere nel file di output.
Come spero l’esempio abbia chiarito, le funzioni di controllo, i manipolatori e gli opera­tori di inserimento ed estrazione, si possono applicare agli stream di I/O su file esatta­mente come avveniva per gli oggetti di classe iostream o ostream. 
La funzione open(), utilizzata alla riga 007, è una funzione membro che serve ad aprire un file colle­gandolo con uno stream precedentemente aperto. La sua dichiarazione, che ricorda molto quella del costruttore della classe fstream, è la seguente:
void open(char const*, int, int = filebuf::openprot) ;
L’altra funzione membro utilizzata nell’esempio è tellg(), che fstream eredita in secondo grado della classe istream. Ritorna la posizione della prossima operazione di estrazione () e la sua dichiarazione è:
long tellg() ;
5.11 POsizionamento negli stream di i/o su file
Simile alla funzione membro tellg(), è la funzione tellp(), che  fstream eredita da sua "nonna" ostream e che ritorna la posizione della prossima operazione di inseri­mento. Complementari a tellg() e tellp() sono, rispettivamente, seekg() e seekp(), che posizionano nel file ad una posizione relativa o assoluta. La tabella seguente riporta le dichiarazioni delle diverse funzioni:
Funzioni di posizionamento su stream

Le funzioni seekg(long pos) e seekp(long pos), posizionano la prossima op­erazione sullo stream all’indirizzo assoluto pos. 
Le versioni seekg(long pos,seek_dir) e seekg(long pos, seek_dir), spostano ad una posizione che è a pos bytes dal punto definito dal secondo argomento della funzione, che è un membro dell’enumerazione  seek_dir, definita, tanto per cambiare, all’interno della classe ios:

enum seek_dir 
{ 
	beg=0, 
	cur=1, 
	end=2 
};
L’effetto dei diversi parametri è il seguente:
	ios::beg: sposta la prossima operazione a pos bytes dall’inizio del file associato;
	ios::cur: si sposta a pos bytes dalla posizione corrente;
	ios::end: si sposta a pos bytes prima della fine del file.
5.12 SISTEMI DI FUNZIONI ITERATE
Il prossimo esempio riunisce un po’ tutti gli elementi esaminati in questa parte del manuale. Si tratta di un visualizzatore di sistemi di funzioni iterate (da adesso in poi abbreviato in IFS) che visualizza delle immagini applicando delle trasformazioni casuali alle coordinate di un un punto. Se il valore delle coordinate iniziali è (X, Y) le coordinate Xnew, Ynew del nuovo punto saranno:

Xnew = a*X + b*Y + c 
Ynew = d*X + e*Y + f
laddove a, b, c, d, ed f sono i valori che definiscono la trasformazione e variano a seconda del tipo di immagine che si desidera ottenere.

void CreaMatrice(char * filename)
{
 ifstream is ;
 double somma = 0 ;

	is.open(filename) ;

	if( ! is ) Erore("\nErrore in apertura file di input") ;
	is >> Set ;

	for(int r = 0 ; r < Set.Righe ; r++ )
	{
		for(int c = 0 ; c < 7 ; c++)
 			  is >> Matrice[r][c]  ;

		Matrice[r][0] += somma ;
		somma = Matrice[r][0] ;
	}
}
Questa funzione legge da uno stream di input un set di parametri fissi per ogni IFS (numero delle trasformazioni, posizionamento sullo schermo, titolo ecc.), quindi riempie una matrice con i valori delle trasformazioni, che hanno questo formato:
Set di trasformazioni

I valori contenuti nella prima colonna determinano le probabilità che la trasformazione ha di essere selezionata: in questo caso 1/3 ciascuna, ma i valori possono essere differenti per far sì che una trasformazione venga applicata più frequentemente delle altre. 
Una volta determinati i valori per le trasformazioni, non resta che applicarle casualmente alle coordinate del punto, visualizzando di volta in volta il pixel corrispondente. Ed è qui che la cosa si fa interessante: per quanto le trasformazioni vengano applicate casualmente ed indipendentemente dalle coordinate iniziali del punto, la figura generata sarà sempre la stessa. Provare per credere:
IFS.CPP - Programma di visualizzazione per sistemi di funzioni iterate

-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/polimorfismo" 
           title="Vai a: Il polimorfismo" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/debug" 
           title="Vai a: Il debug" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
