<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Gli stream |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Gli stream" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    <a title="Vai a: Il polimorfismo" 
        
        href="/man/polimorfismo" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Il debug" 
        
        href="/man/debug" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Gli stream
            </h1>

            <blockquote class="motto">Non puoi immergere i tuoi byte due volte nello stesso stream</blockquote>

            <section id="testo">

                <p>Oggi ti parlerò degli <em>stream</em> che, com’è noto, sono la componente più importante del C++.</p>

<p>Il C++ eredita dal C l’assenza di parole chiave per la gestione dell’I/O.
Al posto di istruzioni come la <code>print</code> del BASIC, utilizza delle librerie di classi e funzioni che permettono di convertire in testo stampabile gli oggetti gestiti dal programma o di convertire degli elementi testuali in oggetti.
Non potrebbe essere altrimenti: il C++ non deve gestire solo stringhe e numeri, come il BASIC, ma anche numeri in virgola mobile, puntatori e soprattutto i tipi di dato definiti dall’utente, per i quali non sarebbe possibile definire un comportamento standard e che quindi dovrebbero essere trattati in maniera differente dai dati primitivi, con tanti saluti alla coerenza del linguaggio.<br />
Oltre a poter sfruttare le librerie di funzioni del <em>C</em>, il C++ ha una propria libreria di I/O, ba­sata sulla gerarchia delle classi <code>stream</code>, che permette di gestire anche i tipi di dato definiti dall’utente.
Abbiamo visto degli esempii di questa caratteristica quando abbiamo parlato di <a href="/man/c-plus-plus#polimorfismo" class="xref">polimorfismo</a> e di <a href="/man/polimorfismo#overload-operatori" class="xref">overload degli operatori</a>:</p>

<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; "Specie:" &lt;&lt; animale.getSpecie() &lt;&lt; "\t"
        &lt;&lt; "Razza:"  &lt;&lt; animale.getRazza()  &lt;&lt; "\t"
        &lt;&lt; "Sesso:"  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}
</code></pre>

<p>Questo codice “insegna” all’operatore <code>&lt;&lt;</code> come comportarsi per visualizzare un oggetto di classe <code>Animale</code>. 
Lo stesso si può fare (e lo abbiamo fatto) per qualsiasi altro tipo definito dall’utente. 
È la sintassi del linguaggio che si adatta alle esigenze del programmatore, e non viceversa.<br />
Alcuni concetti chiave per la comprensione degli stream sono:</p>

<ul>
  <li>uno <em>stream</em> è un’astrazione che rappresenta la sorgente o la destinazione di un insieme di dati di lunghezza variabile: l’input da tastiera, l’output su schermo, i buffer di memoria, le stringhe, i file;</li>
  <li>l’output su stream verso una qualsiasi destinazione, viene definito <em>scrit­tura</em> o <em>inserimento</em> e si effettua per mezzo dell’operatore <code>&lt;&lt;</code>;</li>
  <li>con i termini <em>lettura</em> o <em>estrazione</em>, invece, si intende l’operazione di acquisizione da una sorgente, effettuata dall’operatore <code>&gt;&gt;</code>.</li>
</ul>

<p>La libreria <code>iostream</code> del C++ permette di gestire le operazioni di I/O su stream per mezzo di classi derivate da due classi base: <code>streambuf</code> e <code>iosbase</code>.
La libreria ha due diverse “linee genealogiche”: una destinata alla gestione dei caratteri di un byte e una destinata ai caratteri multi-byte.
Le classi della libreria multi-byte hanno lo stesso nome delle classi ordinarie, con l’aggiunta del prefisso: “w”.<br />
Questo è lo schema di ereditarietà delle classi della libreria <code>iostream</code>:</p>

<pre><code>                              ios_base
                                 |
                             basic_ios
                                 |
               __________________|_________________       
              |                                    | 
              |                                    | 
        basic_istream                         basic_ostream
             | |                                  | |   
             | |                                  | |  
             | |__________________________________| |  
             |                   |                  |   
      _______|______             |         _________|_______       
     |              |            |        |                 | 
basic_istringstream |            |   basic_ostringstream    |
                    |            |                          |
                    |            |                          |
               basic_ifstream    |                  basic_ofstream
                                 |
                            basic_iostream
                         ________|________
                        |                 |
               basic_stringstream    basic_fstream
          
</code></pre>

<p>A parte <code>ios_base</code>, queste sono tutte classi template che sono poi istanziate con parametri differenti per gestire la gestione dei tipi di carattere <code>char</code> and <code>wchar_t</code>. 
Per esempio, la classe <code>ostream</code> è una specializzazione della classe <code>basic_ostream</code>:</p>

<pre><code>typedef basic_ostream&lt;char&gt; ostream;
</code></pre>

<p>Il suo corrispettivo multi-byte è la classe <code>wostream</code>:</p>

<pre><code>typedef basic_ostream&lt;wchar_t&gt; wostream;
</code></pre>

<p>La classe template <code>basic_ostream</code>, a sua volta, deriva da <code>basic_ios</code>:</p>

<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ostream 
: virtual public std::basic_ios&lt;CharT, Traits&gt;
</code></pre>
<p>che, a sua volta, deriva da <code>ios_base</code>:</p>

<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ios 
: public std::ios_base	
</code></pre>

<p>In sostanza: se davanti al nome c’è il prefisso <code>basic_</code>, si tratta della classe template; se c’è c’è la lettera “w”, si tratta della versione multi-byte, altrimenti è la classe ordinaria.<br />
Oltre alle classi derivate da <code>iosbase</code>, la libreria comprende anche delle classi per la gestione dei buffer di dati:</p>

<pre><code>                       basic_streambuf
                      ________|________
                     |                 |
               basic_stringbuf     basic_filebuf
</code></pre>

<p>La classe template virtuale <code>basic_streambuf</code>, che fa parte della libreria, ma non della discendenza da <code>ios_base</code>, contiene i dati e le funzioni necessarie alla gestione di un buffer di caratteri.
Le sue classi derivate <code>basic_stringbuf</code> e <code>basic_filebuf</code> sono invece specializzate, rispettivamente, nella gestione di buffer in memoria e su file.
Anche in questo caso, la libreria comprende due versioni di ciascuna classe, specializzate per la gestione di <code>char</code> and <code>wchar_t</code>.</p>

<pre><code>typedef streambuf  basic_streambuf&lt;char&gt;
typedef wstreambuf basic_streambuf&lt;wchar_t&gt;
typedef stringbuf  basic_stringbuf&lt;char&gt;
typedef wstringbuf basic_stringbuf&lt;wchar_t&gt;
typedef filebuf    basic_filebuf&lt;char&gt;
typedef wfilebuf   basic_filebuf&lt;wchar_t&gt;
</code></pre>

<p>Come forse avrai intuito, esaminare le singole classi della libreria <code>iostream</code> è un’attività che rivaleggia, in quanto a tedio, con l’epigrafia classica, ma ci permetterà di vedere applicati tutta una serie di principii di cui abbiamo parlato nelle lezioni precedenti, perciò, facciamoci forza e andiamo a incominciare.</p>

<hr />

<p>La classe <code id="ios-base">ios_base</code> e la sua prima discendente <code id="basic-ios">basic_ios</code> sono classi generiche che forniscono le funzioni di base per la gestione degli stream, indipendentemente dal fatto che si tratti di stream di input o di output.<br />
Una peculiarità di <code>ios_base</code> è che non possiede un costruttore pubblico, quindi non è possibile utilizzarla per creare oggetti, ma solo come base per delle classi derivate.<br />
Le istanze specializzate di <code>basic_ios</code> sono:</p>

<pre><code>typedef basic_ios&lt;char&gt;    ios;
typedef basic_ios&lt;wchar_t&gt; wios;
</code></pre>

<p>Tramite i metodi di queste classi è possibile verificare o modificare lo stato interno dello stream, la sua formattazione o definire delle funzioni callback per la gestione dei dati.<br />
Il dato membro <code>openmode</code>, per esempio, definisce il modo in cui debba essere aperto lo stream:</p>

<table>
  <tbody>
    <tr>
      <td><em>app</em></td>
      <td>Fa sì che ogni operazione di output avvenga alla fine dello stream.</td>
    </tr>
    <tr>
      <td><em>ate</em></td>
      <td>In apertura dello stream, sposta il punto di inserimento al termine  (<em><strong>at e</strong>nd</em>) del buffer di I/O.</td>
    </tr>
    <tr>
      <td><em>binary</em></td>
      <td>Gestisce il contenuto dello stream come un flusso di dati binario.</td>
    </tr>
    <tr>
      <td><em>in</em></td>
      <td>Permette operazioni di input.</td>
    </tr>
    <tr>
      <td><em>out</em></td>
      <td>Permette operazioni di output.</td>
    </tr>
    <tr>
      <td><em>trunc</em></td>
      <td>Azzera il contenuto dello stream all’apertura.</td>
    </tr>
  </tbody>
</table>

<p>Il dato membro <code>iostate</code>, che utilizzeremo in uno dei prossimi esempii, contiene le informazioni sullo stato corrente dello stream:</p>

<table>
  <tbody>
    <tr>
      <td><em>goodbit</em></td>
      <td>Nessun errore</td>
    </tr>
    <tr>
      <td><em>eofbit</em></td>
      <td>È stata raggiunta la fine dello stream.</td>
    </tr>
    <tr>
      <td><em>failbit</em></td>
      <td>L’ultima operazione di I/O è fallita.</td>
    </tr>
    <tr>
      <td><em>badbit</em></td>
      <td>L’ultima operazione di I/O non era valida.</td>
    </tr>
    <tr>
      <td><em>hardfail</em></td>
      <td>Si è verificato un errore irrecuperabile.</td>
    </tr>
  </tbody>
</table>

<p>Entrambi questi dati membro sono delle <a href="/man/note#bitmask" class="xref">bitmask</a>, quindi possono contenere più di un valore.
L’istruzione seguente, per esempio, apre uno stream su file combinando in <code>OR</code> tre possibili valori per <code>openmode</code>:</p>

<pre><code>fstream file_io("io.txt"
               , ios_base::in | ios_base::out | ios_base::app);
</code></pre>

<p>Dopo <code>basic_ios</code>, le classi della libreria si specializzano nell’input o nell’output: da un lato <code>basic_istream</code>, da cui derivano i due stream standard di input <code>cin</code> e <code>wcin</code>; dall’altro <code>basic_ostream</code>, da cui derivano gli stream standard di output <code>cout</code>, <code>cerr</code>, <code>clog</code> e le loro controparti “wide”: <code>wcout</code>, <code>wcerr</code>, <code>wclog</code>.<br />
Da queste due classi generiche derivano delle classi template specializzate nell’input o nell’output su file o in memoria:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ifstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_istringstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ofstream 
: public basic_ostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_ostringstream 
: public basic_ostream&lt;Elem, Tr&gt;
</code></pre>

<p>e una classe capace di gestire entrambe le operazioni:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_iostream 
: public basic_istream&lt;Elem, Tr&gt;
, public basic_ostream&lt;Elem, Tr&gt;
</code></pre>

<p>anche questa, con due specializzazioni per la gestione di file e memoria:</p>

<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_stringstream 
: public basic_iostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_fstream 
: public basic_iostream&lt;Elem, Tr&gt;
</code></pre>

<p>Prima che ci assalga un attacco di narcolessia, vorrei mettere in atto tutto questo con qualche esempio.<br />
Abbiamo già visto diversi esempii di output su stream:</p>

<pre><code>cout &lt;&lt; "Hello World!"  // stringhe
     &lt;&lt; 12              // interi
     &lt;&lt; 0.35            // float
     &lt;&lt; argv[1]         // puntatori
     &lt;&lt; endl;               
</code></pre>

<p>Non abbiamo ancora parlato dell’input da stream, che però ha un funzionamento piuttosto simile:</p>

<pre><code>/** 
 * @file src/stream-input.cpp
 * Programma di esempio per la gestione dell'input da stream.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    string stringa;
    
    /** Scrive un messaggio sullo schermo */
    cout &lt;&lt; "Inserire una stringa: ";
    
    /** Legge una stringa da tastiera */
    cin &gt;&gt; stringa;

    /** La scrive sullo schermo */
    cout &lt;&lt; stringa &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>Questo codice legge una stringa dallo standard input e la scrive sullo schermo, ma ci mostra una peculiarità dell’input da stream:</p>

<pre><code>&gt; g++ src/cpp/stream-input-1.cpp -o src/out/esempio
&gt; src/out/esempio                                
Inserire una stringa: Penso, quindi sono.
Penso,
</code></pre>

<p>Come vedi, le operazioni di lettura con l’operatore » si arrestano al primo carattere di spaziatura; perciò, se vogliamo leggere tutta la stringa, dobbiamo modificare il codice:</p>

<pre><code>/** 
 * @file src/stream-input-2.cpp
 * Programma di esempio per la gestione dell'input da stream.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    char   buffer[256];
    string stringa;
    
    /** 
    *   Legge una stringa da tastiera tramite
    *   la funzione membro della classe istream.
    */
    cout &lt;&lt; "Inserire una stringa: ";
    cin.getline(buffer, 256);
    cout &lt;&lt; buffer &lt;&lt; endl;


    /** 
    *   Legge una stringa da tastiera tramite
    *   la funzione globale getline.
    */
    cout &lt;&lt; "Inserire una stringa: ";
    getline(cin, stringa);
    cout &lt;&lt; stringa &lt;&lt; endl;

    return 0;
}

</code></pre>

<pre><code>&gt; g++ src/cpp/stream-input-2.cpp -o src/out/esempio
&gt; src/out/esempio                                  
Inserire una stringa: Penso, quindi sono.
Penso, quindi sono.
Inserire una stringa: Cogito ergo sum.
Cogito ergo sum.
</code></pre>

<p>Il comportamento di default degli operatori di input da stream prevede anche delle convenzioni di for­mattazione: <!-- @todo:verificare --></p>
<ul>
  <li><strong>il formato di conversione della base è decimale</strong>;</li>
  <li><strong>il carattere di riempimento è lo spazio</strong>;</li>
  <li><strong>la precisione delle cifre a virgola mobile è la stessa utilizzata da print­f()</strong>, con arrotondamento della sesta cifra decimale;</li>
  <li><strong>la larghezza del campo ha valore di default 0</strong>, il che significa che lo stream di output utilizzerà tutti i caratteri necessari alla visualizzazione dell’intero valore o stringa.</li>
</ul>

<p>Le prime tre modifiche sono per­manenti: una volta impostati, i nuovi valori saranno validi fino a che un’altra istruzione non torni a modificarli; le modifiche alla larghezza del campo di input, invece, valgono solo per l’istruzione che le richiede.<br />
Un’altra caratteristica degli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code> è che la loro precedenza è minore di quasi tutti gli altri operatori, il che vi consente di scrivere delle istruzioni come questa:</p>

<pre><code>cout &lt;&lt; "Due più due fa: " &lt;&lt; 2 + 2 &lt;&lt; '\n' ;
</code></pre>

<p>Sfortunatamente, però, gli operatori logici di AND <code>|</code>, di OR inclusivo <code>&amp;</code> e di XOR esclusivo <code>^</code>, hanno una precedenza minore degli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code>  e, se non vengono isolate tra parentesi, le operazioni che li coinvolgono possono essere causa di errori. 
Per esempio, in un’istruzione come la seguente, l’operatore <code>&amp;</code> verrebbe interpretato come un riferimento a un oggetto, con conseguenze diverse da quelle attese:</p>

<pre><code>cout &lt;&lt; "Il valore è: " &lt;&lt; 2 &amp; 2 &lt;&lt; '\n' ;	// ERRORE! 
</code></pre>

<p>la sintassi corretta è, invece:</p>

<pre><code>cout &lt;&lt; "Il valore è: " &lt;&lt; (2 &amp; 2) &lt;&lt; '\n' ;	// OK
</code></pre>

<p>Quando un’operazione di lettura o scrittura su stream fallisce, il valore del dato membro <code>iostate</code> assume un valore differente da zero.
La classe basic_ios ha delle funzioni membro booleane che tornano <code>true</code> o <code>false</code> se il valore <code>iostate</code> indica un determinato evento e la funzione <code>rdstate</code> che torna il valore assoluto di <code>iostate</code>:</p>

<table>
  <tbody>
    <tr>
      <td>good</td>
      <td>nessun errore: il valore di <code>iostate</code> è 0</td>
    </tr>
    <tr>
      <td>eof</td>
      <td>è stata raggiunta la fine del file</td>
    </tr>
    <tr>
      <td>fail</td>
      <td>c’è stato un errore di I/O non bloccante</td>
    </tr>
    <tr>
      <td>bad</td>
      <td>c’è stato un errore di I/O bloccante</td>
    </tr>
    <tr>
      <td>rdstate</td>
      <td>torna il valore corrente di <code>iostate</code></td>
    </tr>
  </tbody>
</table>

<p>Queste funzioni permettono di interrompere la lettura o la scrittura di uno stream quando si verifica un errore o se si è raggiunta la fine del file.
Una cosa che non devi fare mai, però, è di utilizzare la funzione <code>eof</code> all’interno di un ciclo <code>while</code> per la lettura di un file:</p>

<pre><code>/** 
 * @file src/stream-eof.cpp
 * Gestione dell'I/O su file con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;
    int      n;
    
    /** apre il file in lettura */
    testo.open(argv[1]);
    
    /** Verifica che il file sia aperto */
    if(testo.is_open()) {
        
        /** Utilizza eof per gestire il ciclo */
        while(!testo.eof()) {

            /** Legge un numero dal file */
            testo &gt;&gt; n;

            /** Lo scrive a video */
            cout &lt;&lt; n &lt;&lt; endl;
        }
        
    }
        
    /** Chiude il file di input */
    testo.close();
    
    return 0;
}

</code></pre>

<p>Se fai leggere a questo programma un file che contenga i numeri: 10, 20 e 30, otterrai questo output:</p>

<pre><code>&gt; g++ src/cpp/stream-eof.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/stream-eof.txt       
10
20
30
30
</code></pre>

<p>L’errore si verifica perché il controllo della funzione <code>eof</code> avviene prima della quarta operazione di lettura, quando lo stream è ancora in stato <code>good</code>.
Un modo migliore di gestire questi casi è di utilizzare la funzione <code>good</code>, che ci permette di verificare anche la corretta apertura del file:</p>

<pre><code>/** 
 * @file src/stream-good.cpp
 * Gestione dell'I/O su file con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;
    int      n;
    
    /** apre il file in lettura */
    testo.open(argv[1]);
    
    /** 
    *   Il ciclo si ripete fino a che non 
    *   si verifica un errore
    */
    while(testo.good()) {

        /** Legge un numero dal file */
        testo &gt;&gt; n;

        /** Si interrompe se il file è finito */
        if(testo.eof()) break;
        
        /** Altrimenti, scrive il numero */
        cout &lt;&lt; n &lt;&lt; endl;
    }
                
    /** Chiude il file di input */
    testo.close();
    
    return 0;
}

</code></pre>
<p>Se compili ed esegui questo programma, ottieni il risultato corretto:</p>

<pre><code>&gt; g++ src/cpp/stream-good.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/stream-eof.txt        
10
20
30
</code></pre>

<hr id="eccezioni" />

<p>Le <em>eccezioni</em> permettono di gestire gli errori che avvengono durante l’esecuzione del programma. 
Quando succede qualcosa di anormale, il sistema <em>lancia</em> un’eccezione, ovvero trasferisce il controllo del processo dalla funzione corrente a blocchi di istruzioni specifici, chiamati <em>exception handler</em>. 
Perché tutto questo avvenga, il codice che genera l’errore deve essere racchiuso in un blocco <code>try</code>/<code>catch</code>:</p>

<pre><code>try {
    
    // codice che potrebbe dare errore
    
} catch (...) {

    //  istruzioni per la gestione dell'errore
}
</code></pre>

<p>Le eccezioni possono essere lanciate e gestite sia da codice specifico all’interno del programma, sia dai meccanismi automatici del C++:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-1.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    ifstream testo;

    /** 
    *   Fa sì che, se sia generata un'eccezione 
    *   in caso di errore nella gestione del file.
    */
    testo.exceptions ( ios_base::failbit );

    /** Questa istruzione genererà un'eccezione */
    testo.open("fileinesistente.txt");
    
    testo.close();
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, causerai un errore che, non essendo gestito dal programma, è gestito dalla funzione standard del C++:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-1.cpp -o src/out/esempio
&gt; src/out/esempio
libc++abi: terminating with uncaught exception of type
std::__1::ios_base::failure: ios_base::clear
: unspecified iostream_category error
zsh: abort      src/out/esempio
</code></pre>

<p>Se però inseriamo il codice che apre il file in un blocco <code>try</code>/<code>catch</code> e definiamo un <em>handler</em> per la gestione degli errori in apertura dei file, il risultato sarà più controllato:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-2.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        testo.exceptions ( ios_base::failbit );
        testo.open("fileinesistente.txt");        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; "Errore in esecuzione" &lt;&lt; endl;      
   
    }    
   
    return 0;
}

</code></pre>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-2.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Errore in esecuzione
</code></pre>

<p>Possiamo addirittura prevenire gli errori in apertura del file facendo sì che sia lo stesso programma a lanciare un’eccezione se si accorge che manca il nome del file nei parametri di avvio:</p>

<pre><code>/** 
 * @file src/stream-eccezioni-3.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        /** Verifica che esista il nome del file da aprire */
        if(argc &lt; 2)
            throw "Nome file mancante";
            
        testo.exceptions ( ios_base::failbit );
        testo.open(argv[1]);        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; "Errore in esecuzione" &lt;&lt; endl;      
   
    } catch(char const* msg) {
        
        cerr &lt;&lt; msg &lt;&lt; endl;
    }
   
    return 0;
}

</code></pre>

<p>In questo modo, il programma è in condizione di gestire tutti i possibili errori di esecuzione:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-3.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Nome file mancante
&gt; src/out/esempio nomefile.txt
Errore in esecuzione
</code></pre>

<p>La libreria standard del C++ ha una classe specifica per la gestione delle eccezioni:</p>

<pre><code>class exception {
public:
    exception () throw();
    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();
    virtual ~exception() throw();
    virtual const char* what() const throw();
}
</code></pre>

<p>Definendo una classe derivata da <code>exception</code> con altri dati membro e una funzione <code>what</code> specializzate, è possibile gestire in maniera più strutturata le segnalazioni di errore.
È quello che faremo nel prossimo esempio.</p>

<pre><code>/** 
 * @file src/stream-eccezioni-4.cpp
 * Programma di esempio per la gestione delle eccezioni.
 * Richiede, in input, il numero di caratteri da leggere 
 * e il path del file di input:
 *
 *    src/out/esempio &lt;n caratteri da leggere&gt; &lt;file di input&gt;
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;exception&gt;

using namespace std;

/** Codici e stringhe di errore */
#define ERR_NONE          0
#define ERR_PARAMETRI   -10
#define ERR_FILE_OPEN   -20
#define S_SINTASSI      "USO: esempio &lt;n caratteri&gt; &lt;path file&gt;"
#define S_ERR_PARAMETRI "Errore nei parametri di input."
#define S_ERR_FILE_OPEN "Impossibile aprire il file di input"

/**
*   Definisce una classe derivata da exception
*   per la gestione degli errori.
*/
class Eccezione: public exception
{
private:
    int         _codice;
    const char* _errore;
public:

    /** Costruttore */
    Eccezione(int codice, const char* errore) 
    : _codice(codice), _errore(errore) {        
    }
    
    /** Funzione virtuale pura: va ridefinita */
    virtual const char* what() const throw() {
        return _errore;
    }

    /** Funzioni di interfaccia */
    int getCodice() { return _codice; }
    const char* getErrore() { return _errore; }

    /** Ridefinizione dell'operatore di output */
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, Eccezione e){
        os &lt;&lt; e._codice &lt;&lt; ": " &lt;&lt; e._errore &lt;&lt; endl;
        return os;
    }
};

int main(int argc, char** argv)
{    
    ifstream testo;
    testo.exceptions ( ios_base::badbit );

    try {

        char c     = 0;
        int  letti = 0;
                    
        /** 
        *   Verifica che ci siano sia il nome del file di input 
        *   che il numero di caratteri da leggere.
        */
        if (argc &lt; 3) 
            throw Eccezione(ERR_PARAMETRI, S_ERR_PARAMETRI);
            
        /** Definisce il numero di caratteri da leggere */
        int da_leggere = atoi(argv[1]);
        
        /** 
        *   Imposta la exception mask dello stream per fare
        *   sì che un errore di I/O generi un'eccezione,
        *   poi apre il file in lettura.
        *   Usa un blocco try/catch per intercettare una
        *   eventuale eccezione e gestirla in maniera
        *   omogenea al resto del codice.
        */
        try {
            testo.exceptions ( ios_base::badbit 
                             | ios_base::failbit );
            testo.open(argv[2]);            
        } catch(ifstream::failure e) {
            throw Eccezione(ERR_FILE_OPEN, S_ERR_FILE_OPEN);      
        }

        /**
        *   Re-imposta la exception mask per evitare
        *   eccezioni a fine file.
        */
        testo.exceptions ( ios_base::goodbit);

        /** 
        *   Legge il testo e lo stampa a video 
        *   Se è stato definito un numero massimo di 
        *   caratteri, si ferma lì.
        */
        while(testo.good()) {
            if((c = testo.get()) != EOF) {     
                letti++;
                cout &lt;&lt; c;
            } 
            if((da_leggere != 0) &amp;&amp; (letti &gt;= da_leggere)) {
                cout &lt;&lt; endl;
                break;
            }
        } 
                
        /** Chiude il file di input */
        testo.close();
            
    } catch (Eccezione e) {

        /** Stampa a video l'eccezione */
        cerr &lt;&lt; e &lt;&lt; endl;

        /** Mostra la sintassi di chiamata **/
        cerr &lt;&lt; S_SINTASSI &lt;&lt; endl;
        
        /** Esce con un codice di errore */
        exit(e.getCodice());
    }
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, otterrai il seguente output, a seconda dei parametri forniti:</p>

<pre><code>&gt; g++ src/cpp/stream-eccezioni-4.cpp -o src/out/esempio
&gt; src/out/esempio                                      
-10: Errore nei parametri di input.
USO: esempio &lt;n caratteri&gt; &lt;path file&gt;

&gt; src/out/esempio 41                                   
-10: Errore nei parametri di input.
USO: esempio &lt;n caratteri&gt; &lt;path file&gt;

&gt; src/out/esempio 41 src/cpp/stream-input.txt          
Nacqui da famiglia ricca, ma troppo tardi

&gt; src/out/esempio 0 src/cpp/stream-input.txt 
Nacqui da famiglia ricca, ma troppo tardi.  
Secondogenito, vidi la florida impresa paterna andare in dote  
per diritto di nascita, ma anche per naturale inclinazione
ai miei monozigotici fratelli maggiori e, com'è consuetudine 
per i figli cadetti, fui avviato alla vita monastica.
Entrai in seminario all'età di nove anni e presi i voti il 
giorno del mio diciottesimo compleanno.
Conobbi il Maestro quattro anni dopo.  
</code></pre>

<hr id="formattazione-output" />

<p>In alcuni esempii precedenti abbiamo visto che è possibile modificare il formato di output di default di uno stream tramite dei <em>maipolatori</em>:</p>

<pre><code>cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; ":" 
     &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; ":" 
     &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
</code></pre>

<p>Lo stesso risultato si può ottenere per mezzo di apposite funzioni delle classi <code>ios_base</code> e <code>basic_ios</code>, che permettono di alterare il carattere di riempimento, la precisione delle cifre decimali e la larghezza del campo.
Le prime due modifiche sono permanenti la quarta no.
Se si modifica il formato di output di uno stream, questo resterà nel nuovo stato fino alla prossima istruzione di modifica, mentre il valore della lunghezza del campo viene re-impostato a zero dopo ogni operazione di output:</p>

<pre><code>/** 
 * @file src/stream-format.cpp
 * Formattazione dell'I/O con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;


int main(int argc, char** argv)
{    
    double d = 123.456789 ;

    /** Mostra i valori di default */
    cout &lt;&lt; endl;
    cout &lt;&lt; "Valori di default" &lt;&lt; endl;
    cout &lt;&lt; "  width:     "  &lt;&lt; cout.width()        &lt;&lt; endl;
    cout &lt;&lt; "  precision: "  &lt;&lt; cout.precision()    &lt;&lt; endl; 	
    cout &lt;&lt; "  fill:      '" &lt;&lt; cout.fill()  &lt;&lt; "'" &lt;&lt; endl;	
    cout &lt;&lt; "  output:    "  &lt;&lt; d                   &lt;&lt; endl;

    /** Modifica il formato e mostra il nuovo output */
    cout &lt;&lt; endl;
    cout &lt;&lt; "Modifica formato" &lt;&lt; endl;
    cout &lt;&lt; "  output:    "  ;
    cout.precision(4) ;
    cout.fill('#') ;
    cout.width(10) ;
    cout &lt;&lt; d &lt;&lt; endl;
    
    /** Mostra la persistenza dei valori */
    cout &lt;&lt; endl;
    cout &lt;&lt; "Valori correnti" &lt;&lt; endl;
    cout &lt;&lt; "  width:     "  &lt;&lt; cout.width()        &lt;&lt; endl;
    cout &lt;&lt; "  precision: "  &lt;&lt; cout.precision()    &lt;&lt; endl; 	
    cout &lt;&lt; "  fill:      '" &lt;&lt; cout.fill()  &lt;&lt; "'" &lt;&lt; endl;	
    cout &lt;&lt; "  output:    "  &lt;&lt; d                   &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, ottieni:</p>

<pre><code>&gt; src/out/esempio                                 

Valori di default
  precision: 6
  fill:      ' '
  width:     0
  output:    123.457

Valori modificati
  output:    #####123.5

Valori correnti
  precision: 4
  fill:      '#'
  width:     0
  output:    123.5
</code></pre>

<!--


5.8	modifica dei flags di formattazione
Ma la larghezza del campo, la precisione ed il carattere di riempimento non sono le uniche formattazioni modificabili. Un altro modo di modificare le convenzioni di format­tazione standard è quello di alterare la variabile membro x_flags che contiene i flags per la formattazione. 
La dichiarazione della variabile è:

class ios
{
			...
 protected:
			...
			long x_flags ;
			...
Anche la variabile x_flags, come x_state è un membro protected di ios, quindi anche in questo caso non sarà possibile nessuna modifica diretta da parte di funzioni esterne alla classe, ma solo quelle previste e concesse dalle funzio­ni di interfaccia:
long ios::flags() 
long ios::flags(long flags)
long ios::setf(long flags)
long ios::setf(long group, long bits)
long ios::unsetf(long flags)
I flags che vengono utilizzati con queste funzioni sono definiti in un’enumerazione prop­ria della classe ios:

enum    
{
 skipws    	= 0x0001, 
 left      	= 0x0002,
 right     	= 0x0004,
 internal  	= 0x0008,
 dec 		= 0x0010,
 oct 		= 0x0020,
 hex 		= 0x0040,
 showbase  	= 0x0080,
 showpoint 	= 0x0100,
 uppercase 	= 0x0200,
 showpos   	= 0x0400,
 scientific	= 0x0800,
 fixed     	= 0x1000,
 unitbuf   	= 0x2000,
 stdio     	= 0x4000 
};
La tabella seguente mostra il modo in cui riferirsi ai diversi flag nei programmi e le con­seguenze della loro alterazione sul comportamento della classe:
Funzioni di interfaccia per la modifica della variabile x_flags

Le costanti che invece definiscono i campi di bit su cui operare sono:
Costanti per la modifica della variabile x_flags

Vediamo ora in dettaglio il funzionamento delle diverse funzioni:
long ios::flags() 
long ios::flags(long flags)

La prima versione della funzione flags() è innocua: semplicemente ritorna il valore della variabile x_flags; un po’ più di attenzione va rivolta invece all’utilizzo della secon­da versione, che sostituisce la variabile con quella passatale come parametro, ritornando il vecchio valore. Se per esempio voleste modificare solo il flag ios::hex senza andare ad intaccare lo stato degli altri flag di formattazione, dovreste scrivere qualcosa di simile:
FLAGSTST.CPP - Test della funzione ios::flags()

/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	FLAGSTST.CPP - Test della funzione ios::flags()
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
/////////////////////////////////////////////////////////////
void main()
{
 ostream os(2) ;							  // 001
 long flgs = os.flags() ;					  // 002

 os << "flgs  : " << flgs << "\n" ;				  // 003
 os.flags(flgs ^ ios::dec | ios::hex | ios::showbase); // 004
 os << "flgs  : " << flgs << "\n" ;				  // 005
 os << "flags : " << os.flags() << "\n" ;			  // 006

 os.flags(0) ;							  // 007
 os << "flags : " << os.flags() << "\n" ;			  // 008
};
/////////////////////////////////////////////////////////////
001  Invia l’output a stdout.
002  Salva il valore iniziale di x_flags.
003  Visualizza il valore iniziale di x_flags.
004  Esegue un’operazione di XOR esclusivo sulla variabile per annullare il bit di controllo del formato decimale, quindi, con due operazioni di OR inclusivo, setta i nuovi bit di controllo ed infine passa la variabile alla funzione flags.
005  Visualizza il valore iniziale di x_flags con i nuovi settaggi.
006  Visualizza il nuovo valore della variabile x_flags.
007  Reimposta il formato standard dei flags di formattazione.
008  Visualizza il nuovo valore della variabile x_flags.
L’output di questo programma su una macchina MS-DOS è stato:

flgs  : 1
flgs  : 0x1
flags : 0xd1
flags : 0 
long ios::setf(long flags)
long ios::setf(long flags, long mask)
L’utilizzo della funzione setf() è meno problematico di quello della sua collega: la prima versione modifica i bit di formattazione settati ad 1 in flags e ritorna il vecchio valore della variabile; la seconda versione in­vece assegna ai bit di formattazione specificati da mask il valore dei bit corrispondenti in flags, ritornando il vecchio valore della variabile.
long ios::unsetf(long flags)
Questa funzione di formattazione azzera i flag di formattazione settati ad 1 in flags e ritorna il valore precedente della variabile. La caratteristica di setf() (in tutte e due le sue ver­sioni) di impedire il settaggio di flag in opposizione, fa sì che il suo uso non sia partico­larmente frequente.
5.9	manipolatori
Esiste anche un altro modo per modificare la formattazione dell’I/O delle classi stream e consiste nell’utilizzare particolari funzioni membro, dette manipolatori o gestori e defi­nite nel file iomanip.h. 
La differenza fra i manipolatori e le funzioni di gestione della formattazione che abbiamo appena esaminato, è che i manipolatori restituiscono un riferimento allo stream sul quale intervengono, quindi possono essere utilizzati in cascata, esattamente come gli operatori di inserimento ed estrazione. Attenzione, però, perché, anche se la loro sintassi è la stessa degli operatori << e >>, i manipolatori non effettuano nessun tipo di operazione di in­serimento o estrazione, bensì alterano le variabili di formattazione dello stream, modifi­candone il comportamento nel modo descritto nella tabella seguente:
Manipolatori 

Come vedete, esistono sette gestori non parametrizzati e sei che invece prevedono degli argomenti. I primi sono dichiarati nel file header iostream.h e non necessitano quindi di nessun’altra inclusione per poter essere utilizzati. I gestori parametrizzati, invece, hanno una struttura più complessa, dichiarata nel file header iomanip.h che deve essere perciò incluso in qualunque programma ne faccia uso. 
Nel caso vi stiate chiedendo a cosa mai possa servire un altro metodo di formattazione dell’output, eccovi un breve ma significativo esempio sull’utilizzo dei manipolatori:

MANIPTST.CPP - Utilizzo dei manipolatori
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	MANIPTST.CPP - Utilizzo dei manipolatori
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
#include <iomanip.h>						// 001
/////////////////////////////////////////////////////////////
void main()
{
 int num = 29 ;

	cout.fill('#') ;						// 002
	cout.width(8) ;						// 003
	cout << num << "\n";					// 004

	cout << setfill('.') << setw(7) << num ;		// 005
};
/////////////////////////////////////////////////////////////
001  Inclusione necessaria per utilizzare le versioni parametrizzate.
002  Definisce un carattere di riempimento.
003  Definisce una larghezza di output.
004  Visualizza il numero.
005  La stessa cosa, tutta in una linea di codice.
Come vedete, si ritorna sempre al solito discorso di rendere la vita il più facile possibile al programmatore. E per semplificarvela ancora di più (o complicarvela...), potete scriv­ere voi stessi i vostri manipolatori. 
Questa è la dichiarazione di un manipolatore che in­serisce nello standard stream di ouput il carattere ASCII 7:

ostream & beep (ostream & os)
{
	return os << '\a' ; 	//codice di escape per BELL
}
per scoprire a cosa serve, compilate ed eseguite il seguente esempio:

MANIPDU.CPP - Manipolatori definiti dall’utente
/////////////////////////////////////////////////////////////
//
//	Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//	MANIPDU.CPP - Manipolatori definiti dall'utente
//
/////////////////////////////////////////////////////////////
#include <iostream.h>
#include <iomanip.h>						
/////////////////////////////////////////////////////////////
ostream & beep (ostream & os)
{
	return os << '\07' ;
}
/////////////////////////////////////////////////////////////
void main()
{
	cout << "\nCosa succede?" << beep ;			
}
/////////////////////////////////////////////////////////////
Crearsi i propri manipolatori personalizzati può essere piuttosto utile e non è un compito particolarmente complesso se si tengono a mente alcune regole di base (ed a patto che ci si ricordi di includere nel codice il file iomanip.h ):
	i gestori hanno associatività da sinistra a destra, quindi per potere modificare la formattazione di una variabile, debbono precederla nell’istruzione di I/O:

int n = 33 ;
cout << n << hex ;	// ERRORE! non succede nulla
cout << hex << n ;	// OK
	il tipo di ritorno dev’essere un riferimento allo stream su cui si intervi­ene. Se state scrivendo un manipolatore che agisce su oggetti di classi derivate da istream  il tipo di ritorno dev’essere di tipo istream & ;
	il primo argomento dev’essere un riferimento allo stream che si deve manipolare (valgono le stesse considerazioni fatte sopra) ;
	oltre al riferimento allo stream, la funzione può avere solo un altro ar­gomento, che dev’essere obbligatoriamente o un int o un long .
5.10 stream per I/O su file
Come avevamo detto all’inizio del capitolo, le classi derivate da ios non permettono solo la gestione dell I/O standard da tastiera e su terminale, ma consentono di estendere i benefici dell’approccio orientato agli stream anche alla gestione dei files. 
Concettualmente, i files possono essere assimilati a degli stream: un file da cui si leggono dei dati è un caso particolare di stream di input, un file sul quale invece i dati vengono scritti è a tutti gli effetti un caso particolare di stream di output. Allo stesso modo, la classe ifstream, che si occupa dell’input da file è una specializzazione di istream, mentre la classe ofstream, che gestisce invece l’output, è derivata da ostream. Entrambe poi ereditano da fstreambase, una classe diretta discendente di ios, che fornisce metodi comuni per la gestione dei files e che, insieme ad iostream, serve da base per fstream. Quest’ultima è una classe che, com’è facilmente prevedibile, dati i natali, permette tanto operazioni di input che di output su file. 
Detto così è complicato come l’intreccio di una soap opera, ma forse lo schema seguente vi può aiutare un po’:

In quanto derivazioni di istream ed ostream, la maggior parte delle regole che si applicano agli stream di I/O su file sono sostanzialmente le stesse che abbiamo finora esaminato per gli stream di input ed output standard, qualche differenza però c’è. 
La prima è che, per per poter utilizzare queste classi, è necessario includere nel vostro sorgente il file fstream.h, le altre riguardano invece il modo in cui gli stream vengono dichiarati e collegati ai files. I metodi possibili sono (diamo per scontato che i nostri ven­tisei lettori siano abbastanza astuti da capire che quando ci riferiamo ad oggetti fstream intendiamo una qualunque delle tre classi per la gestione dei files):
	dichiarare un oggetto fstream senza parametri: in questo modo otten­tete uno stream privo di connessione a file (la connessione verrà fatta in seguito per mezzo della funzione membro open());

fstream unFile ;	// nessuna connessione con files
	dichiarare un oggetto fstream con un inizializzatore intero: l’intero dev’essere ovviamente una handle ad un file DOS aperto precedente­mente ;

ofstream aVideo(2); // associa lo stream con lo stdout
	dichiarare un oggetto fstream passando come parametri al costruttore una stringa ed una modalità di apertura: la stringa conterrà il nome del file da aprire, le modalità di apertura è un elemento dell’enumerazione ios::open_mode, che esamineremo tra breve.

ifstream is("a.dat", ios::in); // apre a.dat in lettura
In quest’ultimo caso, il secondo parametro passato al costruttore dell’oggetto, ios::in, definisce il modo in cui verrà aperto il file da associare allo stream. I valori possibili, così come sono dichiarati all’interno della classe ios, sono:

enum open_mode  
{
 in         = 0x01, // apre il file in lettura
 out        = 0x02, // apre il file in scrittura
 ate        = 0x04, // apre il file, quindi va alla sua fine
 app        = 0x08, // apre il file in modalità append
 trunc      = 0x10, // azzera il file se già esiste
 nocreate   = 0x20, // apre solo un file già esistente
 noreplace	= 0x40, // non apre un file esistente
 binary     = 0x80  // apre il file in modalità binaria
};
Le modalità ios::in è quella di default per la classe ifstream; ios::out, è il de­fault per ofstream. Per ottenere delle modalità particolari come, ad esempio, l’apertura di un file in input binario o in input ed output di un file che non dev’essere però sovras­critto se già esistente, si possono combinare fra loro i valori di open_mode con delle operazioni di OR logico:
fstream fs( "pippo.dat", ios::in | ios::binary);
fstream fs( "pippo.dat", ios::in | ios::out | ios::nocreate);
L’ultimo costruttore delle classi fstream ha anche un terzo parametro che defiisce la modalità di protezione per il file. La sua dichiarazione è infatti():
ifstream(const char* nome, int mode, int prot=ios::openprot);
Come noterete, però, il parametro prot ha un suo valore di default, ios::openprot, che, almeno per ora, è anche l’unico possibile, quindi potete tranquillamente ignorarlo. 

Orbene, dopo aver tanto parlato, eccovi un esempio che mostra tutti questi nostri nuovi amici all’opera:
FSTRTEST.CPP - Utilizzo delle classi fstream
/////////////////////////////////////////////////////////////
//
//  Dal C a Windows - Carlo Simonelli & Claudio Munisso
//
//  FSTRTEST.CPP - Utilizzo delle classi fstream
//
/////////////////////////////////////////////////////////////
#include "fstream.h"
#include "stdlib.h"
/////////////////////////////////////////////////////////////
void main()
{
 ifstream is ;                                        // 001
 fstream fs("iofile.dat",
            ios::out|ios::trunc|ios::binary ) ;       // 002

    if( ! fs )
	   cerr << "\nErrore in apertura file di output" ;

    is.open("fstrtest.cpp", ios::nocreate ) ;         // 003

    if( ! is )
        cerr << "\nErrore in apertura file di input" ;

    while(is)                                         // 004
    {
	unsigned char c ;
        
        is.get(c) ;                                   // 005
        if( ! is.good() )                             // 006
        {
		      if( is.eof())
			    cerr << "\nRaggiunta la fine del file" ;

			if( is.fail())
                cerr << "\nErrore irrecuperabile" ;

            if( is.bad() )                           // 007
            {
                cerr << "\nOperazione non valida" ;
	           is.clear() ;                         // 008
            }
        }
        else if( ! fs.put(c) )                       // 009
        {
            cerr << "\nErrore in scrittura" ;
            cerr << " posizione " << fs.tellg() ;
        }
}
/////////////////////////////////////////////////////////////
001  Apre un file stream di input senza associarlo a nessun file.
002  Apre un file stream generico in output binario. Se il file già esiste, lo azzera.
003  Associa l’oggetto ifstream con un file preesistente e lo apre.
004  Ripete il ciclo finché non ci sono errori.
005  Legge un carattere dal file di input.
006  Verifica che non ci siano problemi.
007  Se si è verificato un errore lieve...
008  ...resetta la variabile di stato.
009  Copia il carattere nel file di output.

Come spero l’esempio abbia chiarito, le funzioni di controllo, i manipolatori e gli opera­tori di inserimento ed estrazione, si possono applicare agli stream di I/O su file esatta­mente come avveniva per gli oggetti di classe iostream o ostream. 

La funzione open(), utilizzata alla riga 007, è una funzione membro che serve ad aprire un file colle­gandolo con uno stream precedentemente aperto. La sua dichiarazione, che ricorda molto quella del costruttore della classe fstream, è la seguente:
void open(char const*, int, int = filebuf::openprot) ;

L’altra funzione membro utilizzata nell’esempio è tellg(), che fstream eredita in secondo grado della classe istream. Ritorna la posizione della prossima operazione di estrazione () e la sua dichiarazione è:
long tellg() ;

5.11 POsizionamento negli stream di i/o su file
Simile alla funzione membro tellg(), è la funzione tellp(), che  fstream eredita da sua "nonna" ostream e che ritorna la posizione della prossima operazione di inseri­mento. Complementari a tellg() e tellp() sono, rispettivamente, seekg() e seekp(), che posizionano nel file ad una posizione relativa o assoluta. La tabella seguente riporta le dichiarazioni delle diverse funzioni:
Funzioni di posizionamento su stream

Le funzioni seekg(long pos) e seekp(long pos), posizionano la prossima op­erazione sullo stream all’indirizzo assoluto pos. 
Le versioni seekg(long pos,seek_dir) e seekg(long pos, seek_dir), spostano ad una posizione che è a pos bytes dal punto definito dal secondo argomento della funzione, che è un membro dell’enumerazione  seek_dir, definita, tanto per cambiare, all’interno della classe ios:

enum seek_dir 
{ 
	beg=0, 
	cur=1, 
	end=2 
};
L’effetto dei diversi parametri è il seguente:
	ios::beg: sposta la prossima operazione a pos bytes dall’inizio del file associato;
	ios::cur: si sposta a pos bytes dalla posizione corrente;
	ios::end: si sposta a pos bytes prima della fine del file.

-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/polimorfismo" 
           title="Vai a: Il polimorfismo" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/debug" 
           title="Vai a: Il debug" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
