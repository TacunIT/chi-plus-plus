<!DOCTYPE html>
<html lang="it-IT">

<head>
    <title>Espressioni e operatori | C'hi++</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="http://localhost:4000/man/espressioni-e-operatori" />
    <meta     name="thumbnail"       content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Espressioni e operatori" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source"" />
    <meta property="og:image"        content="http://localhost:4000/assets/img/chi-plus-plus.png" />
    <meta property="og:image:width"  content="300" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <script src="https://use.fontawesome.com/b4b35c88c8.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Simonetta:400,400i,900,900i&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/screen.css" media="screen">        
    <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    
    <a href="tipi-di-dato" 
       title="Vai a: tipi-di-dato" 
       class="left">
        <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    
    <a href="funzioni" 
       title="Vai a: funzioni" 
       class="right" >
            <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
    
</nav>
</header>

        <main class="bozza">
            
        

            

            <h1>
                Espressioni e operatori
            </h1>

            <blockquote class="motto">question = 2b | ( ! 2b );</blockquote>

            <section id="testo">

                <!--
@todo: Riprendere i concetti visti nel Manfesto a proposito delle
ideologie dell'ultimo cinquantennio quando si parla di vero e falso
-->

<p>## operatori</p>

<h3 id="operatore-di-negazione">operatore di negazione</h3>

<p>[la negazione e il paradosso come metodo per comprendere ciò che non è
di per sé evidente]</p>

<h3 id="operatori-logici">operatori logici</h3>

<p>È impossibile definire in maniera assoluta i concetti di <em>vero</em> e di
<em>falso</em>.</p>

<p>Possiamo definire “falso” il contrario di “vero”, ma non potendo
definire il concetto di “vero”, non possiamo sapere cosa sia il suo
contrario.</p>

<p>La ragione per cui non possiamo definire il concetto di “vero” è che
farlo implica una ricorsione: quale che sia la definizione prescelta,
prima di poterla prendere per buona dovremo poterla considerare vera, ma
ciò è impossibile perché non sappiamo (ancora) cosa sia, effettivamente,
“vero”.</p>

<p>Tutto ciò non vuol dire che non esistano il vero e il falso, ma solo che
i nostri strumenti dialettici sono inadeguati a descriverli.</p>

<p>I computer sono più fortunati: nel loro mondo, il vero e il falso sono</p>

<h2 id="istruzioni-condizionali">Istruzioni condizionali</h2>

<p>Le istruzioni condizionali sono la parte più importante del codice.</p>

<p>Ogni programma deve saper reagire correttamente al variare delle
condizioni di utilizzo; per far ciò, si utilizzano le istruzioni
condizionali.</p>

<p>Le istruzioni condizionali permettono di definire il comportamento del
sistema a seconda che una determinata condizione si riveli vera o falsa.</p>

<p>Ci sono due istruzioni condizionali: le sequenze <em>if-else</em> e
l'istruzione <em>switch</em>.</p>

<h3 id="istruzioni-if-else">Istruzioni <em>if-else</em></h3>

<p>La forma generale di questa istruzione è la seguente:</p>

<p>if ( <em>condizione</em> )</p>

<p>{</p>

<p>// istruzioni da eseguire se la condizione è vera</p>

<p>}</p>

<p>else</p>

<p>{</p>

<p>// istruzioni da eseguire se la condizione è falsa</p>

<p>}</p>

<p>Se l’espressione condizionale all'inizio del codice è vera (nell'unica
accezione di <em>vero</em> che un programma può comprendere, ovvero, se ha un
valore diverso da zero), il programma eseguirà il primo blocco di
istruzioni; se no, eseguirà il secondo blocco di istruzioni.</p>

<p>Se la condizione "falso" non richiede alcuna azione specifica, il
secondo blocco di istruzioni può essere omesso:</p>

<p>if ( <em>condizione</em> )</p>

<p>{</p>

<p>// istruzioni da eseguire se la condizione è vera</p>

<p>}</p>

<p>Similmente, le parentesi graffe possono essere omesse se il blocco
istruzioni che racchiudono è costituito da una singola istruzione:</p>

<p>if ( <em>condizione</em> )</p>

<p>valore = 1;</p>

<p>else</p>

<blockquote>
  <p>valore = 0;</p>
</blockquote>

<p>D'altro canto, se le condizioni da valutare sono più di due, si possono
concatenare più istruzioni condizionali utilizzando l'istruzione <em>else
if</em>, che permette di definire una condizione alternativa alla prima e di
associarle un blocco di codice.</p>

<blockquote>
  <p>if ( <em>condizione 1</em> )</p>
</blockquote>

<p>{</p>

<p>// <em>istruzioni per caso 1</em></p>

<p>}</p>

<p>else if ( <em>condizione 2</em> )</p>

<p>{</p>

<p>// <em>istruzioni per caso 2</em></p>

<p>}</p>

<p>else if ( <em>condizione 3</em> )</p>

<p>{</p>

<p>// <em>istruzioni per caso 3</em></p>

<p>}</p>

<p>Anche in questo caso, si può chiudere la sequenza con un'istruzione
<em>else</em>, definendo un blocco di istruzioni da eseguire se non si verifica
nessuna delle condizioni previste.</p>

<blockquote>
  <p>if ( <em>condizione 1</em> )</p>
</blockquote>

<p>{</p>

<p>// <em>istruzioni per caso 1</em></p>

<p>}</p>

<p>else if ( <em>condizione 2</em> )</p>

<p>{</p>

<p>// <em>istruzioni per caso 2</em></p>

<p>}</p>

<p>else if ( <em>condizione 3</em> )</p>

<p>{</p>

<p>// <em>istruzioni per caso 3</em></p>

<p>}</p>

<p>else</p>

<p>{</p>

<p>// <em>istruzioni per tutti gli altri casi</em></p>

<p>}</p>

<p>Il programma esamina queste istruzioni in sequenza e, se ne trova una
vera, esegue il codice associato.</p>

<p>Le istruzioni <em>if-else</em> influenzano la leggibilità del codice; è una
cosa di cui il buon programmatore deve sempre tenere conto.</p>

<p>Il C++ è un linguaggio indipendente dalla formattazione, quindi, una
stessa istruzione può essere scritta in molte maniere diverse:</p>

<p>if ( <em>condizione</em> )</p>

<p>{</p>

<p>...</p>

<p>}</p>

<p>else</p>

<p>{</p>

<p>...</p>

<p>}</p>

<p>o, pure:</p>

<p>if ( <em>condizione</em> ) {</p>

<p>...</p>

<p>} else {</p>

<p>...</p>

<p>}</p>

<p>o perfino:</p>

<p>if ( <em>condizione</em> ) { ...} else { ... }</p>

<p>Se le istruzioni sono poche e semplici, una forma vale l'altra (fatte
salve le questioni di stile, ovviamente), ma se il flusso del programma
prevede, come di solito avviene, delle condizioni annidate, è necessario
fare in modo che la forma dell'istruzione semplifichi tanto la
scrittura che la lettura che un'eventuale correzione del codice.</p>

<p>Immagina un brano di codice che debba fare una verifica all'inizio
dell'elaborazione e, a seconda dell'esito, eseguire una sequenza di
istruzioni o inviare un messaggio di errore:</p>

<blockquote>
  <p>if ( <em>condizione</em> )</p>
</blockquote>

<p>{</p>

<p>// codice da eseguire in caso</p>

<p>// la condizione sia vera</p>

<p>}</p>

<p>else</p>

<p>{</p>

<p>// messaggio di errore</p>

<p>}</p>

<p>Se le istruzioni da eseguire in caso di buon successo della verifica
sono poche e semplici, questa sequenza non darà problemi, ma se, al
contrario, le istruzioni fossero tante e complesse, leggendo il codice
potresti arrivare all'istruzione <em>else</em> e non ricordarti più a quale
condizione fosse associata.</p>

<p>Per questo motivo, è preferibile la forma:</p>

<blockquote>
  <p>if ( <em>errore</em> )</p>
</blockquote>

<p>{</p>

<p>// messaggio di errore</p>

<p>}</p>

<p>else</p>

<p>{</p>

<p>// codice da eseguire in caso</p>

<p>// tutto vada bene</p>

<p>}</p>

<p>Dato che la gestione dell'errore non richiederà mai più di qualche riga
di codice, a colpo d'occhio potrai capire tutto il flusso del
programma, indipendentemente dalla lunghezza del secondo blocco di
istruzioni.</p>

<p>Questo, ovviamente, non vuole essere né un invito né una giustificazione
per la scrittura di istruzioni complesse.</p>

<p>A meno che non sia necessario evitare le chiamate a funzione per
garantire un'alta velocità di esecuzione, è sempre meglio scomporre il
flusso del programma in una serie di funzioni distinte.</p>

<p>Questo renderà il programma un po' più lento (o, meglio: un po' meno
veloce), ma renderà il codice molto più facile da leggere e da
modificare o correggere.</p>

<p>Immagina adesso un brano di codice che richieda molte condizioni *if
*concatenate:</p>

<blockquote>
  <p>esito = 0;</p>
</blockquote>

<blockquote>
  <p>if ( <em>condizione 1</em> )</p>
</blockquote>

<blockquote>
  <p>{</p>
</blockquote>

<p>esito = 1</p>

<blockquote>
  <p>}</p>
</blockquote>

<blockquote>
  <p>else if ( <em>condizione 2</em> )</p>
</blockquote>

<p>{</p>

<p>esito = 2</p>

<p>}</p>

<p>else if ( <em>condizione 3</em> )</p>

<p>{</p>

<p>esito = 3</p>

<p>}</p>

<p>else</p>

<p>{</p>

<p>esito = 9</p>

<p>}</p>

<p>return esito</p>

<p>Questa forma, per quanto corretta e canonicamente ineccepibile, potrebbe
rivelarsi difficile da gestire se le condizioni da considerare fossero
molto complesse o numerose.</p>

<p>Il buon programmatore, allora, può decidere di contravvenire alla
(giusta) norma che prescrive di non inserire delle istruzioni <em>return</em>
all'interno del codice, e scrivere la sequenza in questo modo:</p>

<blockquote>
  <p>esito = 0;</p>
</blockquote>

<blockquote>
  <p>if ( <em>condizione 1</em> )</p>
</blockquote>

<blockquote>
  <p>{</p>
</blockquote>

<p>return 1</p>

<blockquote>
  <p>}</p>
</blockquote>

<blockquote>
  <p>if ( <em>condizione 2</em> )</p>
</blockquote>

<p>{</p>

<p>return 2</p>

<p>}</p>

<p>if ( <em>condizione 3</em> )</p>

<p>{</p>

<p>return 3</p>

<p>}</p>

<p>...</p>

<p>return 9</p>

<p>Non ti sto dicendo che sia giusto scrivere così e vedi da solo che il
codice è rozzo e inelegante, ma ci potrebbero essere dei casi in cui sia
questa, la forma più efficiente.</p>

<p>Per esempio, per un sistema che generi del codice in maniera automatica,
è molto più semplice gestire delle istruzioni <em>if</em> isolate che delle
condizioni <em>if-else</em> concatenate.</p>

<p>Pensa a una <em>stored-procedure</em> che debba controllare l'integrità
referenziale dei parametri ricevuti:</p>

<blockquote>
  <p>CREATE FUNCTION utente_insert (</p>
</blockquote>

<blockquote>
  <p>_id_classe INTEGER</p>
</blockquote>

<blockquote>
  <p>, _id_gruppo INTEGER</p>
</blockquote>

<blockquote>
  <p>, _username VARCHAR(255)</p>
</blockquote>

<blockquote>
  <p>, _cognome VARCHAR(80)</p>
</blockquote>

<blockquote>
  <p>, _nome VARCHAR(80)</p>
</blockquote>

<blockquote>
  <p>)</p>
</blockquote>

<blockquote>
  <p>RETURNS INTEGER DETERMINISTIC</p>
</blockquote>

<blockquote>
  <p>BEGIN</p>
</blockquote>

<blockquote>
  <p>DECLARE _id INTEGER DEFAULT -1;</p>
</blockquote>

<blockquote>
  <p>DECLARE _count INTEGER DEFAULT 0;</p>
</blockquote>

<blockquote>
  <p>SELECT count(*) INTO _count FROM classe WHERE (id = _id_classe);</p>
</blockquote>

<blockquote>
  <p>IF _count = 0 THEN</p>
</blockquote>

<blockquote>
  <p>RETURN -2;</p>
</blockquote>

<blockquote>
  <p>END IF;</p>
</blockquote>

<blockquote>
  <p>SELECT count(*) INTO _count FROM gruppo WHERE (id = _id_gruppo);</p>
</blockquote>

<blockquote>
  <p>IF _count = 0 THEN</p>
</blockquote>

<blockquote>
  <p>RETURN -3;</p>
</blockquote>

<blockquote>
  <p>END IF;</p>
</blockquote>

<blockquote>
  <p>IF (_username IS NULL) OR (_username = '') THEN</p>
</blockquote>

<blockquote>
  <p>RETURN -4;</p>
</blockquote>

<blockquote>
  <p>END IF;</p>
</blockquote>

<blockquote>
  <p>IF (_cognome IS NULL) OR (_cognome = '') THEN</p>
</blockquote>

<blockquote>
  <p>RETURN -5;</p>
</blockquote>

<blockquote>
  <p>END IF;</p>
</blockquote>

<blockquote>
  <p>IF (_nome IS NULL) OR (_nome = '') THEN</p>
</blockquote>

<blockquote>
  <p>RETURN -6;</p>
</blockquote>

<blockquote>
  <p>END IF;</p>
</blockquote>

<blockquote>
  <p>...</p>
</blockquote>

<p>Se scrivi il codice in questa maniera, puoi inserire o rimuovere un
parametro (e i relativi controlli) senza alterare il resto del codice,
cosa che non avverrebbe se tu concatenassi le istruzioni <em>if</em>.</p>

<p>Attento, però: mettere in sequenza delle semplici istruzioni <em>if</em> è cosa
ben diversa dal creare una catena di istruzioni <em>else-if</em> .</p>

<p>[specificare la differenza e la necessità del return per bloccare i
controlli; chiudere con l'aneddoto del Maestro Canaro e il sacerdote
buddista]</p>

<h2 id="cicli">cicli</h2>

<h3 id="ciclo-for">ciclo for</h3>

<h3 id="ciclo-while">ciclo while</h3>

<h3 id="ciclo-do-while">ciclo do-while</h3>

<p>###</p>


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="tipi-di-dato" 
           title="Vai a: tipi-di-dato" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="funzioni" 
           title="Vai a: funzioni" 
           class="right" >
            <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
        
        
    </nav>

</footer>


    </div>

  </body>

</html>
