<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="it-IT" xml:lang="it-IT">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>C'hi++</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/assets/css/pdf.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <main>
<header id="title-block-header">
<h1 class="title">C'hi++</h1>
</header>
<div class="page copertina">
<a href="Javascript:void(0);" class="left inattivo" title="Vai a: "><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/dedica" class="right" title="Vai a: Dedica"><em></em></a>
<div class="corpo pubblicato" role="main">
<p><img src="/assets/img/chi-plus-plus.png" title="C&#39;hi plus plus" class="logo" alt="C&#39;hi++" /></p>
<section id="section" class="box titoli">
<h1></h1>
<h2 id="il-senso-della-vita-è-il-debug">Il senso della Vita è il debug</h2>
</section>
</div>
</div>
<div class="page dedica">
<a href="/man/" class="left" title="Vai a: Copertina"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/indice" class="right" title="Vai a: Indice"><em></em></a>
<div class="corpo pubblicato" role="main">
<p>Questo libro è dedicato ai miei nipoti.<br />
I tre che vivono in Francia e i tre miliardi che vivono anche altrove.</p>
</div>
</div>
<div class="page indice">
<a href="/man/dedica" class="left" title="Vai a: Dedica"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/prologo.html" class="right" title="Vai a: Prologo"><em></em></a>
<section id="indice" class="corpo pubblicato" role="main">
<h1>Indice</h1>
<section class="indice">
<h3 id="prologo"><a href="/man/prologo.html">Prologo</a></h3>
<h3 id="incipit"><a href="/man/incipit">Incipit</a></h3>
<h3 id="mitopoietica-del-chi"><a href="/man/mitopoietica">Mitopoietica del C'hi++</a></h3>
<h3 id="il-buon-programmatore"><a href="/man/programmatore">Il buon programmatore</a></h3>
<h3 id="i-sistemi-di-numerazione"><a href="/man/sistemi-di-numerazione">I sistemi di numerazione</a></h3>
<h3 id="i-linguaggi-di-programmazione"><a href="/man/linguaggi-di-programmazione">I linguaggi di programmazione</a></h3>
<h3 id="il-c"><a href="/man/c-plus-plus">Il C++</a></h3>
<h3 id="i-commenti"><a href="/man/commenti">I commenti</a></h3>
<h3 id="i-tipi-di-dato"><a href="/man/tipi-di-dato">I tipi di dato</a></h3>
<h3 id="struttura-dei-programmi-c"><a href="/man/struttura-dei-programmi">Struttura dei programmi C++</a></h3>
<h3 id="gli-operatori"><a href="/man/operatori">Gli operatori</a></h3>
<h3 id="il-preprocessore"><a href="/man/preprocessore">Il preprocessore</a></h3>
<h3 id="la-memoria"><a href="/man/memoria">La memoria</a></h3>
<h3 id="le-funzioni"><a href="/man/funzioni">Le funzioni</a></h3>
<h3 id="istruzioni-condizionali"><a href="/man/istruzioni-condizionali">Istruzioni condizionali</a></h3>
<h3 id="istruzioni-iterative"><a href="/man/istruzioni-iterative">Istruzioni iterative</a></h3>
<h3 id="classi-e-oggetti"><a href="/man/classi-oggetti">Classi e oggetti</a></h3>
<h3 id="lereditarietà"><a href="/man/ereditarieta">L'ereditarietà</a></h3>
<h3 id="il-polimorfismo"><a href="/man/polimorfismo">Il polimorfismo</a></h3>
<h3 id="gli-stream"><a href="/man/stream">Gli stream</a></h3>
<h3 id="il-debug"><a href="/man/debug">Il debug</a></h3>
<h3 id="epilogo"><a href="/man/epilogo">Epilogo</a></h3>
<h3 id="ringraziamenti"><a href="/man/ringraziamenti">Ringraziamenti</a></h3>
<h3 id="note"><a href="/man/note">Note</a></h3>
</section>
</section>
</div>
<div class="page capitolo">
<a href="/man/indice" class="left" title="Vai a: Indice"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/incipit" class="right" title="Vai a: Incipit"><em></em></a>
<section id="prologo-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Prologo</a></h1>
<blockquote>
In principio era il login
</blockquote>
<section class="testo">
<p>Nacqui da famiglia ricca, ma troppo tardi.<br />
Secondogenito, vidi la florida impresa paterna andare in dote — per diritto di nascita, ma anche per naturale inclinazione — ai miei monozigotici fratelli maggiori e, com’è consuetudine per i figli cadetti, fui avviato alla vita monastica. Entrai in seminario all’età di nove anni e presi i voti il giorno del mio diciottesimo compleanno. Conobbi il Maestro quattro anni dopo.<br />
Fui mandato da lui perché un vecchio programma, dopo quasi un decennio di attività ininterrotta, aveva avuto dei problemi e non c’era nessuno nel monastero che sapesse come porvi rimedio. Pur avendo trascorso in quello stesso edificio due terzi della mia vita, non avevo mai incontrato il Maestro, prima di allora. Sapevo poco di lui, principalmente che non era bene saperne molto e non l’avevo mai visto né nel refettorio, né in occasione di celebrazioni o emergenze. Era, per tutti noi giovani, una sorta di figura mitologica, maligna o benigna a seconda dei racconti che su di lei si ascoltavano.<br />
Bussai alla sua porta con cautela, quasi mi aspettassi terribili rappresaglie per quell’indebita intromissione nella sua vita e con altrettanta cautela accettai il suo invito a entrare. L’arredamento delle nostre stanze era semplice ed essenziale, ma in confronto a quello della cella del Maestro, appariva sfarzoso. Non c’erano finestre alle pareti e le uniche due fonti di luce erano una piccola lampada e lo schermo di quello che sembrava un vecchio computer risalente alla fine del XX secolo. In un angolo c’era un curioso divano-letto, simile alle panchine dei parchi, che doveva essere il suo giaciglio per la notte; al lato opposto della stanza, una sorta di libreria realizzata con mattoni e assi di legno grezzo sorreggeva i suoi pochi effetti personali. Nulla copriva la pietra del pavimento.</p>
<p>«Il mio programma sta dando degli errori.»<br />
Risposi di sì, anche se la sua era stata un’affermazione. Il Maestro annuì.<br />
«Era stato istruito a farlo. Adesso lo mettiamo a posto.»<br />
Cominciò a battere sulla tastiera del suo computer e io mi avvicinai incuriosito. Quando arrivai a vedere l’immagine proiettata dallo schermo capii perché nessuno all’interno del convento sapesse intervenire sul suo programma.<br />
«Sì, è C++,» disse il Maestro, intuendo la mia curiosità. «Un tempo si pensava che fosse il linguaggio del futuro. Come di tutti i linguaggi, del resto.»<br />
Chiesi cosa volesse dire che il programma era stato istruito a dare errori.<br />
«Questa è una domanda sciocca. D’altro canto, il fatto che stessi dicendo la verità è evidente, visto che non ti ho nemmeno chiesto che genere di difetto fosse stato rilevato. Bene, puoi andare a dire al tuo superiore che il vecchio pazzo ha corretto l’errore.»<br />
Non riuscivo a distogliere lo sguardo dallo schermo, ero come ipnotizzato da quello strano codice che potevo capire solo in parte. In quelle sequenze di istruzioni c’era qualcosa che non avevo mai visto prima: un ritmo, una sorta di indefinibile bellezza di cui mi ero innamorato a prima vista.<br />
Chiesi al Maestro di insegnarmi il C++.<br />
«E perché mai? ci sono linguaggi molto più facili da usare.»<br />
Gli spiegai che non si trattava di un interesse tecnologico, ma estetico. Lui restò in silenzio per qualche secondo, considerando quello che avevo detto, poi chiese:<br />
«Qual’è il dovere di un programmatore?»<br />
Lo pregai di definire meglio la sua domanda.<br />
«Torna qui domani; se mi saprai dire qual’è il dovere di un programmatore, ti insegnerò il C++.»</p>
<p>Passai tutta la notte a meditare su quella strana domanda e la mattina dopo mi presentai al Maestro. Dissi che il dovere di un programmatore era quello di scrivere del buon codice. Il Maestro non distolse nemmeno lo sguardo dallo schermo e disse:<br />
«Torna qui domani; se mi saprai dire cosa vuol dire scrivere del buon codice, io ti insegnerò il C++.»</p>
<p>Com’è facile intuire, anche il giorno dopo e per diversi giorni a seguire il Maestro trovò il modo di rimandare l’inizio del mio tirocinio con domande ancora più specifiche che andavano a colpire anche la più lieve lacunosità delle mie risposte. Analizzai ogni possibile aspetto della produzione del software, dall’utilizzo delle risorse di sistema alle implicazioni sociali dell’incremento dell’occupazione che deriva dall’evoluzione dei programmi, ma non ci fu nulla da fare: ogni volta il Maestro riuscì a trovare una scappatoia per venire meno al suo impegno.<br />
Alla fine non ne potei più. Esasperato, dissi che ne avevo abbastanza di quella sua ostinata capziosità: per quanto io potessi essere specifico nelle mie risposte, ci sarebbe sempre stato un margine di indeterminazione. Se voleva insegnarmi il C++ doveva iniziare quel giorno stesso.<br />
Il Maestro mi fissò e, sorridendo, spense il computer.<br />
«No, per oggi basta. Vieni domani per la seconda lezione.»</p>
<p>Negli ultimi mesi la salute del Maestro è peggiorata e così gli ho chiesto il permesso di trascrivere i suoi insegnamenti per poterli trasmettere a mia volta ad altri discepoli.<br />
Con mia grande sorpresa, ha accettato.</p>
</section>
</section>
<a href="/man/indice" class="left" title="Vai a: Indice"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/incipit" class="right" title="Vai a: Incipit"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/prologo.html" class="left" title="Vai a: Prologo"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/mitopoietica" class="right" title="Vai a: Mitopoietica del C&#39;hi++"><em></em></a>
<section id="incipit-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Incipit</a></h1>
<blockquote>
*.* è il migliore
</blockquote>
<section class="testo">
<p>Quello che stai facendo è inutile.<br />
Voglio che tu lo scriva all’inizio del tuo libro, così la gente non perderà tempo a leggerlo. Tutto ciò che si fa con uno scòpo è inutile. In particolare i libri, perché sono stupidi: non si accorgono di quando sbagliano e anche se se ne accorgessero non ci potrebbero fare nulla: seguiterebbero a dire una cosa sbagliata.</p>
<p>Tu pensi di scrivere una nuova Bibbia: anche fosse, sei sicuro di volerlo fare? Tutti i libri sacri partono da un presupposto sbagliato: che valga la pena scriverli, perché l’Umanità può essere salvata e, soprattutto, che merita di essere salvata. Non è così. Credi che se gli autori della Bibbia o dei Vangeli avessero potuto prevedere le conseguenze ultime delle loro opere — le guerre, le morti, le sofferenze —, li avrebbero scritti lo stesso? I libri sacri sono sempre stati strumentalizzati dai potenti, cosa ti fa pensare che per il tuo non succederà lo stesso?</p>
<p>Il Maestro Musashi, nel suo <em>Dokkodo</em>, scrisse:</p>
<blockquote>
<p>Fà che le future generazioni non siano legate ad armi antiche.</p>
</blockquote>
<p>Tu proietti su questo linguaggio ormai morto delle aspettative personali, speri che possa far rivivere il tempo passato e ti illudi che il tempo passato sia meglio di quello presente. Ti sbagli. Il passato, mio giovane amico, è una vecchia amante che col suono della sua voce ci ricorda i piaceri vissuti insieme, ma che bada a restare alle nostre spalle per nasconderci il suo volto rugoso.</p>
<p>Io ti insegnerò il Chi++, non ti indicherò la Via. Quando qualcuno ti indica la Via, ricordati sempre che una via la si può percorrere in due direzioni: una direzione ci avvicina alla nostra méta; una direzione ce ne allontana.<br />
La direzione è importante, non la via. Se un uomo conosce la direzione, la via non ha più alcuna importanza.</p>
<p>Le nuvole che oscuravano il cielo questa mattina sono scomparse, il cielo della notte trabocca di stelle. Sono cose che si notano, a mano a mano che si invecchia. Io le noto da quando ero bambino.</p>
<p>Quello che ti insegnerò non è illegale, ma è come se lo fosse.</p>
<p>Il C’hi++ è allo stesso tempo un linguaggio di programmazione, un atteggiamento mentale e un modo di vivere. Chi pratica il C’hi++ scrive codice come se stesse vivendo e vive come se stesse scrivendo del codice.<br />
Vivere è come scendere in canoa lungo un fiume. Affannarsi a risalire la corrente è inutile e infruttuoso, perché il fiume è più forte di noi e non si stanca mai. Lasciarsi andare alla corrente è pericoloso, perché ci si potrebbe parare davanti un ostacolo e noi non avremmo modo di evitarlo. È necessario quindi remare solo quel tanto che ci permette di essere più veloci della corrente e di schivare gli ostacoli che, di volta in volta, si presentano sul nostro cammino.<br />
Similmente, scrivere del buon codice significa scrivere solo il codice necessario a raggiungere lo scòpo che ci si è prefissi. Aggiungere una sola virgola in più è sbagliato, perché rende più difficile il debug e più lento il programma. Chi pratica il C’hi++ applica lo stesso principio alla sua vita e compie solo le azioni necessarie, ignorando tutto ciò che è superfluo. Capire quali sono le azioni necessarie è semplice, così com’è semplice capire qual è la direzione della corrente quando navighi su un fiume. La cosa difficile è capire di essere su un fiume.</p>
<p>Tutte le cosmogonie che sono state formulate nel corso dei secoli hanno una caratteristica comune: richiedono una certa dose di fede in qualcosa di cui non è possibile provare l’esistenza; uno o più elementi fittizi e sovra-naturali, che si introducono nel sistema per spiegare ciò che non è possibile dimostrare praticamente. Credere in queste entità richiede un’abiura più o meno marcata delle nostre capacità cognitive e, spesso, l’accettazione di condizioni più paradossali di quelle che si cercava di spiegare originariamente. Ma, come diceva sempre il Maestro Canaro: “la Verità è semplice”. Qualunque spiegazione che richieda dei parametri correttivi, è inesatta. Una volta, poco prima di morire, il Maestro Canaro mi disse che, utilizzando i costrutti tipici del C’hi++, si poteva scrivere la dimostrazione dell’ultimo teorema di Fermat su una bustina di fiammiferi.</p>
<p><em>C’hi</em>, in giapponese, vuol dire “respiro”. L’Universo è scritto in C’hi++. L’Universo respira. Ciò che noi percepiamo come eternità altro non è che un singolo respiro dell’Universo, una delle innumerevoli eternità che si sono succedute dall’inizio dei tempi. Ogni respiro dell’Universo comporta una fase di espansione e una fase di contrazione. I punti terminali di ciascuna fase prevedono l’annichilimento di ogni forma di vita senziente. Al contrario, nei periodi intermedi nascono e muoiono innumerevoli mondi. Su ciascuno di questi innumerevoli mondi nascono e muoiono innumerevoli esseri Ciascuno di questi innumerevoli esseri, nel corso della sua vita, compie una serie di azioni che influenzano la sua esistenza e quella dei suoi simili. Le possibili permutazioni di queste innumerevoli azioni per questi innumerevoli esseri per questi innumerevoli mondi sono quasi illimitate.<br />
Quasi.</p>
<p>Il tempo, al contrario, è illimitato, quindi può capitare che una determinata sequenza di eventi, già avvenuta in un precedente respiro dell’Universo, si ripeta, con condizioni simili, in un respiro successivo. Ciò vuol dire che, con buone probabilità, io e te abbiamo già avuto questa conversazione in una o in migliaia delle nostre esistenze precedenti.</p>
<p>Ciò che le religioni non dicono è che non si può andare in Paradiso da soli: o ci andiamo tutti, o non ci va nessuno.</p>
</section>
</section>
<a href="/man/prologo.html" class="left" title="Vai a: Prologo"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/mitopoietica" class="right" title="Vai a: Mitopoietica del C&#39;hi++"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/incipit" class="left" title="Vai a: Incipit"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/programmatore" class="right" title="Vai a: Il buon programmatore"><em></em></a>
<section id="mitopoietica-del-chi-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Mitopoietica del C'hi++</a></h1>
<blockquote>
Il settimo giorno, Dio fece il backup
</blockquote>
<section class="testo">
<p>Su di me ci sono due teorie: qualcuno pensa che io sia impazzito cercando di fare il <em>debug</em> dell’Universo, altri pensano invece che io abbia deciso di fare il <em>debug</em> dell’Universo perché sono pazzo.</p>
<p>Anche il Maestro Canaro fu accusato di essere pazzo quando disse di essere stato incaricato da Dio di fare il <em>porting</em> dell’Universo dal COBOL al C++, ma non era pazzo. Ho conservato questi documenti: sono l’ultima pagina del suo diario e le relazioni che furono inviate alla società per cui lui lavorava mentre era distaccato dal “Cliente”. Mettili all’inizio del tuo libro, così tutto ciò che diremo dopo non sarà che una ripetizione.</p>
<blockquote>
<h3 id="ultima-pagina-del-diario-del-maestro-canaro-8-aprile">Ultima pagina del diario del Maestro Canaro (8 Aprile)</h3>
<p>Sono in ufficio e sto lavorando quando squilla il telefono. La voce che mi risponde è piuttosto bassa e ha un'eco curiosa. Mi fa:<br />
- Canaro, sono Dio, ho bisogno di te.<br />
- Marco, ho da fare, ci sentiamo dopo.<br />
Riattacco. Un attimo dopo il telefono squilla di nuovo. Stavolta faccio caso al tipo di squillo e deduco che si tratta di una telefonata esterna.<br />
- Canaro, non sono il tuo collega, sono davvero Dio. Devi aiutarmi a fare il porting dell'universo in C++.<br />
Non posso fare a meno di sorridere.<br />
- Carina. E anche il sintetizzatore vocale mi sembra che funzioni piuttosto bene. Senti, finisco questa relazione e ti offro un caffè, ma adesso lasciami lavorare.<br />
Riattacco di nuovo e di nuovo il malefico oggetto fa sentire la sua voce. È un'esterna, non posso rischiare: potrebbe essere un cliente, ma so già che..<br />
- Canaro, ascoltami una buona volta: sono davvero Dio e ho bisogno che tu mi risolva un problema.<br />
Sto per dirgli qualcosa di cui poi mi pentirò, ma la voce continua:<br />
- Se non mi credi, stacca la spina del telefono.<br />
- Ma per favore..<br />
- Staccala!<br />
Più per curiosità che altro, vado a vedere il suo bluff. Stacco la spina.<br />
- Adesso mi credi?<br />
Devo dire che per un attimo il mio scetticismo vacilla. Cerco una possibile spiegazione.<br />
- Hai messo una ricevente nella cornetta.<br />
- Testardo eh? Va bene: scegli un oggetto a caso.<br />
- Per fare cosa?<br />
- Per utilizzarlo come cornetta, uno che il tuo collega non possa aver manomesso.<br />
- Marco, per favore..<br />
- Avanti, cosa ti costa? Visto che sei così sicuro..<br />
- La mia pipa va bene?<br />
- Quello che vuoi: avvicinala all'orecchio.<br />
Vediamo dove vuole andare a parare: tiro fuori la mia pipa dall'astuccio di pelle e avvicino il fornello all'orecchio.<br />
- Fatto, - dico e intanto mi guardo intorno in attesa dello scherzo.<br />
- Lo so, - la voce è nel fornello di radica. - Adesso, se per favore potessimo riprendere la nostra conversazione telefonica.. Non vorrei che entrasse qualcuno e ti vedesse parlare con una pipa.<br />
<br />
- Premetto che io di queste cose di computer non ci capisco niente, -  mi dice appena ho riattaccato la spina del telefono.<br />
- Mio figlio, invece, i computer li sa usare e mi ha detto che sarebbe meglio fare il porting dell'universo in un linguaggio a oggetti, suggerendomi questo C++. Ora, vedi, io vado forte in scienze naturali, non in informatica, e tutti questi termini tecnici, per me, sono misteriosi: cosa vuol dire fare il porting di qualcosa? e cosa sono i linguaggi orientati agli oggetti?<br />
“Bella domanda”, pensai. Anni prima avevo scritto un manuale di C++ e il paradigma a oggetti era l'argomento del primo capitolo. Se solo lo avesse letto..<br />
- Ho anche dato una scorsa al tuo libro, ma non ci ho capito niente: scrivi di schifo, lasciatelo dire. E poi, mi sono detto, chissà quante cose sono cambiate nel frattempo, così ho deciso di chiamarti.<br />
- Innanzitutto la ringrazio per i complimenti, poi, per venire alla sua domanda, fare il porting di qualcosa vuol dire riscrivere un'applicazione con un linguaggio di programmazione differente da quello in cui era stata scritta inizialmente.<br />
- E questo a quale scopo?<br />
- Di solito per sfruttare le potenzialità del nuovo linguaggio o per poter utilizzare l'applicazione in un sistema per cui il vecchio linguaggio non sia valido.<br />
- Come tradurre i dieci comandamenti dall'Ebraico al Latino?<br />
- Qualcosa di simile.<br />
- E questo "C++"? Cosa vuol dire "linguaggio orientato agli oggetti"?<br />
- Che invece di tipi di dato astratti come numeri e caratteri, permette di utilizzare dei tipi di dato simili a quelli reali.<br />
- Non ho capito.<br />
- I vecchi linguaggi di programmazione costringevano il programmatore a utilizzare solo dei tipi di dato predefiniti: numeri, lettere, date. Questo va bene per un certo tipo di applicazioni, ma rende difficile scrivere applicazioni più complesse dove può essere utile sfruttare un linguaggio che sia capace di gestire anche dei nuovi tipi di dato, definiti dall'utente. In C++, il linguaggio che suo figlio le ha consigliato, questo si ottiene per mezzo delle classi.<br />
- Come in zoologia?<br />
- Una specie. Per classe si intende un tipo di dato non standard, del quale si può definire il comportamento.<br />
- Fammi un esempio, che non capisco. E poi basta con questo lei, passiamo al "tu", che è più semplice.<br />
- Mettiamo che tu abbia due stringhe..<br />
- Non porto scarpe con le stringhe, uso i sandali Birkenstock.<br />
- Intendevo delle sequenze di caratteri. Ora, per come un computer gestisce i dati normalmente, non ha senso addizionare due stringhe, dato che non si tratta di un tipo di dato numerico, ma si può definire una classe "Stringa" che, se sottoposta ad addizione, faccia qualcosa di sensato.<br />
- Del tipo?<br />
- Poniamo che tu abbia una stringa A qualsiasi.<br />
- "Pippo" va bene?<br />
- Originale. E che tu voglia unirla ad un'altra stringa B.<br />
- "Pluto".<br />
- Anche questa bella originale. Comunque, tu scriverai l'istruzione: C = A + B e nella stringa C ci sarà scritto: "PippoPluto".<br />
- Lo terrò a mente la prima volta che mi capiterà di dover scrivere: "PippoPluto".<br />
- Era un esempio.<br />
- Seguito a non capire perché si chiamino "linguaggi orientati agli oggetti".<br />
- Perché non gestiscono dati grezzi, ma oggetti con un loro comportamento ben definito.<br />
- Devo vederlo in pratica. Comunque, quali sarebbero i vantaggi di questa traduzione?<br />
- Nel caso del C++, una maggior facilità di analisi.<br />
- Ma l'analisi dell'applicazione già c'è.<br />
- E una maggiore facilità di debug.<br />
- Prego?<br />
- Di correzione degli errori.<br />
- L'applicazione attuale è in funzione da un'eternità e non ha mai dato nessun problema.<br />
- Aumenta anche le possibilità di riutilizzare il codice in altre applicazioni.<br />
- Questo mi sembra utile quanto la stringa "PippoPluto".<br />
- Il processo produttivo ha una certificazione di qualità?<br />
- Io ho visto che era buono: direi che può bastare.<br />
- Be', allora non vedo che necessità ci sia di riscriverla.<br />
- Esattamente quello che ho detto a mio figlio, ma lui ha cominciato a parlare di questo C++ e di quell'altro, quello col nome di un'isola, come si chiama..<br />
- Java? Non si riferisce a un'isola, ma a un tipo di miscela per il caffé.<br />
- Quello che sia. Il discorso è: che bisogno c'è di riscrivere tutto?<br />
- Per quello che ne posso capire, direi nessuno..<br />
- Bene, ti ringrazio.<br />
Attacca (o quello che è), ma dopo un po' richiama.<br />
- Canaro, ho parlato con mio figlio e lui dice che sono un retrogrado, che l'applicazione attuale è obsoleta, che gli utenti si lamentano e che questo porting è necessario. Io non ci capisco più niente, cosa devo fare?<br />
Sto per rispondere "Lo sa Iddio", ma fortunatamente mi trattengo e ricorro alla risposta standard in questi casi:<br />
- Potremmo fare uno studio di fattibilità e poi decidere..<br />
- Mi sembra una buona idea. Quando puoi cominciare?<br />
- Non lo so, devo chiederlo al mio responsabile.<br />
- D'accordo: chiediglielo e poi fammi sapere.<br />
Riattacca senza dirmi come potrò "farglielo sapere", ma questo è l'ultimo dei miei problemi. Il primo, al momento, è in che modo raccontare questa cosa al mio capo senza farmi prendere per pazzo.<br />
<br />
- Se speri di rimediare un periodo di convalescenza per esaurimento nervoso, scordatelo. Hai detto (e soprattutto fatto) cose molto più strane.<br />
- Lo so che è pazzesco, ma è vero: Dio mi ha telefonato e mi ha chiesto di riscrivere l'Universo in C++.<br />
- Canaro, piantala e vai a finire l'analisi, che la dobbiamo portare al cliente nel pomeriggio.<br />
- E se mi richiama, cosa gli devo dire?<br />
- Raccontagli di quanto hai sbagliato le stime dell'ultimo progetto, così si rivolgerà a un altro.<br />
Scornato, me ne torno al mio loculo dove mi preparo in anticipo la seconda pipa della giornata. Mentre armeggio con il tabacco, il telefono squilla per l'ennesima volta, ma non è chi mi aspetto che sia, bensì il mio capo che mi richiama nel suo ufficio. "Chiamata di re, tanto buona non è..", penso, ma quando arrivo nella ben nota stanza dall'inequivocabile odore di sigaro toscano, mi trovo di fronte un uomo d'umore molto diverso da quello che mi ha allontanato poco prima. La voce è pacata, i modi gentili e mostra la massima comprensione e disponibilità nei miei confronti.<br />
- Passa le cose che stai seguendo a Igino e Paolo e dedicati completamente allo studio di fattibilità per il porting dell'Universo. Stupito per il repentino voltafaccia, chiedo la prima cosa che mi passa per la testa.<br />
- Su quale commessa devo scaricare le ore?<br />
- Ancora non lo so, ma non te ne preoccupare. Oh, se ti serve un portatile puoi prendere il mio.<br />
- Va bene, grazie. C'è nient'altro?<br />
- Tieni, - mi porge un foglietto con qualcosa scritto sopra. - ha detto che puoi richiamarlo a questo numero.<br />
Rientro nel mio ufficio, chiudo la porta e compongo il numero: una voce registrata mi avvisa che l'utente è al momento occupato, ma che è stato inviato l'avviso di chiamata. Non passa un attimo che sento la Sua voce dire:<br />
- Sì, pronto?<br />
- Scusami, io ti ho richiamato subito, ma se sei al telefono..<br />
- Non ti preoccupare, stavamo chiudendo. Allora?<br />
- Sono a tua disposizione, ma prima di iniziare c'è una cosa che devo dirti.<br />
- Vuoi sapere come ho fatto a convincere il tuo capo? È stato facile, gli ho detto che a prendere le cose sul serio e ad arrabbiarsi ci si accorcia la vita.<br />
- Questo credo che lo sapesse già..<br />
- Probabile, ma io gli ho detto di quanto.<br />
- Tu sai quando morirà?<br />
- Teoricamente sì, ma chi se lo ricorda.. Ho sparato una data a caso entro la fine dell'anno. Gli ho detto anche che questa era la sua ultima possibilità per far sì che quel doloretto che ha sentito al torace stamattina appena sveglio fosse solo un doloretto. È bastato.<br />
- Almeno così sembra. Comunque non è questo che volevo chiederti.<br />
- Oh! Tu probabilmente vuoi sapere perché ho scelto proprio te, avendo a disposizione i migliori.<br />
- Io avrei detto "fra i migliori", ma comunque..<br />
- Te lo dirò se farai un buon lavoro. Noi ci vediamo domani mattina all'indirizzo che ti ha dato il tuo capo. Cerca di essere puntuale e non passare dal centro perché ci sarà una fila per un tamponamento.<br />
- Me ne ricorderò.</p>
<h3 id="prima-relazione-sullandamento-del-progetto-u-19-aprile">Prima relazione sull'andamento del progetto "U++" (19 Aprile)</h3>
<p>Le cose vanno meglio di quello che sperassi: malgrado i suoi impegni, il Cliente trova sempre del tempo da dedicarmi e il mio lavoro procede spedito. Inoltre, a dispetto di una malcelata ritrosia iniziale, credo che finalmente si sia convinto dell'utilità di una revisione del codice e adesso è Lui stesso, e non più il Figlio, a spingere per una rapida conclusione. Due sono state finora le scoperte di maggior rilievo: la prima è che l'applicazione attuale è scritta in COBOL (il Cliente mi ha spiegato che l'ipotesi iniziale di utilizzare il FORTRAN era stata abbandonata dopo un primo tentativo e che in quel linguaggio è stato scritto solo il cervello degli ingegneri); la seconda è che Mandelbrot aveva ragione: l'Universo ha una struttura frattale (scelta, questa, che semplifica di molto la gestione di situazioni complesse tipo l'interazione fra gli agenti atmosferici, il rumore dei pedalò e gli incontri casuali con ex amanti nei grandi magazzini). Una mia proposta che ha incontrato l'approvazione del Cliente è di procedere per gradi, stendendo un'analisi generale completa, ma riscrivendo l'applicazione poco per volta, in modo da produrre il minimo disturbo possibile agli utenti e semplificando il lavoro di affinamento delle procedure. Ho scritto una relazione preliminare (che allego) e l'ho consegnata al Cliente: domani mi farà avere una sua opinione al riguardo.</p>
<h3 id="seconda-relazione-sul-progetto-u-20-aprile">Seconda relazione sul progetto "U++" (20 Aprile)</h3>
<p>Nella mattinata odierna ho discusso la mia relazione preliminare con il Cliente, che nel complesso mi è sembrato soddisfatto dell'impostazione prescelta. Dopo qualche tentennamento, si è anche convinto che non è possibile fare dei paragoni fra i tempi di sviluppo dell'applicazione precedente e di quella nuova, sia per l'impossibilità di paragonare analisi strutturata e analisi orientata agli oggetti, sia per la difficoltà di comparare la misurazione attuale, in giorni/uomo, con quella precedente, in giorni/Dio. Al momento ho solo una preoccupazione, ovvero che qualcuno, da dietro le quinte, piloti gli umori del Cliente con fini non chiari. Dico ciò, perché tutti i dubbi e le perplessità da lui espresse finora sono largamente al disopra delle sue conoscenze tecniche. Se inizialmente pensavo che dietro a tutto questo ci fosse quel Figlio di cui ho già fatto menzione nella memoria inviatavi prima della mia partenza (il che mi avrebbe posto in una situazione oltremodo delicata in quanto, come tutti ben sappiamo, la mia stessa presenza qui è dovuta proprio ad un suo suggerimento e metterne in discussione la competenza sarebbe controproducente), ora sono ragionevolmente certo che si tratti di qualcun altro, anche se non so proprio né chi possa essere né quali possano essere i suoi scopi.</p>
<h3 id="terza-relazione-sul-progetto-u-28-aprile">Terza relazione sul progetto "U++" (28 Aprile)</h3>
<p>Mi scuso per il prolungato silenzio, ma le riunioni degli ultimi giorni sono state letteralmente massacranti e non ho avuto il tempo di mantenervi aggiornati sui più recenti sviluppi della situazione. Di contro, va detto che finalmente comincio ad avere un'idea un po' più chiara delle diverse esigenze funzionali e dei ruoli coinvolti nel progetto, il che è sicuramente un bene, specie perché il terreno, qui, comincia a scottarmi sotto i piedi. E non faccio per dire. Come certo ricorderete, nella mia precedente comunicazione avevo paventato l'esistenza di ingerenze occulte e, comunque, un dubbio che avevo avuto sin dall'inizio era: dato che il Cliente ha più volte affermato di non possedere grosse cognizioni tecniche in campo informatico, chi ha scritto a suo tempo la prima applicazione? Non certo il Figlio (il quale altro non è che uno smanettone con quattro conoscenze d'accatto mutuate dalle riviste del settore), né tanto meno il terzo membro del consiglio di amministrazione, che è quasi sempre in viaggio. Quindi, chi? Bene: adesso ho una risposta ad entrambi i quesiti e buone ragioni per sospettare che le due figure (quelle del manovratore occulto e dell'autore del codice) coincidano, ma non so se esserne contento o spaventato. Comunque è meglio raccontarvi tutto dall'inizio. Il Cliente decide di realizzare un'applicazione per la gestione dell'Universo (che sarebbe quella attualmente in produzione), così si mette a tavolino, butta giù l'analisi funzionale, aggiunge alcune regole di business (tipo: l'acqua va sempre in basso, di mamma ce n'è una sola, i negri hanno la musica nel sangue e via dicendo), poi passa all'implementazione. Parte con qualcosa di piccolo e di facile, ma il risultato che ottiene non lo soddisfa; inoltre, come molti creativi, non è particolarmente attratto dalla realizzazione pratica di quello che ha elaborato concettualmente, perciò decide di subappaltare il lavoro a terze parti e le crea contestualmente. I nuovi arrivati studiano l'analisi, definiscono il disegno della base dati, stabiliscono alcuni criteri di implementazione (si passa dal FORTRAN al COBOL) e finalmente cominciano a scrivere il codice. L'analisi, va da sé, è estremamente precisa e tutto andrebbe nel migliore dei modi se a un certo punto uno dei programmatori non cominciasse a inserire delle backdoor nel programma. Inizia quasi per scherzo (modifica il codice in modo da garantirsi l'imbattibilità a briscola e il possesso di Viale dei Giardini e Parco della Vittoria a Monopoli), ma poi ci prende gusto e comincia ad aggiungere modifiche sempre più sostanziali, coinvolgendo nell'operazione di inquinamento anche alcuni suoi colleghi. Alla fine, i suoi privilegi sono di poco inferiori a quelli dell'Amministratore del sistema. Reso spavaldo dall'impunità di cui ha goduto fino ad allora, si mette alla testa del suo gruppo di cialtroni e tenta di esautorare il Cliente con un colpo di mano, ma senza successo: il suo piano è subito scoperto e sia lui che i suoi seguaci sono trasferiti per punizione in una sede secondaria, un open space senza aria condizionata, dove d'estate fa un caldo assurdo. Li salva da un destino peggiore (la presenza, nell'ufficio, di colleghe di sesso femminile) una curiosa circostanza: c'è bisogno di loro per la manutenzione del programma. Infatti, anche se la congiura è sventata, i danni al codice rimangono e non c'è né il tempo di ricontrollare tutto né chi, a parte loro, lo passa fare. Si decide perciò di mettere in produzione l'applicazione così com'è e di procedere all'eliminazione delle anomalie a mano a mano che verranno alla luce: una scelta tanto rischiosa quanto necessaria, che porta ben presto ad una situazione paradossale in cui i congiurati diventano il punto di riferimento del Cliente per la correzione degli errori che loro stessi hanno generato e che seguitano a generare (un po' per vendetta, un po' per accrescere il proprio potere contrattuale) sfruttando i privilegi illegali che si sono garantiti. É facile capire con quanta poca gioia questi personaggi abbiano salutato il mio arrivo: anche se apparentemente masochista, la scelta del Cliente di riscrivere tutta l'applicazione si rivela adesso l'unica possibilità rimasta di eliminare il Male dal Creato. Ecco spiegate le ingerenze esterne, ecco spiegato il motivo. Fatemi gli auguri.</p>
<h3 id="quarta-relazione-sul-progetto-u-1-maggio">Quarta relazione sul progetto "U++" (1 Maggio)</h3>
<p>Credete a me: i clienti buoni esistono solo per i commerciali; per i tecnici esistono solo clienti che non hanno (ancora) creato problemi. Ero così eccitato dall'idea di essere lo Strumento Divino che avrebbe eliminato il Male dall'universo ed invece eccomi qui, sprofondato nella più tetra depressione per colpa del Cliente e delle sue assurde fissazioni. Io pensavo, anzi, ero certo che nella nuova versione dell'applicazione la parola d'ordine sarebbe stata "Bene": con quale sorpresa ho scoperto invece che, anche in questa versione, l'esistenza sarà un'altalena fra le colline della moderata contentezza e gli abissi oceanici della malinconia. Stamattina ne ho parlato con il Cliente, ho cercato di farlo ragionare. Addirittura, visto che erano qui e che non avevano niente da fare, mi sono perfino fatto dare una mano da Schopenhauer e Bergson, ma invano. Mi ha risposto, seccato, di fare il mio lavoro e di non impicciarmi di questioni che vanno oltre la mia comprensione (per poi blandirmi perché lo aiutassi con i backup dopo che aveva cancellato per sbaglio due galassie). Nel pomeriggio sono tornato alla carica, convinto com'ero che le cospicue quantità di vin santo ingurgitate nel post-prandiale avessero favorevolmente influito sulla sua disponibilità, ma mi sbagliavo: mi ha ripetuto quanto aveva già detto nella mattina e, in più, mi ha attaccato un pistolotto di sapore vagamente taoista, il cui fine dichiarato era quello di illuminarmi sulla soggettività dei concetti di bene e di male. In un ultimo, disperato tentativo, ho ribattuto che la presenza del Male nel Creato è uno degli argomenti preferiti di coloro che tentano di dimostrare che Dio non esiste, ma è equivalso a darsi la zappa sui piedi: mi ha confessato di essere stato proprio lui a infondere simili pensieri nella mente dei suoi detrattori nella speranza, frustrata, che la gente si trovasse qualcun' altro da bestemmiare. Una volta di più, mi trovo a dover fronteggiare l'<span id="annosa-dicotomia">annosa dicotomia fra ciò che il cliente desidera e quello di cui realmente ha bisogno</span> e, una volta di più, sarà ingrato compito dell'uomo informatico quello di venire apparentemente meno ai propri doveri al fine di produrre qualcosa di consono alle reali esigenze del committente.</p>
<h3 id="fax-del-cliente-19-maggio">Fax del Cliente (19 Maggio)</h3>
<p>La presente per informarvi della nostra decisione di interrompere l'opera di *porting* del nostro sistema gestionale in linguaggio C++; una decisione sofferta, ma irrevocabile, cui siamo giunti avendo constatato che i principali difetti dell'applicazione precedente non avevano trovato una cura in questa nuova versione. Stando così le cose, abbiamo deciso di focalizzare i nostri sforzi piuttosto che su una rischiosa operazione di revisione, su un programma organico di formazione degli utenti, nella speranza che una maggiore consapevolezza delle problematiche di fondo del contesto di utilizzo possa correggere quelle che, a questo punto, consideriamo delle idiosincrasie congenite del sistema. Quale ricompensa dell'impegno da Voi profuso in questo progetto abbiamo pensato di risparmiare l'edificio in cui ha sede la Vostra società dal terremoto del 24 luglio p.v., ma siamo aperti a qualsiasi soluzione di Vostro gradimento, a patto che non contravvenga alle nostre politiche aziendali. Sfortunatamente, il Vostro personale distaccato presso di noi, è rimasto vittima dell'annosa dicotomia fra ciò che gli utenti di un sistema desiderano e ciò di cui realmente hanno bisogno e siamo certi che non avrete nulla in contrario se lo utilizzeremo come cavia per il nostro programma di rieducazione. Attualmente, comunque, gode di ottima salute e sembra non avere difficoltà ad integrarsi con il nuovo gruppo di lavoro cui è stato assegnato, nella sede distaccata del nostro CED.</p>
</blockquote>
<p>Finito il corso di riqualificazione, il maestro Canaro non fu più lo stesso. Tornò alla sua società, ma vi rimase solo il tempo di dare le dimissioni. Fondò il nostro Ordine e cominciò a predicare la mistica della programmazione, ottenendo subito un grosso seguito.<br />
I tempi erano maturi per il cambiamento: c’era stata la crescita prodigiosa di fine millennio e c’era stata la rovinosa caduta dell’11 marzo 2000. La vecchia guardia era stanca di dover dipendere dalle bizze della borsa e del marketing; i giovani volevano la Terra Promessa per cui avevano abbandonato gli studi classici; gli utenti volevano che la posta elettronica funzionasse.<br />
La dottrina del maestro Canaro era semplice: riportare l’informatica in una torre d’avorio, accettarne la componente imponderabile ed elevarla da attività produttiva ad attività mistica. Basta con l’improvvisazione, basta con il <em>time to market</em>, basta con i prodotti inaffidabili: chi voleva scrivere codice doveva entrare in un Ordine monastico e seguire un lungo percorso di iniziazione, prima di poter cominciare a lavorare.<br />
Furono in molti a vedere nel maestro Canaro <em>“il vento che spazzerà via il fango”</em>: la vecchia guardia fu ben felice di veder nuovamente riconosciuto il suo status di casta eletta; i giovani, che cercavano un riparo, lo trovarono all’interno dei monasteri; gli utenti seppero che le loro posta elettronica avrebbe funzionato e furono felici.<br />
Ci fu anche una componente politica, a favorire il successo della dottrina predicata dal maestro Canaro. La società dipendeva ormai totalmente dai computer e i computer dipendevano dagli informatici. Se un giorno avessero deciso di coalizzarsi e di scioperare, avrebbero messo il Paese, se non il Mondo intero, in ginocchio.<br />
Le psicopatologie tipiche degli informatici, la loro incapacità di gestire, se non addirittura di <em>concepire</em> una vita sociale, rendevano questa ipotesi molto poco probabile, ma era comunque un rischio troppo grosso per essere ignorato. Al contrario, l’indottrinamento degli informatici, la loro segregazione in una casta con forti componenti mistico-religiose, li avrebbero tenuti lontani dalle lusinghe dei sindacati e avrebbero reso l’ipotesi di uno sciopero improbabile quanto l’ipotesi di uno sciopero dei sacerdoti.</p>
<hr />
<p>Gli insegnamenti del maestro Canaro non uscirono mai dall’ambito del software. Non nominò mai l’<em>hardware</em>, in nessuno dei suoi scritti; diceva che se un uomo configura un <em>firewall</em> è un informatico, se attacca due cavi è un elettricista. Una volta chiesi al maestro Canaro perché non avesse mai dato delle indicazioni sull’affidabilità fisica dei server.<br />
“Se è per questo,” mi rispose “non nemmeno prodotto tabelle per il calcolo del cemento armato.” Solo anni dopo capii cosa intendesse dire.<br />
Malgrado il suo disinteresse per ciò che lui chiamava: “le cose reali”, la rivoluzione culturale provocata dal maestro Canaro ebbe delle conseguenze anche per i produttori di computer. La maggior parte di loro fu lenta a percepire i cambiamenti in atto e pagò duramente la sua disattenzione, gli altri prosperarono.<br />
Anche se il Maestro Canaro non prese mai una posizione definita nella disputa che contrappose i sostenitori della dottrina del <em>Grande Veicolo</em> (i <em>mainframe</em>) e quelli che erano invece favorevoli al <em>Piccolo Veicolo</em> (i PC casalinghi), alcuni alti prelati si dichiararono favorevoli al monoteismo dei <em>mainframe</em> e, alla fine, i sostenitori del politeismo furono sconfitti.<br />
Negli uffici e nelle case, i PC vennero sostituiti da terminali e gli edifici ebbero tutti, oltre al garage e al locale caldaie, un’area CED. Il territorio fu suddiviso in diocesi, e ciascuna diocesi fu affidata a un diacono che aveva il compito di sovrintendere al corretto funzionamento dei diversi sistemi.<br />
Sebbene noi, che gli eravamo vicini fin dall’inizio della sua predicazione, sapessimo che era il C++ il suo linguaggio di programmazione preferito, il maestro Canaro lasciò che fosse Java a diventare il linguaggio ufficiale della comunità, subendo senza replicare gli attacchi di coloro che lo accusavano di essersi venduto alla Sun. Le procedure esistenti furono tutte riscritte; gli ordini monastici che insegnavano il C++ divennero sempre di meno e alla fine non ce ne furono più.<br />
Fu solo allora che il maestro Canaro mi parlò per la prima volta del <em>C’hi++</em>.</p>
</section>
</section>
<a href="/man/incipit" class="left" title="Vai a: Incipit"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/programmatore" class="right" title="Vai a: Il buon programmatore"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/mitopoietica" class="left" title="Vai a: Mitopoietica del C&#39;hi++"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/sistemi-di-numerazione" class="right" title="Vai a: I sistemi di numerazione"><em></em></a>
<section id="il-buon-programmatore-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Il buon programmatore</a></h1>
<blockquote>
È stata una giornata estenuante: questa mattina ho tolto una virgola dal mio codice e stasera ce l'ho rimessa
</blockquote>
<section class="testo">
<p>Le principali discipline dell’informatica sono: la gestione del personale, la gestione dei progetti, la gestione dei sistemi e la programmazione. Un buon maestro deve essere abile in tutte le discipline, ma può eccellere solo in una di esse, perché per arrivare all’eccellenza dovrà dedicare a quella disciplina tutta la sua vita e nessuno ha più di una vita.<br />
È fondamentale che il maestro conosca e pratichi tutte le discipline, perché solo conoscendo le problematiche connesse a ciascuna fase e a ciascuna disciplina, potrà raggiungere l’eccellenza in una di esse. La disciplina più alta é la programmazione, perché non ha a che fare con entità reali, ma solo con concetti astratti.<br />
Non c’è differenza fra lo scrivere codice e il gestire un’azienda: è come osservare una medesima città su carte di diversa scala. Se il rapporto di scala è basso, si avrà una buona visione di insieme, ma pochi dettagli; se il rapporto di scala è alto, si avranno molti dettagli, ma una visione di insieme limitata. La città, però, sarà sempre la stessa.<br />
Nella <em>Bhagavad Gita</em> si dice:</p>
<blockquote>
<p>Tu hai diritto solo all’azione, mai ai suoi frutti: che il tuo movente non sia il frutto dell’azione, né vi sia in te attaccamento all’inattività.<a href="/man/note/#azione" id="azione" class="nota"></a></p>
</blockquote>
<p>È così che opera il buon programmatore: scrive del buon codice, anche se non beneficerà mai dei suoi effetti. Scrive del buon codice perché non può farne a meno.<br />
Scrivere codice non è un mestiere, è una deformazione mentale. Il <span id="buon-programmatore">buon programmatore</span> è un disadattato che ha la fortuna di essere retribuito per dare sfogo ai lati peggiori della sua personalità. Mentre scrive il codice, la mente del buon programmatore lavora su tre livelli: il primo livello decide la sequenza delle istruzioni necessarie a far funzionare il programma; il secondo livello ne controlla costantemente la correttezza sintattica e semantica; il terzo livello verifica se ci sia un sistema più efficiente per fare la stessa cosa. I buoni programmatori sono paranoici ed è giusto che sia così. Le istruzioni di un programma sono eseguite milioni di volte nel corso della loro vita e anche una probabilità minima di errore è inammissibile. Ricòrdati: il codice funziona come vuoi tu solo se non gli lasci altra scelta.<br />
Nei tempi andati ci fu chi sostenne una teoria bizzarra secondo la quale i programmi, per essere veramente efficaci, sarebbero dovuti essere rapidi, ridondanti e imprecisi. L’idea di fondo era che, essendo impossibile, sopra un certo livello di complessità, produrre del codice privo di errori, sarebbe stato meglio produrre molti programmi mediamente imprecisi e valutare l’insieme dei loro risultati. L’unica cosa che posso dire a loro discolpa è che a quei tempi si pensava alla produzione di codice come a un’attività di tipo industriale e non come a una disciplina mistica.<br />
Anche il buon sistemista è paranoico, ma un buon programmatore difficilmente potrà essere un buon sistemista. Il buon sistemista ricerca la ridondanza, perché la ridondanza aumenta l’affidabilità del sistema. Il buon programmatore rifugge la ridondanza, perché la ridondanza diminuisce l’efficienza del codice. Il programmatore è Mercurio, il sistemista è Vulcano.</p>
<hr />
<p>Un buon programmatore dovrebbe conoscere più di un linguaggio di programmazione. Che si conosca a fondo solo un particolare linguaggio è ammissibile, ma una visione di insieme è sempre necessaria per operare delle scelte. Quelli che al giorno d’oggi si definiscono “programmatori” non sono nient’altro che dei forzati di un determinato linguaggio. Allevati in batteria come i polli, conoscono soltanto quello, lo ritengono il migliore e si interessano degli altri linguaggi solo allo scòpo di evidenziarne le pecche. Questo è improduttivo e pericoloso perché, quando con il passare del tempo, questi “programmatori” diventeranno analisti, gestiranno i progetti e le persone a loro affidate con la stessa miopia, producendo sistemi instabili, costosi e difficili da mantenere. Ciò è immorale.<br />
All’estremo opposto stanno coloro i quali dedicano il loro tempo e le loro energie allo studio dei linguaggi e delle metodologie di progettazione del passato. Sono capaci di citare costrutti in LISP, Ada o Eiffel con grande precisione, ma non hanno mai scritto una riga di codice originale in vita loro. I più abili riescono a modificare i programmi di esempio che trovano nei libri di testo o nei manuali, sostituendo gli algoritmi con altri brani di codice classico, ma senza alcun apporto creativo. Fra questi individui e i veri programmatori c’è la stessa differenza che passa fra un sessuologo e un pornodivo.</p>
<hr />
<p>Una volta chiesi al Maestro Canaro: «Maestro, cosa facevano i paranoici prima che fosse inventata l’informatica?» Il Maestro ci pensò un po’ su, poi rispose: «Ormeggiavano le barche».</p>
</section>
</section>
<a href="/man/mitopoietica" class="left" title="Vai a: Mitopoietica del C&#39;hi++"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/sistemi-di-numerazione" class="right" title="Vai a: I sistemi di numerazione"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/programmatore" class="left" title="Vai a: Il buon programmatore"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/linguaggi-di-programmazione" class="right" title="Vai a: I linguaggi di programmazione"><em></em></a>
<section id="i-sistemi-di-numerazione-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">I sistemi di numerazione</a></h1>
<blockquote>
Ci sono 10 tipi di persone: quelli che capiscono la numerazione binaria e quelli che non la capiscono
</blockquote>
<section class="testo">
<p>Per dissuadere i pochi ostinati che sono arrivati a leggere fin qui, voglio parlarti dei sistemi di numerazione.</p>
<p>Secondo antiche leggende, la razza umana sarebbe il frutto di un esperimento di ingegneria genetica operato da alieni esadattili arrivati sulla Terra trecentomila anni prima di Cristo. Che sia vero o no, immagina di avere intorno a un tavolo uno di questi alieni, uno dei tuoi confratelli e un uomo che abbia solo un dito. Se poggiassi una dozzina di uova sul tavolo e chiedessi a ciascuno di loro di numerarle, cosa otterresti? Il tuo amico, che conta in base alle dieci dita delle sue mani, direbbe che le uova sono pari a una volta tutte le sue dita più due. Se esprimessimo questa risposta con potenze del numero delle dita delle mani del tuo confratello, otterremmo che:</p>
<pre><code>1x101 + 2x100 = 12</code></pre>
<p>L'alieno, abituato a contare in base alle sue dodici dita, direbbe che le uova sono:</p>
<pre><code>1x121 + 0x120 = 10</code></pre>
<p>Il disgraziato con un dito, che può considerare solo le due possibilità: <em>un dito/nessun dito</em>, sarebbe costretto a fare un calcolo più lungo:</p>
<pre><code>1x23 + 1x22 + 1x22 + 0x20 = 1100</code></pre>
<p>Questi tre risultati, per quanto differenti, non sono sbagliati, perché ciascuno dei tre conta le dodici uova in base al numero delle proprie dita e risponde di conseguenza. Le uova rimangono le stesse: cambia solo il sistema di numerazione.<br />
Del resto, è naturale che sia così: i numeri sono solo concetti astratti; simboli che si utilizzano per identificare delle quantità. Potresti sostituire i numeri da 0 a 9 con le prime dieci lettere dell'alfabeto e non cambierebbe nulla:</p>
<table style="margin:1rem auto">
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr class="even">
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>l</td>
</tr>
</tbody>
</table>
<pre><code>a + b = b     
b + c = d   
d * e = bc</code></pre>
<p>Il metodo di calcolo resta lo stesso: quando la quantità da valutare è maggiore del numero delle cifre disponibili, si riporta la differenza a sinistra, nella colonna di ordine superiore. Il valore <em>bc</em> della moltiplicazione, significa infatti:</p>
<pre><code>b*(numero di cifre)1 + 
c*(numero di cifre)0</code></pre>
<p>ovvero, visto che il numero di cifre a nostra disposizione è 10:</p>
<pre><code>b*10 + c*1</code></pre>
<p>Se sostituiamo le lettere con i numeri, otteniamo:</p>
<pre><code>1*10 + 2*1 = 3*4</code></pre>
<p>La numerazione esadecimale fa proprio questo: utilizza le lettere dalla A alla F in aggiunta ai dieci valori della numerazione araba:</p>
<table class="esadecimale">
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
</tr>
</tbody>
</table>
<p>Questo torna molto utile quando hai a che fare con dei byte di otto cifre, come vedremo dopo.</p>
<hr />
<p>Nei sistemi di numerazione <em>posizionali</em> il valore di una cifra dipende dal punto in cui si trova: le cifre a sinistra hanno più valore delle cifre a destra, ma non tutti i sistemi di numerazione funzionano allo stesso modo. Se tu chiedessi a un antico romano di calcolare il numero delle uova, ti risponderebbe:</p>
<pre><code>XII</code></pre>
<p>Anche questo sarebbe un risultato corretto, pur se diverso dai precedenti. Il sistema di numerazione romano è un po' più complicato dei sistemi in base 10, 12 e 2 che abbiamo visto finora. Nella numerazione romana, il valore di una cifra (I, V, X, L, C, D, M) non dipende dalla sua posizione assoluta, ma dalla sua posizione in rapporto alle altre cifre.<br />
Il Maestro Canaro nacque il 29 febbraio 1964; in cifre romane, questa data è:</p>
<pre><code>XXIX II MCMLXIV</code></pre>
<p>ovvero:</p>
<pre><code>10+10+(10-1)
 
1+1

1000+(1000-100)+50+10+(5-1)</code></pre>
<p>I numeri romani possono andar bene per un popolo di conquistatori: sono facili da scolpire nel marmo, a memoria di una battaglia vittoriosa e non considerano lo zero, la nullità, ma per il commercio e per i calcoli in generale sono piuttosto scomodi. Quando gli arabi diffusero nel bacino del Mediterraneo il sistema di numerazione che avevano a loro volta imparato dagli indiani, la sua diffusione fu tanto rapida quanto inevitabile.<br />
I computer, però, non sono né egocentrici come un imperatore romano, né astuti come un mercante fenicio; al contrario, sono veloci, ma tonti: bisogna spiegar loro le cose in maniera semplice, perché le possano portare a termine.<br />
La numerazione romana non fa per loro, perché richiede troppi simboli e troppe regole per essere messa in pratica. La numerazione decimale è già un po' meglio, ma richiede comunque la definizione di dieci simboli diversi, uno per ciascuna cifra da 0 a 9. Paradossalmente, il sistema di calcolo che un calcolatore può capire più facilmente è quello per noi più complicato, ovvero il sistema binario. Questo sistema richiede solo la definizione di due simboli: <em>1</em> e <em>0</em>; due concetti che possono capire facilmente sia un transistor che una scheda perforata.</p>
<hr />
<p>Qualcuno potrebbe dirti che ci sono sistemi di calcolo migliori del binario. Qualcuno, probabilmente uno di quei disgraziati individui che amministrano le basi di dati, potrebbe dirti che il sistema ternario bilanciato funziona molto meglio e semplifica i calcoli. Ciò corrisponde al vero.<br />
La ragione per cui il Maestro Canaro non approvava i sistemi ternarii era filosofica, non tecnica. I due valori del sistema binario possono essere identificati con i valori logici sì/no, vero/falso; ovvero con le due condizioni di esistenza e non esistenza, per esempio, di un buco in una scheda perforata o di una corrente in un circuito. Al contrario, i sistemi con basi superiori a due, richiedono la definizione di un terzo stato che non può essere né sì, né no; né vero, né falso; né esistente, né in-esistente. Questo terzo stato intermedio può essere definito solo per mezzo di una valutazione che non è logica, ma quantitativa. Mettiamo che su una scheda perforata il valore 0 sia associato all'assenza di fori e il valore 1 sia associato alla presenza di un foro; un terzo valore, differente da 0 e da 1, potrebbe essere identificato o da un foro di dimensioni differenti o da una concavità. Quale che sia la soluzione scelta, saremmo costretti a definire un valore in base a una grandezza fisica, ovvero, a basare il calcolo digitale su una misurazione analogica.<br />
Il Maestro Canaro pensava che ciò fosse empio.</p>
<hr />
<p>Un esempio di tutto ciò di cui ti ho parlato oggi lo trovi nella codifica RGB dei colori delle pagine Web. Nella codifica RGB, ciascun colore è definito come una combinazione di rosso verde e blu – i colori <em>Red</em>, <em>Green</em> e <em>Blue</em> le cui iniziali costituiscono l’acronimo del sistema.<br />
La quantità di ciascun colore è determinata da tre valori di 8 bit ciascuno e può quindi variare da 0 a 255 (2<sup>8</sup>).<br />
I possibili colori della codifica RGB possono essere calcolati o moltiplicando fra loro i tre valori di R, G e B:</p>
<pre><code>256 * 256 * 256 = 16.777.216</code></pre>
<p>oppure considerando i tre byte un unico valore binario di 24 cifre:</p>
<pre><code>224 = 16.777.216</code></pre>
<p>Un colore RGB con tutti e tre i suoi byte a zero è nero; uno con tutti i byte di valore 255 è bianco.</p>
<table class="rgb">
<tbody>
<tr class="odd">
<td></td>
<td>RGB(0,0,0)</td>
</tr>
<tr class="even">
<td></td>
<td>RGB(255,255,255)</td>
</tr>
</tbody>
</table>
<p>Fra questi due estremi ci sono le restanti 16.777.214 possibili combinazioni dei tre valori. Se assegnamo un valore solo a uno dei tre byte, otterremo delle gradazioni di rosso, verde o blu:</p>
<table class="rgb">
<tbody>
<tr class="odd">
<td></td>
<td>RGB(234,0,0)</td>
</tr>
<tr class="even">
<td></td>
<td>RGB(0,111,0)</td>
</tr>
<tr class="odd">
<td></td>
<td>RGB(0,0,80)</td>
</tr>
</tbody>
</table>
<p>Se attribuiamo dei valori a tutti e tre i byte, otterremo dei colori composti. Per esempio, il colore di sfondo dei brani di codice o il colore dei link di navigazione:</p>
<table class="rgb">
<tbody>
<tr class="odd">
<td></td>
<td>RGB(232,232,222)</td>
</tr>
<tr class="even">
<td></td>
<td>RGB(85,85,0)</td>
</tr>
</tbody>
</table>
<p>Gli stessi valori possono essere espressi in notazione esadecimale:</p>
<table class="rgb">
<tbody>
<tr class="odd">
<td></td>
<td>000000</td>
</tr>
<tr class="even">
<td></td>
<td>FFFFFF</td>
</tr>
<tr class="odd">
<td></td>
<td>ea0000</td>
</tr>
<tr class="even">
<td></td>
<td>006f00</td>
</tr>
<tr class="odd">
<td></td>
<td>000050</td>
</tr>
<tr class="even">
<td></td>
<td>e8e8de</td>
</tr>
<tr class="odd">
<td></td>
<td>555500</td>
</tr>
</tbody>
</table>
<p>L’unica diffferenza è che la numerazione esadecimale è più facile da utilizzare e da memorizzare, perché ciascuna lettera corrisponde a un byte. Il valore binario e il colore visualizzato, rimangono gli stessi, indipendentemente dal modo in cui tu li vuoi misurare.</p>
<hr />
<p>C’è qualcosa, in tutto questo, sulla quale vorrei che tu soffermassi la tua attenzione: i numeri <em>descrivono</em> un valore, non <em>sono</em> un valore. I valori esistevano da prima che esistessero i numeri e gli sopravviveranno. La quantità di fiammiferi che vedi qui sul mio tavolo, rimane la stessa sia che tu la chiami <em>4</em>, <em>100</em> o <em>IV</em>, così come rimarrebbe la stessa se tu la chiamassi <em>five</em> o <em>cinco</em>.<br />
I numeri li abbiamo inventati noi, i valori, no.</p>
</section>
</section>
<a href="/man/programmatore" class="left" title="Vai a: Il buon programmatore"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/linguaggi-di-programmazione" class="right" title="Vai a: I linguaggi di programmazione"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/sistemi-di-numerazione" class="left" title="Vai a: I sistemi di numerazione"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/c-plus-plus" class="right" title="Vai a: Il C++"><em></em></a>
<section id="i-linguaggi-di-programmazione-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">I linguaggi di programmazione</a></h1>
<blockquote>
Dio non programma in Assembler con l'Universo
</blockquote>
<section class="testo">
<p>Brian Kernigan, disse:</p>
<blockquote>
<p>L’unico modo di apprendere un linguaggio di programmazione è quello di utilizzarlo per scrivere programmi.</p>
</blockquote>
<p>Il maestro Canaro sosteneva che anche scrivere il manuale di un linguaggio di programmazione è un buon sistema per impararlo.</p>
<hr />
<p>I linguaggi di programmazione servono a chiedere al computer di fare determinate operazioni. Perché il computer possa ubbidirci, deve “capire” che tipo di entità deve gestire e che tipo di operazioni deve compiere su di esse. Per esempio, se chiedessimo al computer di raddoppiarci lo stipendio, il computer dovrebbe sapere almeno a quanto ammonta il nostro stipendio e come funziona una moltiplicazione per due.</p>
<pre><code>long raddoppia(long stipendio)
{
    return stipendio * 2;
}</code></pre>
<p>Siccome l’unica cosa che il computer conosce sono delle sequenze di 1 e di 0 – siano esse su un disco, in memoria o sulla porta di comunicazione della tastiera o del video, – dobbiamo trovare il modo di “spiegargli” i concetti di <em>stipendio</em> e <em>moltiplicazione</em> in forma binaria. I linguaggi di programmazione fanno precisamente questo: traducono le nostre richieste in un linguaggio che il computer può comprendere.</p>
<hr />
<p>Il linguaggi di programmazione possono essere di <em>alto livello</em> o di <em>basso livello</em>. I linguaggi di alto livello, come il <em>C</em> o il <em>C++</em> hanno dei costrutti simili al linguaggio naturale e non sono legati a una determinata architettura hardware. I linguaggi di basso livello, come l’<em>assembly</em> hanno dei costrutti simili al codice nativo della macchina e sono, per questo motivo, legati a una specifica architettura hardware.<br />
La funzione <em>raddoppia</em>, che abbiamo visto prima, tradotta in linguaggio <em>assembly</em>, diventa:</p>
<pre><code>raddoppia(long):
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     rax, QWORD PTR [rbp-8]
        add     rax, rax
        pop     rbp
        ret</code></pre>
<p>I programmi scritti con linguaggi di alto livello, come vedi, sono più facili da scrivere e da correggere, ma sono più lenti da esegure perché il codice deve essere “tradotto” in una forma comprensibile alla CPU. I programmi scritti con linguaggi di basso livello sono più complessi da scrivere o da correggere, ma sono molto più veloci da eseguire perché contengono solo le istruzioni strettamente necessarie a svolgere il compito desiderato.</p>
<hr />
<p>Un computer è come una nave. L’hardware è in basso, come la sala macchine e la CPU è il capo-smacchinista: non vede il mare, non vede il cielo, non sa nemmeno se la nave stia andando a Nord oppure a Sud; riceve le sue istruzioni dall’interfono e si interessa solo solo della velocità e dei consumi. Il sistema operativo è l’equipaggio: è in una posizione intermedia, né in basso né in alto e si prende cura della nave e del carico; può parlare con il Comandante e con il capo macchinista, ma non parla mai con gli armatori. L’interfaccia utente, invece, è il ponte di comando: è il punto più alto della nave, da cui si può vedere tutto; è in contatto diretto con gli armatori, da cui riceve delle direttive su ciò che deve o non deve fare e con l’equipaggio, che lo informa sullo stato della nave.<br />
Ciascun livello del computer ha il suo linguaggio. La CPU di questo computer “ragiona” in quello che si chiama: <em>linguaggio macchina</em>, ovvero una lunga serie di valori decimali che indicano sia le operazioni da compiere che le grandezze coinvolte. Il sistema operativo è scritto in C, perché è il linguaggio che si adatta meglio a gestire un computer. L’interfaccia utente, infine, sfrutta dei linguaggi a oggetti come il C++ per creare gli elementi grafici che le consentono di interagire con l’utente.<br />
I linguaggi e i costrutti che si applicano a un livello non funzionano, se si applicano agli altri livelli, perché ciascun livello concepisce e gestisce gli elementi di un programma in maniera diversa. L’interfaccia utente conosce molte caratteristiche del programmatore: vede il suo viso nella Webcam, ascolta la sua voce nel microfono, talvolta legge le sue impronte digitali sullo scanner. Il sistema operativo non lo può vedere o sentire, ma conosce i suoi dati anagrafici e sa tutto quello che lui scrive ai suoi amici. La CPU non sa nulla di lui: gestisce i suoi dati, ma non sa cosa siano. Può elaborare la sequenza di byte:</p>
<pre><code>01000011 
01100001 
01101110 
01100001 
01110010 
01101111</code></pre>
<p>ma non sa che è il nome: <em>Canaro</em>. In effetti, non sa nemmeno cosa sia, la parola: <em>nome</em>. Per lui è solo la sequenza di byte:</p>
<pre><code>01001110 
01101111 
01101101 
01100101</code></pre>
<p>Invertendo questi concetti, una volta il Maestro Canaro disse:</p>
<blockquote>
<p>L’Uomo non può dire se Dio sia buono o meno, perché non si può classificare l’essenza del Creatore con gli attributi del creato. Sarebbe come se i byte di un computer si chiedessero se il Programmatore valga 1 o 0.</p>
</blockquote>
<hr />
<p>Noi percepiamo il mondo reale come un insieme di eventi che coinvolgono una o più entità. Ciascuna entità è identificabile per le sue caratteristiche fisiche e ha un suo modo particolare di reagire agli stimoli esterni. Per descrivere le entità, i linguaggi di programmazione hanno i <a href="/man/tipi-di-dato">tipi di dato</a>; per descrivere gli eventi, hanno <a href="/man/espressioni-e-operatori">istruzioni e operatori</a>. Un linguaggio di programmazione è tanto più efficace quanto più i suoi tipi di dato e i suoi costrutti sintattici riescono a rappresentare le entità che il programma dovrà gestire.<br />
Ci sono molti linguaggi di programmazione. Ciascun linguaggio sa spiegare bene certe cose e meno bene certe altre. Esistono linguaggi che descrivono bene le transazioni bancarie, ma che sono inadatti a gestire il treffico aereo; altri che funzionano molto bene per creare pagine Web, ma con cui sarebbe masochistico scrivere un sistema operativo. Un programmatore che conosce a fondo un certo linguaggio di programmazione può utilizzarlo efficacemente per scrivere qualsiasi programma, ma a quale prezzo? Se il linguaggio di programmazione è inadatto a descrivere gli eventi che interesseranno il programma, il programmatore dovrà preoccuparsi di piegare o gli eventi o il linguaggio o entrambi per ottenere il risultato atteso. Scegliendo invece un linguaggio i cui tipi di dato e i cui costrutti siano più affini alla realtà da descrivere, si risparmiano tempo e fatica e si scrive un codice più affidabile.<br />
I linguaggi di programmazione possono essere di due tipi: <em>interpretati</em> o <em>compilati</em>. Posso spiegarti la differenza in questo modo: immagina di essere in Cina e di dover tornare al tuo albergo in taxi. Se non parli il Cinese, ha due possibilità: o porti con te un interprete che spieghi al tassista dove devi andare o ti fai dare dall’albergo un foglio di carta con l’indirizzo e lo fai vedere al guidatore del taxi. Entrambe le possibilità hanno lati positivi e negativi. Se scegli di portarti dietro un interprete avrai dei costi in più, ma sarai libero di andare dove vuoi: in albergo, in un ristorante o in un locale notturno. Se invece opti per il foglio con l’indirizzo risparmierai i soldi dell’interprete, ma, una volta salito in taxi, potrai solo tornare all’albergo.<br />
Con i linguaggi di programmazioni avviene la stessa cosa. Il codice dei linguaggi interpretati viene letto da un programma chiamato: <em>interprete</em> che prima traduce le istruzioni nel linguaggio del computer e poi le esegue. Il codice dei linguaggi compilati, al contrario, viene letto da un programma chiamato <em>compilatore</em>, che lo converte in istruzioni comprensibili dal computer, scrive queste istruzioni in un nuovo file, detto: <em>object-file</em> e lo passa a un altro programma, chiamato <em>linker</em>, che lo trasforma in un file <em>eseguibile</em>.<br />
Anche in questo caso, ciascun metodo ha lati positivi e lati negativi.<br />
I linguaggi interpretati sono più lenti, perché il passaggio lettura/conversione/esecuzione si ripete ogni volta che il codice viene elaborato; inoltre, richiedono delle risorse di sistema in più da destinare all’interprete. In compenso, ogni modifica al codice sorgente viene trasmessa immediatamente anche al programma in esecuzione. I linguaggi compilati sono più rapidi e richiedono meno risorse di sistema perché la compilazione avviene solo una volta, dopo di che il programma può essere eseguito autonomamente, ma se si modifica il codice sorgente, il programma dovrà essere ri-compilato per funzionare correttamente.<br />
Anche la religione è, da un certo punto di vista, un linguaggio di programmazione, perché consente agli umani di dialogare con Dio. Il codice, in questo caso, è la preghiera, che i fedeli formulano e inviamo alla Divinità nella speranza che la esegua. Anche le religioni, come i linguaggi di programmazione, possono essere o compilate o interpretate, a seconda che la comunicazione fra il fedele e Dio sia diretta o mediata da un Ordine sacerdotale.</p>
<hr />
<p>Tutti i linguaggi hanno una sintassi, tutti i linguaggi hanno dei tipi di dato; pochissimi linguaggi hanno anche dei principii. I principii sono importanti, perché danno robustezza al linguaggio. Il linguaggio C, da cui è derivato il C++, non ha principii: è solo un modo per descrivere gli eventi all’interno di un computer.<br />
L’istruzione:</p>
<pre><code>char b = 23;</code></pre>
<p>è un modo per dire al computer:</p>
<ol>
<li>trova un’area di memoria libera larga 1 byte;</li>
<li>assegna l’indirizzo di quell’area alla variabile <em>b</em>;</li>
<li>inserisci nell’area di memoria il valore <em>23</em>.</li>
</ol>
<p>Immagina che tu sia il C. Il muro della cucina è la memoria del computer e ciascuna mattonella è un <em>bit</em>. Le prime diciassette mattonelle sono occupate, ma dalla diciottesima alla venticinquesima ci sono otto mattonelle libere, così tu prendi un pennarello e, senza farti vedere dal cuoco, scrivi nelle otto mattonelle libere il corrispondente binario del numero 23:</p>
<table class="memoria">
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>La variabile <em>b</em>, a questo punto, avrà un <em>indirizzo</em>, ovvero il numero della prima mattonella in cui hai scritto (18) e un <em>valore</em>, ovvero il numero binario contenuto nelle otto mattonelle (23).<br />
Se l’istruzione successiva fosse:</p>
<pre><code>char c = b * 2;</code></pre>
<p>tutto quello che dovresti fare è di cercare un’altra serie di otto mattonelle libere in cui scrivere il valore della variabile <em>b</em> spostato verso sinistra di una mattonella:</p>
<table class="memoria">
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ti vedo perplesso, ma ragiona: la moltiplicazione per due, in binario, è l’equivalente della moltiplicazione per dieci nella numerazione decimale. Se devi moltiplicare un numero decimale per la base del sistema di numerazione — che è dieci, appunto —, lo sposti a sinistra di un posto e aggiungi uno zero a destra:</p>
<pre><code>    1234 * 10 = 12340</code></pre>
<p>Se devi moltiplicare un valore binario per la base del sistema, che in questo caso è due, fai la stessa cosa:</p>
<pre><code>00010111 * 00000010 = 00101110</code></pre>
<p>Il valore <code>00101110</code> equivale a 46, che è il doppio di 23.</p>
<hr />
<p>Il C è un linguaggio estremamente efficiente per gestire tutte le entità che puoi trovare in un computer – numeri, stringhe, flussi di dati –, ma la sua forza è allo stesso tempo il suo limite, perché non funziona altrettanto bene se hai a che fare con oggetti più complessi. Anche la gestione delle stringhe di testo, nel C, è rudimentale: se tu provassi a eseguire la somma di cui parla il Maestro Canaro nel suo diario:</p>
<pre><code>#include &lt;stdio.h&gt;

int main (int argc, char** argv)
{
    char* a = &quot;pippo&quot;;
    char* b = &quot;pluto&quot;;
    printf(&quot;\npippo+pluto=%s\n&quot;, a+b);
    return 0;
}
</code></pre>
<p>il compilatore C ti avviserebbe che non può sommare due variabili di tipo char.</p>
<pre><code>% gcc linguaggi-programmazione-pippopluto.c -o ../out/esempio; 
6.1-pippopluto.c:7:35: 
error: invalid operands to binary expression 
(&#39;char *&#39; and &#39;char *&#39;)
    printf(&quot;\npippo+pluto=%s\n&quot;, a+b);
                                 ~^~
1 error generated.</code></pre>
<p>Il C è un linguaggio che non va oltre l’ambito per cui è stato creato. È una convenzione. Se domani smettessimo di utilizzare i computer, il C non esisterebbe più, perché tutti i suoi costrutti sono legati al funzionamento degli apparati informatici. Al contrario, il C++ e tutti i linguaggi che si basano sul paradigma a oggetti hanno una componente filosofica che trascende l’ambito informatico. Se domani smettessimo di utilizzare i computer, i costrutti che il C++ ha ereditato dal C non avrebbero più senso, ma i concetti di <a href="/man/classi">classe</a> e di <a href="/man/oggetti">oggetto</a> resterebbero ancora validi.<br />
Molti pensano che avere dei principii sia limitativo, ma non è vero. Il C non ha principi e i suoi costrutti sono limitati ai tipi di dato previsti. Il C++, grazie ai suoi principii, ha una maggior duttilità e può evolversi, adattando i suoi costrutti a qualsiasi contesto.</p>
<hr />
<p>Il Maestro Canaro pensava che la Scienza fosse come il C: uno strumento perfetto per descrivere ciò che ci circonda, ma inadatto a descrivere ciò che trascende la nostra conoscenza diretta. Il problema, secondo lui, era la matematica. Parasfrasando Karl Kraus, diceva che la matematica è una malattia di cui pensa di essere la cura. Non so se conosci la frase di André Weil: «Dio esiste perché la matematica è coerente; il Diavolo esiste perché non possiamo dimostrarlo.» È vero il contrario. I paradossi sono la crittografia di Dio e la matematica è utile non perché quasi sempre è coerente, ma perché, di quando in quando, produce dei paradossi.</p>
</section>
</section>
<a href="/man/sistemi-di-numerazione" class="left" title="Vai a: I sistemi di numerazione"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/c-plus-plus" class="right" title="Vai a: Il C++"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/linguaggi-di-programmazione" class="left" title="Vai a: I linguaggi di programmazione"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/commenti" class="right" title="Vai a: I commenti"><em></em></a>
<section id="il-c-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Il C++</a></h1>
<blockquote>
Non chiederti cosa può fare per te il sistema operativo; chiediti invece cosa puoi fare tu, per il sistema operativo
</blockquote>
<section class="testo">
<p>In uno dei suoi libri, Bjarne Stroustroup definì il C++:</p>
<blockquote>
<p>Un linguaggio di programmazione per svolgere compiti non banali.</p>
</blockquote>
<p>Fà che si possa dire la stessa cosa di te.</p>
<hr />
<p>C++ è un linguaggio di programmazione creato da Bjarne Stroustrup nel 1983, quando lavorava ai Laboratori Bell della AT&amp;T. Dieci anni prima, il suo collega Dennis Ritchie aveva creato un linguaggio di programmazione chiamato <em>C</em>. Il C, come ti ho detto, era estremamente efficace se dovevi programmare i computer, ma — così come alcuni dei tuoi confratelli — non gestiva altrettanto bene le entità della vita reale.<br />
Stroustrup, che ai tempi del suo dottorato aveva lavorato con un linguaggio a oggetti chiamato <em>Simula67</em>, pensò che se avesse potuto aggiungere alla velocità di esecuzione del C la possibilità di creare dei nuovi tipi di dato di Simula, avrebbe ottenuto il linguaggio perfetto. Aveva ragione.<br />
Il nome <em>C++</em> si riferisce all’operatore <code>++</code>, che serve a incrementare di un’unità il valore di una variabile:</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{
    int C = 12;                  
    cout &lt;&lt; &quot;Valore di C = &quot; &lt;&lt; C &lt;&lt; endl;  
    C++;                         
    cout &lt;&lt; &quot;Valore di C = &quot; &lt;&lt; C &lt;&lt; endl; 
    return 0;               
} 
</code></pre>
<p>Se compili ed eseguti questo codice, otterrai:</p>
<pre><code>&gt; g++ cplusplus-incremento.cpp -o ../out/esempio
&gt; ../out/esempio
Valore di C = 12
Valore di C = 13</code></pre>
<p>C++, infatti, non era un nuovo linguaggio: era un C migliorato. Tutto il codice e l’esperienza che erano state fatte fino ad allora sul C potevano essere applicate anche al C++.<br />
Parafrasando Neruda, Stroustrsup fece con il C quello che Gesù fece con l’Ebraismo: prese una religione spartana, adatta per un popolo in fuga nel deserto e la migliorò, rendendola meno autoritaria.</p>
<hr />
<p>Le principali novità aggiunte al C dal C++ sono: l’<em>astrazione dei dati</em>, la <em>programmazone a oggetti</em> e la <em>generic programming</em>. Ora ti spiego cosa sono, ma tu non preoccuparti se non capisci: approfondiremo tutti questi concetti in seguito.<br />
I tipi di dato del C sono:</p>
<pre><code>char, int, float, double, array, enum, struct, union</code></pre>
<p>Più che sufficienti per scrivere il <em>kernel</em> di Unix, ma decisamente inadeguati per scrivere un programma che gestisca delle linee telefoniche. Perché un linguaggio di programmazione possa gestire con la stessa facilità un flusso di dati, un utente, una linea telefonica o anche un allevamento di cavalli, è necessario che oltre ai tipi di dato predefiniti, possa gestire anche delle nuove entità definite dal programmatore. Questa è ciò che si chiama <em>data abstraction</em> e il C++ la ottiene per mezzo delle <em>classi</em>. Le classi sono la rappresentazione, all’interno del codice, di un’entità:</p>
<pre><code>class Cavallo {
private:
    Sesso  _sesso;
    string _razza;
public:
    const char* getSpecie() const {
        return &quot;cavallo&quot;; 
    } 
    const char getSesso() const {        
        return (char)_sesso;
    }
    const char* getRazza() const {
        return _razza.c_str();
    }
    Cavallo() {}
    Cavallo(const char* razza, Sesso sesso ) {
        _razza  = razza;
        _sesso  = sesso;
    }
};</code></pre>
<p>o di un concetto:</p>
<pre><code>class Monta {
private:
    Cavallo _maschio;
    Cavallo _femmina;
    Data     _giorno;
public:
    Monta(Cavallo&amp; maschio, Cavallo&amp; femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
    }
};</code></pre>
<p>Grazie alle classi, il programmatore può creare dei nuovi tipi di dato e utilizzarli all’interno del suo programma nello stesso modo in cui utilizzerebbe i tipi di dato primitivi del linguaggio.<br />
Ciascuna classe ha degli <em>attributi</em> e dei <em>metodi</em>. Gli <em>attributi</em> sono dei dati che descrivono le caratteristiche della classe, per esempio, la razza o il sesso di un cavallo. I <em>metodi</em> sono delle funzioni che definiscono il modo in cui la classe può interagire con gli altri elementi del programma. Nelle classi dell’esempio gli <em>attributi</em> sono gli elementi che vedi nella sezione <code>private</code>, mentre i <em>metodi</em> sono le funzioni che vedi nella sezione <code>public</code>. La funzione che ha lo stesso nome della classe si chiama <em>costruttore</em> della classe, perché “spiega” al compilatore come debbano essere creati gli oggetti di questa classe.<br />
Le classi, però, sono la ricetta, non sono la pietanza. Per poter essere utilizzate, le classi devono essere <em>istanziate</em> negli oggetti:</p>
<pre><code>int main()
{
    Cavallo stallone(&quot;lipizzano&quot;, maschio);    
    Cavallo giumenta(&quot;maremmano&quot;, femmina);
    Monta   monta(stallone, giumenta);
    cout &lt;&lt; monta &lt;&lt; endl;
    return 0;               
}</code></pre>
<p><code>stallone</code>, <code>giumenta</code> e <code>monta</code> sono tre oggetti. I primi due sono istanze della classe <code>Cavallo</code>, il terzo è un’istanza della classe <code>Monta</code>.<br />
Se aggiungi un po’ di codice alle classi che abbiamo visto prima e compili il programma, otterrai:</p>
<pre><code>% g++ cplusplus-classe.cpp -o ../out/esempio 
% ../out/esempio                               
DATA: Sun Apr  5 10:38:31 2020
MASCHIO: Specie:cavallo, Sesso:m, Razza:lipizzano
FEMMINA: Specie:cavallo, Sesso:f, Razza:maremmano```</code></pre>
<p>Perché un linguaggio di programmazione possa dirsi <em>orientato agli oggetti</em>, però, oltre alle classi deve poter gestire l’<em>ereditarietà</em> e il <em>polimorfismo</em>. L’<em>ereditarietà</em> permette di definire dei nuove classi come estensione di classi esistenti: <span id="cast"></span></p>
<pre><code>class Animale {
private:
    string _specie;
    string _razza;
    Sesso  _sesso;
public:
    const char* getSpecie() const {
        return _specie.c_str(); 
    } 
    const char getSesso() const {        
        return (char)_sesso;
    } 
    const char* getRazza() const {
        return _razza.c_str();
    }
    Animale() {}
    Animale(const char* specie, const char* razza, const Sesso sesso ) {
        _specie = specie;
        _razza  = razza;
        _sesso  = sesso;
    }
};

class Cavallo : public Animale {
public:
    Cavallo() {}
    Cavallo(const char* razza, const Sesso sesso )
    : Animale(&quot;Cavallo&quot;, razza, sesso ) { 
    }
};</code></pre>
<p>Nell’esempio qui sopra, abbiamo prima definito una classe <code>Animale</code>, che ha tre attributi: la <code>specie </code>, la <code>razza </code> e il <code>sesso </code>; poi abbiamo definito una classe <code>Cavallo</code>, derivandola dalla classe <code>Animale</code>. In questo modo, se oltre ai cavalli il nostro programma dovesse gestire anche altri ungulati, non dovremmo ripetere in ciascuna classe le stesse istruzioni, ma potremmo utilizzare quelle della classe base:</p>
<pre><code>class Asino : public Animale {
public:
    Asino() {}
    Asino(const char* razza, const Sesso sesso )
    : Animale(&quot;Asino&quot;, razza, sesso ) { 
    }
};</code></pre>
<p>A questo punto, la tua sagacia dovrebbe averti fatto rilevare un possibile problema (posto che tu sia sveglio, cosa di cui non sono del tutto certo): la classe <code>Monta</code> può gestire solo oggetti di tipo <code>Cavallo</code>.<br />
Un linguaggio che non gestisca il polimorfismo ci costringerebbe a scrivere due nuove classi: una per i muli e una per i bardotti:</p>
<pre><code>class MontaMulo {
private:
    Asino   _maschio;
    Cavallo _femmina;
    Data     _giorno;
public:
    MontaMulo(Asino&amp; maschio, Cavallo&amp; femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
    }
};

class MontaBardotto {
private:
    Cavallo _maschio;
    Asino   _femmina;
    Data     _giorno;
public:
    Monta(const Cavallo&amp; maschio, const Asino&amp; femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
    }
};</code></pre>
<p>Il problema è che più codice scrivi, più è probabile che farai degli errori e meno facile sarà correggerli. Al contrario, i programmi con meno righe di codice sono più affidabili e più facili da correggere o da modificare.<br />
Il C++ ci aiuta in questo senso perché permette il <em>polimorfismo</em>, ovvero la capacità di una funzione o di un operatore di svolgere il proprio compito indipendentemente dal tipo di dato che deve gestire. Se riscriviamo la classe <code>Monta</code> usando, al posto dei parametri di tipo <code>Cavallo</code>, dei parametri che hanno il tipo della classe base <code>Animale</code>:</p>
<pre><code>class Monta {
private:
    Animale* _maschio;
    Animale* _femmina;
    Data     _giorno;
public:
    Monta(Animale* maschio, Animale* femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
    }
};
</code></pre>
<p>Potremo creare degli oggetti di classe <code>Monta</code> con qualunque classe derivata:</p>
<pre><code>/** 
 * @file src/cplusplus-polimorfismo.cpp
 * Esempio di polimorfismo delle classi.
 */

#include &lt;iostream&gt;
#include &lt;ctime&gt;

using namespace std;

typedef time_t Data;

typedef enum _sesso {
    maschio = &#39;m&#39;,
    femmina = &#39;f&#39;
} Sesso;

class Animale {
private:
    string _razza;
    Sesso  _sesso;
public:
    virtual const char* getSpecie() const {
        return &quot;&quot;; 
    } 
    const char getSesso() const {        
        return (char)_sesso;
    } 
    const char* getRazza() const {
        return _razza.c_str();
    }
    Animale() {}
    Animale(const char* razza, const Sesso sesso ) {
        _razza  = razza;
        _sesso  = sesso;
    }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; &quot;Specie:&quot; &lt;&lt; animale.getSpecie() &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Razza:&quot;  &lt;&lt; animale.getRazza()  &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Sesso:&quot;  &lt;&lt; animale.getSesso()  &lt;&lt; endl;
    return os;   
}

class Cavallo : public Animale {
public:
    const char* getSpecie() const {
        return &quot;Cavallo&quot;; 
    }     
    Cavallo() {}
    Cavallo(const char* razza, const Sesso sesso )
    : Animale(razza, sesso ) { 
    }
};

class Asino : public Animale {
public:
    const char* getSpecie() const {
        return &quot;Asino&quot;; 
    }     
    Asino() {}
    Asino(const char* razza, const Sesso sesso )
    : Animale(razza, sesso ) { 
    }
};

class Monta {
private:
    Animale* _maschio;
    Animale* _femmina;
    Data     _giorno;
public:
    Monta(Animale* maschio, Animale* femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
    }
    friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Monta&amp; copula) {
        os &lt;&lt; &quot;DATA: &quot;    &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
           &lt;&lt; &quot;MASCHIO: &quot; &lt;&lt; *copula._maschio 
           &lt;&lt; &quot;FEMMINA: &quot; &lt;&lt; *copula._femmina;
           return os;   
     };
};

int main()
{
    Animale* cavallo  = new Cavallo(&quot;lipizzano&quot;, maschio);    
    Animale* giumenta = new Cavallo(&quot;maremmano&quot;, femmina);    
    Animale* asino    = new Asino(&quot;amiatino&quot;, maschio);
    Animale* asina    = new Asino(&quot;sardo&quot;, femmina);

    Monta puledro(cavallo, giumenta);
    Monta ciuco(asino, asina);
    Monta mulo(asino, giumenta);
    Monta bardotto(asina, cavallo);

    cout &lt;&lt; &quot;PULEDRO\n&quot;  &lt;&lt; puledro  &lt;&lt; endl;
    cout &lt;&lt; &quot;CIUCO\n&quot;    &lt;&lt; ciuco    &lt;&lt; endl;
    cout &lt;&lt; &quot;MULO\n&quot;     &lt;&lt; mulo     &lt;&lt; endl;
    cout &lt;&lt; &quot;BARDOTTO\n&quot; &lt;&lt; bardotto &lt;&lt; endl;

    return 0;               
}
</code></pre>
<p>Compilando ed esegendo il programma, otterrai:</p>
<pre><code>% g++ cplusplus-polimorfismo.cpp -o ../out/esempio
% ../out/esempio                                    
PULEDRO
DATA: Sun Apr  5 12:33:45 2020
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f

CIUCO
DATA: Sun Apr  5 12:33:45 2020
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f

MULO
DATA: Sun Apr  5 12:33:45 2020
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f

BARDOTTO
DATA: Sun Apr  5 12:33:45 2020
MASCHIO: Specie:Asino   Razza:sardo     Sesso:f
FEMMINA: Specie:Cavallo Razza:lipizzano Sesso:m</code></pre>
<p>Come ti ho detto, però, un buon programmatore non si accontenta di essere riuscito a produrre il risultato atteso, ma si chiede sempre se ci sia un modo più efficiente per ottenerlo. Nel nostro caso, il codice che abbiamo utilizzato per mostrare il risultato degli accoppiamenti:</p>
<pre><code>Monta puledro(cavallo, giumenta);
Monta ciuco(asino, asina);
Monta mulo(asino, giumenta);
Monta bardotto(asina, cavallo);

cout &lt;&lt; &quot;PULEDRO\n&quot;  &lt;&lt; puledro  &lt;&lt; endl;
cout &lt;&lt; &quot;CIUCO\n&quot;    &lt;&lt; ciuco    &lt;&lt; endl;
cout &lt;&lt; &quot;MULO\n&quot;     &lt;&lt; mulo     &lt;&lt; endl;
cout &lt;&lt; &quot;BARDOTTO\n&quot; &lt;&lt; bardotto &lt;&lt; endl;</code></pre>
<p>non è il massimo dell’efficienza, sia perché potremmo sbagliarci ad accoppiare la specie dei genitori con il nome del figlio, sia perché le istruzioni devono essere ripetute per ciascun oggetto. Per risolvere il primo difetto possiamo aggiungere alla classe <code>Monta</code> un attributo e un metodo per definire autonomamente che tipo di genìa venga prodotta dalla copula: <span id="membro"></span></p>
<pre><code>string   _esito;
void setEsito() {
    if(strcmp(_maschio-&gt;getSpecie(),&quot;Asino&quot;) == 0) {
        if(strcmp(_femmina-&gt;getSpecie(),&quot;Asino&quot;) == 0){
            _esito = &quot;asino&quot;;
        } else {
            _esito = &quot;mulo&quot;;
        } 
    } else {        
        if(strcmp(_femmina-&gt;getSpecie(),&quot;Cavallo&quot;) == 0) {
            _esito = &quot;puledro&quot;;
        } else {
            _esito = &quot;bardotto&quot;;
        } 
    }
}</code></pre>
<p>ma anche così dovremo comunque riscrivere quattro righe di codice per modificare l’output del programma: un approccio inaccettabile per i sistemi di produzione, dove le entità da gestire possono essere migliaia. Possiamo risolvere questo problema grazie al <em>generic programming</em> e al modo in cui viene implementato nel C++: le classi <em>template</em>:</p>
<pre><code>template &lt; class T&gt; class list;</code></pre>
<p>La classe <code>list</code> è una delle classi <em>template</em> del C++ e permette di inserire, rimuovere, spostare, unire, ordinare ed elencare una lista di oggetti di una stessa classe. La sintassi per creare una lista di oggetti di classe <code>Monta</code> è:</p>
<pre><code>list&lt;Monta&gt; monte;</code></pre>
<p>Fatto ciò, possiamo aggiungere elementi alla nostra lista con la funzione <code>push_back()</code>, alla quale passeremo direttamente il costruttore della classe:</p>
<pre><code>monte.push_back(Monta(cavallo, giumenta)); 
monte.push_back(Monta(asino, asina));       
monte.push_back(Monta(asino, giumenta));     
monte.push_back(Monta(cavallo, asina));</code></pre>
<p>Questo codice è una forma più efficiente di:</p>
<pre><code>Monta m1(cavallo, giumenta); 
Monta m2(asino, asina);       
Monta m3(asino, giumenta);     
Monta m4(cavallo, asina);

monte.push_back(m1);  
monte.push_back(m2);  
monte.push_back(m3);
monte.push_back(m4);</code></pre>
<p>Per visualizzare il contenuto della lista, indipendentemtente dal numero di elementi, basta l’istruzione:</p>
<pre><code>for (list&lt;Monta&gt;::iterator it=monte.begin(); it!=monte.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; endl;
}</code></pre>
<p>La funzione <code>main()</code> del nostro programma sarà quindi:</p>
<pre><code>int main()
{
    Animale* cavallo  = new Cavallo(&quot;lipizzano&quot;, maschio);    
    Animale* giumenta = new Cavallo(&quot;maremmano&quot;, femmina);    
    Animale* asino    = new Asino(&quot;amiatino&quot;, maschio);
    Animale* asina    = new Asino(&quot;sardo&quot;, femmina);
    list&lt;Monta&gt; monte;
    monte.push_back(Monta(cavallo, giumenta)); 
    monte.push_back(Monta (asino, asina));       
    monte.push_back(Monta (asino, giumenta));     
    monte.push_back(Monta (cavallo, asina));
    for (list&lt;Monta&gt;::iterator it=monte.begin(); 
         it!=monte.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; endl;
    }
    return 0;               
}</code></pre>
<p>e l’output che otterremo è:</p>
<pre><code>$ g++ cplusplus-template.cpp -o ../out/esempio
% ../out/esempio                                
DATA:    Sun Apr  5 16:19:24 2020
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   puledro

DATA:    Sun Apr  5 16:19:24 2020
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   asino

DATA:    Sun Apr  5 16:19:24 2020
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   mulo

DATA:    Sun Apr  5 16:19:24 2020
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   bardotto</code></pre>
<p>Se per qualche motivo volessimo invertire l’ordine degli elementi nella lista, tutto quello che dovremmo fare è di aggiungere prima del ciclo <code>for</code> l’istruzione:</p>
<pre><code>monte.reverse();</code></pre>
<p>e l’output che otteremmo è:</p>
<pre><code>% g++ cplusplus-template.cpp -o ../out/esempio
% ../out/esempio                                
DATA:    Sun Apr  5 17:08:27 2020
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Asino   Razza:sardo Sesso:f
ESITO:   bardotto

DATA:    Sun Apr  5 17:08:27 2020
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   mulo

DATA:    Sun Apr  5 17:08:27 2020
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   asino

DATA:    Sun Apr  5 17:08:27 2020
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   puledro
</code></pre>
<p>Oltre alle classi template predefinite della <em>Standard Template Library</em>, il C++ permette di definire le proprie classi template, ma di questo parleremo <a href="/man/polimorfismo#template" class="xref">a tempo debito</a>.<br />
Queste caratteristche, unite alla compatibilità con il codice scritto in C, fecero di C++ il linguaggio <em>object-oriented</em> più utilizzato degli anni ‘90. L’avvento, alla fine del Secolo, del linguaggio con la “J”, quello che ha bisogno di un sistema di <em>garbage collecion</em> per sopperire alla pochezza dei suoi programmatori, avrebbe dovuto darci un’idea di quello che sarebbe stato il millennio che ci si presentava davanti. Non a caso, Stroustrsup disse:</p>
<blockquote>
<p>I suspect that the root of many of the differences between C/C++ and Java is that AT&amp;T is primarily a user (a consumer) of computers, languages, and tools, whereas Sun is primarily a vendor of such things. <a href="/man/note/#cpp" class="nota"></a></p>
</blockquote>
</section>
</section>
<a href="/man/linguaggi-di-programmazione" class="left" title="Vai a: I linguaggi di programmazione"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/commenti" class="right" title="Vai a: I commenti"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/c-plus-plus" class="left" title="Vai a: Il C++"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/tipi-di-dato" class="right" title="Vai a: I tipi di dato"><em></em></a>
<section id="i-commenti-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">I commenti</a></h1>
<blockquote>
Il Compilatore e il Linker non usano carità, tengono i diecimila oggetti per cani di paglia
</blockquote>
<section class="testo">
<p>I commenti sono la cosa più importante, quando si programma.</p>
<p>Un commento è un breve brano di testo che descrive in linguaggio comune il funzionamento o lo scòpo del codice a cui è riferito:</p>
<pre><code>/**
 * Funzione per il raddoppio dello stipendio.
 * Richiede come paramentro il valore dello 
 * stipendio corrente e ne torna il valore 
 * duplicato.
 */
long raddoppia(long stipendio)
{
    return stipendio * 2;   //  raddoppia il valore 
}</code></pre>
<p>Pur essendo all’interno del codice, il commento viene ignorato in fase di compilazione, perché è un’aggiunta utile solo al programmatore. Al processore non interessa sapere a cosa serve il codice che sta eseguendo: lo esegue e basta, senza farsi distrarre da implicazioni funzionali — o, peggio, etiche — che allungherebbero i tempi di risposta.<br />
È importante commentare bene il proprio codice. Il buon codice produce programmi che durano nel tempo e, col tempo, si tende a dimenticare. Anche se si ha la fortuna di possedere una buona memoria, bisogna considerare la possibilità che il proprio codice sia utilizzato da un collega. Non solo non è educato costringerlo ad analizzare ogni singola riga di codice per capirne il funzionamento, ma è anche improduttivo.<br />
Così come la penuria, anche l’eccesso di commenti è un errore da evitare. Il programmatore inesperto non commenta il proprio codice perché pensa che sia una perdita di tempo. È davvero un atteggiamento poco responsabile. Il neofita zelante riempie il proprio codice di commenti, o perché ritiene che chi lo andrà a leggere sarà meno esperto di lui o perché vuole in questo modo esaltare le sue poche conoscenze. Il programmatore esperto commenta solo ciò che non è di per sé evidente e indica i possibili punti deboli del suo programma in modo che chi si trova a riutilizzarlo o a correggerlo vi presti la dovuta attenzione. Il programmatore perfetto non commenta il suo codice, perché il suo codice è auto-esplicativo:</p>
<pre><code>typedef Importo unsigned long;

Importo raddoppiaStipendio(Importo stipendioCorrente)
{
    return stipendioCorrente * 2;   
}</code></pre>
<p>È lo stesso brano di codice che abbiamo visto prima, ma stavolta i commenti non servono, perché gli intenti della funzione sono espressi direttamente nel codice, rendendo espliciti il nome della funzione, del suo parametro e del suo valore di ritorno. L’istruzione <code>typedef</code>, che hai visto anche negli esempii precedenti, seve a definire dei nuovi tipi di dato, come alias di tipi di dato esistenti. L’istruzione:</p>
<pre><code>typedef time_t Data;</code></pre>
<p>definisce il tipo di dato <code>Data</code> come alias del tipo di dato standard <code>time_t</code>, mentre l’istruzione:</p>
<pre><code>typedef Importo unsigned long;</code></pre>
<p>definisce il tipo di dato <code>Importo</code> come alias del tipo di dato standard <code>unsigned long</code>.<br />
La definizione dei proprii tipi di dato non solo rende il codice più leggibile, ma lo rende anche più facile da modificare. La funzione originale utilizza dei valori di tipo <code>unsigned long</code>, ovvero delle sequenze di 4 byte che permettono di memorizzare numeri interi da 0 a 4.294.967.295 (2<sup>32</sup>). Questo tipo di dato può essere utilizzato per uno stipendio che non abbia cifre decimali, come quello del Maestro Canaro nel secolo scorso, ma se dovessimo raddoppiare uno stipendio con delle cifre decimali, dovremmo utilizzare dei tipi di dato come i <code>float</code> o i <code>double</code> e, senza una <code>typedef</code>, saremmo costretti a modificare sia il valore di ritorno che il tipo di parametro della funzione:</p>
<pre><code>float raddoppia(float stipendio)
{
    return stipendio * 2;   //  raddoppia il valore 
}</code></pre>
<p>Se invece abbiamo definito un nostro tipo di dato dobbiamo modificare solo l’istruzione <code>typedef</code>, lasciando tutto il resto invariato:</p>
<pre><code>typedef Importo float;

Importo raddoppiaStipendio(Importo stipendioCorrente)
{
    return stipendioCorrente * 2;   
}</code></pre>
<p>È ammissibile che i commenti abbiano una sfumatura umoristica, può essere utile per scaricare un po’ della tensione in chi legge, così come scambiarsi una battuta mentre si lavora, ma anche in questo non si deve esagerare.</p>
<pre><code>    case STATE_CR:  // Got CR: look for LF 
        state = STATE_NORMAL;
        if( ch == LF) {
            continue;
        }
        break;
    default:  // Hmmm... this shouldn&#39;t happen
        break;
    }
    cgi.param_data[j++] = ch;
}</code></pre>
<p>Il C++ prevede due modi distinti per commentare il codice: due caratteri <code>//</code> affiancati o la sequenza <code>/*  */</code>, che il Linguaggio ha mutuato dal suo predecessore, il C. Nel primo caso, il compilatore ignora i caratteri dal simbolo fino alla fine della riga; nel secondo caso, ignora tutto ciò che è compreso fra le due sequenze di caratteri.</p>
<pre><code>/**
 * Questa sintassi è più comoda per i commenti 
 * che si estendono su più di una riga
 */
for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; i &lt;&lt; endl; // questa, per i commenti su una riga
}
</code></pre>
<p>Entrambe le soluzioni hanno dei pro e dei contro che con l’esperienza risultano evidenti. Scegliere l’uno o l’altro è spesso una questione di convenienza, altre volte una questione di stile, ma se si capisce la vera essenza del Linguaggio, è solo una questione di ritmo.</p>
<hr />
<p>Una volta, il maestro Canaro mostrò ai suoi allievi un brano di codice e gli chiese di spiegare che cosa facesse:</p>
<pre><code>/**********************************************************
 
#include &lt;iostream.h&gt;

#define ERR_NOFILE 1

int errore( int errore );
void leggi_file( char * nomefile );
void crea_matrice(void);
int inizializza(void);
void imposta_probabilita(void);
void attrattore(void);
int chiudi(void);

int main(int argc, char * argv[])
{
    int esito = 0 ;
    if(argc &lt; 2) {
        esito = errore(ERR_NOFILE);
    } else {
        leggi_file(argv[1]);
        crea_matrice();
        if(inizializza()) {
            const char * valore = imposta_probabilita();
            attrattore(valore);
            esito = chiudi();
        }
    }
    return esito ;
}

***********************************************************/
</code></pre>
<p>Gli allievi studiarono il codice e diedero le loro risposte, ma sbagliarono tutti, perché tutte le istruzioni erano comprese fra un <code>/*</code> e un <code>*/</code> e non venivano compilate.</p>
</section>
</section>
<a href="/man/c-plus-plus" class="left" title="Vai a: Il C++"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/tipi-di-dato" class="right" title="Vai a: I tipi di dato"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/commenti" class="left" title="Vai a: I commenti"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/struttura-dei-programmi" class="right" title="Vai a: Struttura dei programmi C++"><em></em></a>
<section id="i-tipi-di-dato-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">I tipi di dato</a></h1>
<blockquote>
Tutto è byte
</blockquote>
<section class="testo">
<p>La varietà dei tipi di dato disponibili è la caratteristica principale del C++.</p>
<p>Il C++ ha ereditato dal C una vasta gamma di tipi di dato. A seconda della loro natura, possiamo dividere questi tipi di dato in due gruppi: i dati <em>scalari</em> e i dati <em>aggregati</em>.<br />
I tipi di dato <em>scalari</em> sono: <code>void</code>, <code>bool</code>, <code>char</code>, <code>wchar_t</code>, <code>int</code>, <code>float</code>, <code>double</code> e permettono di gestre gli elementi classici di un programma: i numeri interi, i numeri decimali, le lettere e i valori booleani.<br />
I tipi di dato <em>aggregati</em> sono gli <em>array</em>, le <em>unioni</em>, gli <em>emumerati</em>, le <em>strutture</em> e le <em>classi</em>. Questi, come dice anche il loro nome, sono costituiti dall’aggregazione di più dati scalari dello stesso tipo o di tipi differenti.<br />
Il prossimo brano di codice — fastidiosamente didascalico, nella sua sostanziale inutilità — mostra i principali tipi di dato del C++. Contiene molti elementi di cui ancora non ti ho parlato, quindi non preoccuparti se non capisci del tutto ciò che fa.</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

/** Definisce un tipo di dato enumerato di nome RGB */
enum RGB { red = 0xFF0000, green = 0x00ff00, blue = 0x0000ff };

/** Definisce una struttura che contiene un colore RGB e un nome */
struct ColoreRGB {
    RGB  valore;
    const char* nome;        
};

/** 
 * Definisce la classe Colore, che contiene un coloreRGB 
 * e una funzione che ne mostra il nome.
 */
class Colore {
public:
    ColoreRGB coloreRgb;        
    void nome_colore() {
        cout &lt;&lt; &quot;coloreRGB:&quot;;
        switch(coloreRgb.valore) {
            case red  : cout &lt;&lt; &quot;red&quot;  ; break;
            case green: cout &lt;&lt; &quot;green&quot;; break;
            case blue : cout &lt;&lt; &quot;blue&quot; ; break;
        }
        cout &lt;&lt; endl;
    }        
};

int main()
{    
    /** Dichiara una serie di variabili */
    bool    booleano  = false;
    char    carattere = &#39;C&#39;;
    int     intero    = 1234567890;
    float   decimale  = 3.14;
    char    array[]   = &quot;abcdefghilmnopqrstuvz&quot;;
    RGB     enumerato = green;
    
    /** Crea un oggetto di tipo Colore */
    Colore  colore;    
    
    /** 
     * Assegna un valore ai dati della struttura coloreRgb 
     * all&#39;interno dell&#39;oggetto di tipo Colore.
     */
    colore.coloreRgb.valore = enumerato;   
    colore.coloreRgb.nome = &quot;verde&quot;;     

    /** Mostra il valore delle variabili */
    cout &lt;&lt; &quot;booleano:&quot;    &lt;&lt; booleano   &lt;&lt; endl;
    cout &lt;&lt; &quot;carattere:&quot;   &lt;&lt; carattere  &lt;&lt; endl;
    cout &lt;&lt; &quot;intero:&quot;      &lt;&lt; intero     &lt;&lt; endl;
    cout &lt;&lt; &quot;decimale:&quot;    &lt;&lt; decimale   &lt;&lt; endl;
    cout &lt;&lt; &quot;array:&quot;       &lt;&lt; array      &lt;&lt; endl;
    
    /** Mostra il nome del colore */
    colore.nome_colore();
    
    return 0;
}
</code></pre>
<p>Compilando ed eseguendo questo codice, otterrai:</p>
<pre><code>% g++ src/cpp/tipi-di-dato-principali.cpp -o src/out/esempio
% src/out/esempio 
booleano:0
carattere:C
intero:1234567890
decimale:3.14
array:abcdefghilmnopqrstuvz
coloreRGB:green</code></pre>
<p>Il tipo di dato <code>void</code> non ha né una dimensione né un valore e può essere assegnato solo a un puntatore o a una funzione che non torna alcun tipo di valore, come la funzione <code>nome_colore</code> della classe <code>Colore</code>.<br />
Il tipo di dato <code>bool</code> è utilizzato per gestire i valori booleani. Può assumere solo due valori: <code>true</code> o <code>false</code>, quindi ha la dimensione minima possibile, ovvero un byte.<br />
Il tipo <code>int</code> permette di gestire i numeri interi. Di solito ha una dimensione di quattro byte, che può essere aumentata o diminuita per mezzo di parole-chiave dette: <a href="#modificatori">modificatori</a>.<br />
I tipi <code>float</code> e <code>double</code> si utilizzano per gestire i numeri decimali. Hanno una lunghezza di quattro e otto byte rispettivamente e una precisione di sette e quindici cifre decimali.<br />
I tre elementi che compaiono al di fuori della funzione <code>main</code> sono tipi di dato <em>aggregati</em> e permettono di definre dei tipi di dati non standard.<br />
Gli <code>enum</code> permettono di assegnare dei nomi a dei valori, rendendo più facile la programmazione. Nell’esempio, l’<em>enum</em> <code>RGB</code>assegna un nome a tre valori della codifica RGB. Questo nuovo tipo di dato è utilizzato nella struttura <code>ColoreRGB</code>.<br />
Le <code>struct</code> permettono di creare degli insiemi di dati eterogenei. La variabile <code>ColoreRGB</code> contiene due variabili differenti: un valore di tipo <code>RGB</code> e un <a href="#puntatori">puntatore</a> a carattere.<br />
Tutti i tipi di dati che abbiamo visto finora sono un retaggio del linguaggio <em>C</em>. La classe <code>Colore</code>, invece, è una delle novità introdotte dal C++ e contiene due elementi: una struttura di tipo <code>ColoreRGB</code> e una funzione che mostra il nome del colore.<br />
Attenzione, però: nessuno di questi signori è in realtà ciò che afferma di essere. Nella variabile <code>booleano</code> non c’è il valore <code>true</code> o <code>false</code>, ma un valore binario che il sistema considera tale. Allo stesso modo, nella variabile <code>carattere</code>, non c’è la lettera <code>C</code>, ma il valore binario corrispondente alla codifica ASCII della lettera <code>C</code>. Ogni tipo di dato non è altro che il nome di una quantità di memoria. Ricordatelo, perché questo è la chiave di tutto.</p>
<hr />
<p>La dimensione di memoria associata a ciascun tipo di dato non è fissa, ma può variare a seconda del sistema in cui stai lavorando. Il codice qui sotto ti permette di conoscere la dimensione in byte dei tipi di dato scalari:<span id="sizeof"></span></p>
<pre><code>/** 
 * @file tipi-di-dato-dimensione.cpp
 * Mostra la dimensione dei principali tipi di dato del C++.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

int main()
{    
    int w = 12;
    
    cout &lt;&lt; setw(w) &lt;&lt; &quot;bool: &quot;   &lt;&lt; sizeof(bool)   &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;char: &quot;   &lt;&lt; sizeof(char)   &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;int: &quot;    &lt;&lt; sizeof(int)    &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;float: &quot;  &lt;&lt; sizeof(float)  &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Compilando ed eseguendo questo codice, otterrai:</p>
<pre><code>% g++ tipi-di-dato-dimensione.cpp -o ../out/esempio
% ../out/esempio                                   
      bool: 1
      char: 1
       int: 4
     float: 4
    double: 8</code></pre>
<p>Dalla dimensione del tipo di dato dipende la quantità di valori che può assumere. Un <code>char</code> è composto da otto bit e può assumere per ciò 2<sup>8</sup> valori, quindi: da 0 a 255. Un <code>int</code> è composto da trentadue bit e può assumere 2<sup>32</sup> valori, ovvero: da 0 a 4.294.967.295. Un <code>float</code> ha 8 bit per l’esponente e 23 per la mantissa, quindi può assumere valori da 1.175494e-38 a 3.402823e+38 e così via.<br />
<span id="modificatori"></span> Oltre ai tipi di dato, il C++ ha ereditato dal C anche i cosiddetti <em>modificatori</em>, ovvero delle parole-chiave che, se aggiunte al nome di un tipo di dato, ne modificano le caratteristiche.<br />
I modificatori <code>short</code> e <code>long</code> alterano la dimensione del dato, riducendolo o aumentandolo.<br />
I modificatori <code>signed</code> e <code>unsigned</code> fanno sì che il primo bit del dato sia considerato il suo segno: positivo se il valore è 0; negativo se il valore è 1. Il segno, però, “ruba” un bit alla variabile <em>signed</em> che quindi potrà assumere un numero minore di valori rispetto alla stessa variabile <em>unsigned</em>.<br />
Questo programma mostra come la dimensione e i valori minimi e massimi del tipo di dato <code>int</code> possano variare con l’utilizzo dei modificatori:</p>
<pre><code>/** 
 * @file tipi-di-dato-limiti.cpp
 * Mostra i valori possibili per i principali tipi di dato del C++.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;limits&gt;

using namespace std;

/**
 * Funzione template che mostra la dimensione e i 
 * valori minimi e massimi per un tipo di dato.
 */
template&lt;typename T&gt;
void dimensione()
{
    cout &lt;&lt; sizeof(T) &lt;&lt; &quot; bytes,&quot;
         &lt;&lt; setw(4)   &lt;&lt; &quot;da:&quot;   
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::min()
         &lt;&lt; setw(4)   &lt;&lt; &quot;a:&quot;    
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::max() 
         &lt;&lt; endl;
}

int main()
{    
    /** Variazione della dimensione e dei valori del tipo int */
    cout &lt;&lt; setw(16) &lt;&lt; &quot;int: &quot;; 
    dimensione&lt;int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned int: &quot;; 
    dimensione&lt;unsigned int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;short int: &quot;; 
    dimensione&lt;short int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned short: &quot;; 
    dimensione&lt;unsigned short&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;long int: &quot;; 
    dimensione&lt;long int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned long: &quot;; 
    dimensione&lt;unsigned long&gt;();
    
    return 0;
}
</code></pre>
<p>Se esamini con attenzione il codice scoprirai un’altra caratteristica dei modificatori del C++: se sono riferiti a un dato di tipo intero, è possibile accorciare la dichiarazione omettendo la parola-chiave <code>int</code>.<br />
L’output di questo programma, sul mio computer è:</p>
<pre><code>% g++ tipi-di-dato-limiti.cpp -o ../out/esempio
% ../out/esempio                               
           int: 4 bytes, da:          -2147483648  a:           2147483647
  unsigned int: 4 bytes, da:                    0  a:           4294967295
     short int: 2 bytes, da:               -32768  a:                32767
unsigned short: 2 bytes, da:                    0  a:                65535
      long int: 8 bytes, da: -9223372036854775808  a:  9223372036854775807
 unsigned long: 8 bytes, da:                    0  a: 18446744073709551615</code></pre>
<p><span id="funzioni"></span> L’ultima cosa di cui ti devo parlare, a proposito dei tipi di dato del C++ sono i cosiddetti <em>attributi intermediari</em>, ovvero: le <em>funzioni</em>, gli <em>array</em>, i <em>puntatori</em> e le <em>reference</em>.<br />
Delle <em>funzioni</em> parleremo diffusamente <a href="/man/funzioni">in seguito</a>. Quello che ci interessa, qui e ora, è che ogni funzione ha un suo tipo di dato. La funzione <code>main</code>, che è la funzione principale di ogni programma, ha come tipo di dato <code>int</code> e infatti si chiude con l’istruzione:</p>
<pre><code>return 0;</code></pre>
<p>La funzione <code>nome_colore</code>, all’interno della classe <code>Colore</code> è di tipo <code>void</code> e, come puoi vedere, non ha valore di ritorno.<br />
Gli <em>array</em> sono degli insiemi di dati omogemei e si dichiarano aggiungendo al nome della variabile delle parentesi quadre. La dimensione dell’array deve essere definita al momento della sua dichiarazione; questo può avvenire o in maniera esplicita, inserendo il numero di elementi fra le parentesi quadre:</p>
<pre><code>char elementi[10];</code></pre>
<p>o assegnando all’array un valore che ne determinerà la dimensione massima, così come abbiamo visto nel primo esempio:</p>
<pre><code>char array[] = &quot;abcdefghilmnopqrstuvz&quot;;</code></pre>
<p>Ogni elemento dell’array è identificato da un indice che va 0 al numero di elementi dell’array meno uno. Nel caso dell’array qui sopra, la lettera <code>a</code> avrà indice 0, la <code>b</code> avrà indice 2 e così via, fino alla <code>z</code>, che avrà indice 20.</p>
<hr />
<p>I <em>puntatori</em> sono come i pitbull: alla maggior parte delle persone fanno paura, ma chi li conosce sa che sono cani dolcissimi, se li sai trattare. Quello che devi tenere sempre a mente è che il <em>C++</em> è solo un modo particolare di vedere la memoria del computer e nella memoria non ci sono caratteri, non ci sono classi, non ci sono immagini e non ci sono film porno, ma solo una lunga sequenza di 1 e di 0:</p>
<pre><code>0100001100100111011010000110000101101110011011100110111100100000
0110011001101111011100100111001101100101001000000111010001110101
0111010001110100011001010010000001100101001000000110010001110101
0110010100100000011011000110000100100000011100110111010001100101
0111001101110011011000010010000001100101011101001110000000100000
0000101001001010011001010010000001100110011010010110111101110010
0110100101110011011000110110010100100000011001000110010101101110
0111010001110010011011110010000001100001011011000010000001100011
0110111101110010011001010010000000100111011011100010000001101001
0110110001101100011101010111001101101001011011110110111001100101</code></pre>
<p>L’unico modo per dare un senso a questa catena di valori binarii è di suddividerli in blocchi e assegnare un tipo di dato a ciascun blocco. Per esempio, se suddividi la sequenza binaria qui sopra in blocchi di otto bit:</p>
<pre><code>01000011 00100111 01101000 01100001 01101110 01101110 01101111 
00100000 01100110 01101111 01110010 01110011 01100101 00100000 
01110100 01110101 01110100 01110100 01100101 00100000 01100101 
00100000 01100100 01110101 01100101 00100000 01101100 01100001 
00100000 01110011 01110100 01100101 01110011 01110011 01100001 
00100000 01100101 01110100 11100000 00100000 00001010 01001010 
01100101 00100000 01100110 01101001 01101111 01110010 01101001 
01110011 01100011 01100101 00100000 01100100 01100101 01101110 
01110100 01110010 01101111 00100000 01100001 01110010 00100000 
01100011 01101111 01110010 01100101 00100000 00100111 01101110 
00100000 01101001 01101100 01101100 01110101 01110011 01101001 
01101111 01101110 01100101 </code></pre>
<p>e converti ciascun valore nel corrispondente carattere del set ASCII, scopri che una sequenza apparentemente insensata di 1 e di 0 è in realtà l’inizio di una famosa canzone popolare:</p>
<pre><code>01000011 =  67 = C
00100111 =  39 = &#39;
01101000 = 104 = h
01100001 =  97 = a
01101110 = 110 = n
01101110 = 110 = n
01101111 = 111 = o
00100000 =  32 = </code></pre>
<p>Per identificare i valori all’interno della sequenza di bit, hai bisogno di due informazioni: il tipo di dato che stai puntando e il suo indirizzo in memoria. I puntatori ti permettono di ottenere queste informazioni: il loro valore definisce l’indirizzo di memoria da cui leggere; il loro tipo definisce la dimensione del valore puntato.</p>
<pre><code>unsigned char * ptr = valori;</code></pre>
<p>Molti pensano ai puntatori come a delle bandierine che ti permettono di identificare un punto specifico della memoria, ma questo è vero solo per i puntatori <code>void</code>, che non hanno un tipo di dato associato. Gli altri puntatori, più che una bandierina, sono una sorta di maschera che può scorrere sulla sequenza di bit, isolando ed evidenziando i singoli valori che la compongono:</p>
<pre><code>01000011 00100111 01101000 01100001 01101110 01101110 01101111 
00100000 011001100110111101110010 01110011 01100101 00100000 
01110100 01110101 01110100 01110100 01100101 00100000 01100101 
00100000 01100100 01110101</code></pre>
<p>Questo programma mostra come la dimensione di un puntatore modifichi il risultato della lettura dei dati:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** 
 * Definisce due tipi di dato: uno lungo un byte 
 * e uno lungo due byte 
 */
typedef unsigned char byte;
typedef short int duebyte;

int main()
{    
    /** Crea un array di 80 valori binarii */
    byte valori[] = { 
          0b01000011, 0b00100111, 0b01101000, 0b01100001
        , 0b01101110, 0b01101110, 0b01101111, 0b00100000 
        , 0b01100110, 0b01101111, 0b01110010, 0b01110011
        , 0b01100101, 0b00100000, 0b01110100, 0b01110101
        , 0b01110100, 0b01110100, 0b01100101, 0b00100000
        , 0b01100101, 0b00100000, 0b01100100, 0b01110101
        , 0b01100101, 0b00100000, 0b01101100, 0b01100001
        , 0b00100000, 0b01110011, 0b01110100, 0b01100101
        , 0b01110011, 0b01110011, 0b01100001, 0b00100000
        , 0b01100101, 0b01110100, 0b11100000, 0b00100000
        , 0b00001010, 0b01001010, 0b01100101, 0b00100000
        , 0b01100110, 0b01101001, 0b01101111, 0b01110010
        , 0b01101001, 0b01110011, 0b01100011, 0b01100101
        , 0b00100000, 0b01100100, 0b01100101, 0b01101110
        , 0b01110100, 0b01110010, 0b01101111, 0b00100000
        , 0b01100001, 0b01110010, 0b00100000, 0b01100011
        , 0b01101111, 0b01110010, 0b01100101, 0b00100000
        , 0b00100111, 0b01101110, 0b00100000, 0b01101001
        , 0b01101100, 0b01101100, 0b01110101, 0b01110011
        , 0b01101001, 0b01101111, 0b01101110, 0b01100101 
    };

    /** 
     * Crea un puntatore con una dimensione di otto bit e gli
     * assegna come valore l&#39;indirizzo dell&#39;inizio dell&#39;array. 
     */
    byte * p1 = valori;
    
    /** 
     * Sposta il puntatore per tutta la lunghezza dell&#39;array,
     * mostrando per ciascun byte il suo valore binario, il
     * suo valore convertito in decimale e la lettera del      
     * set ASCII corrispondente a quel valore.
     */
    for(int i = 0; i &lt; sizeof(valori); i++) {
        cout &lt;&lt; setw(4)  &lt;&lt; i
             &lt;&lt; setw(18) &lt;&lt; bitset&lt;8&gt;(*p1) 
             &lt;&lt; setw(6)  &lt;&lt; (int)*p1 
             &lt;&lt; setw(4)  &lt;&lt; (char) *p1 &lt;&lt; endl;
             
        /** Sposta il puntatore al byte successivo. */
        p1++;
    }
    
    cout &lt;&lt; endl;
    
    /**
     * Crea un nuovo puntatore, stavolta con una
     * dimensione di sedici bit.
     */
    duebyte * p2 = (duebyte*)valori;
    
    /** 
     * Legge di nuovo i valori dell&#39;array,
     */
    for(int i = 0; i &lt; sizeof(valori) / 2; i++) {
        cout &lt;&lt; setw(4)  &lt;&lt; i
             &lt;&lt; setw(18) &lt;&lt; bitset&lt;16&gt;(*p2) 
             &lt;&lt; setw(6)  &lt;&lt; (short)*p2 
             &lt;&lt; setw(4)  &lt;&lt; (char) *p2 &lt;&lt; endl;
         
        /** Sposta il puntatore di due byte. */
        p2++;
    }

    return 0;
}
</code></pre>
<p>Questo è l’output del programma; voglio proprio vedere come farai a farlo entrare nel tuo libro:</p>
<pre><code> 0          01000011    67   C
 1          00100111    39   &#39;
 2          01101000   104   h
 3          01100001    97   a
 4          01101110   110   n
 5          01101110   110   n
 6          01101111   111   o
 7          00100000    32    
 8          01100110   102   f
 9          01101111   111   o
10          01110010   114   r
11          01110011   115   s
12          01100101   101   e
13          00100000    32    
14          01110100   116   t
15          01110101   117   u
16          01110100   116   t
17          01110100   116   t
18          01100101   101   e
19          00100000    32    
20          01100101   101   e
21          00100000    32    
22          01100100   100   d
23          01110101   117   u
24          01100101   101   e
25          00100000    32    
26          01101100   108   l
27          01100001    97   a
28          00100000    32    
29          01110011   115   s
30          01110100   116   t
31          01100101   101   e
32          01110011   115   s
33          01110011   115   s
34          01100001    97   a
35          00100000    32    
36          01100101   101   e
37          01110100   116   t
38          11100000   224   ?
39          00100000    32    
40          00001010    10   
41          01001010    74   J
42          01100101   101   e
43          00100000    32    
44          01100110   102   f
45          01101001   105   i
46          01101111   111   o
47          01110010   114   r
48          01101001   105   i
49          01110011   115   s
50          01100011    99   c
51          01100101   101   e
52          00100000    32    
53          01100100   100   d
54          01100101   101   e
55          01101110   110   n
56          01110100   116   t
57          01110010   114   r
58          01101111   111   o
59          00100000    32    
60          01100001    97   a
61          01110010   114   r
62          00100000    32    
63          01100011    99   c
64          01101111   111   o
65          01110010   114   r
66          01100101   101   e
67          00100000    32    
68          00100111    39   &#39;
69          01101110   110   n
70          00100000    32    
71          01101001   105   i
72          01101100   108   l
73          01101100   108   l
74          01110101   117   u
75          01110011   115   s
76          01101001   105   i
77          01101111   111   o
78          01101110   110   n
79          01100101   101   e

 0  0010011101000011 10051   C
 1  0110000101101000 24936   h
 2  0110111001101110 28270   n
 3  0010000001101111  8303   o
 4  0110111101100110 28518   f
 5  0111001101110010 29554   r
 6  0010000001100101  8293   e
 7  0111010101110100 30068   t
 8  0111010001110100 29812   t
 9  0010000001100101  8293   e
10  0010000001100101  8293   e
11  0111010101100100 30052   d
12  0010000001100101  8293   e
13  0110000101101100 24940   l
14  0111001100100000 29472    
15  0110010101110100 25972   t
16  0111001101110011 29555   s
17  0010000001100001  8289   a
18  0111010001100101 29797   e
19  0010000011100000  8416   ?
20  0100101000001010 18954   
21  0010000001100101  8293   e
22  0110100101100110 26982   f
23  0111001001101111 29295   o
24  0111001101101001 29545   i
25  0110010101100011 25955   c
26  0110010000100000 25632    
27  0110111001100101 28261   e
28  0111001001110100 29300   t
29  0010000001101111  8303   o
30  0111001001100001 29281   a
31  0110001100100000 25376    
32  0111001001101111 29295   o
33  0010000001100101  8293   e
34  0110111000100111 28199   &#39;
35  0110100100100000 26912    
36  0110110001101100 27756   l
37  0111001101110101 29557   u
38  0110111101101001 28521   i
39  0110010101101110 25966   n</code></pre>
<p>Come vedi, i bit sono gli stessi, ma cambiando il tipo di dato associato al puntatore e quindi la sua dimensione, il valore dei dati diventa un altro e la conversione dei numeri in lettere perde di significato.<br />
Le istruzioni: <code>p1++</code> e <code>p2++</code> incrementano di un’unità il puntatore, ovvero lo spostano in avanti nella memoria del numero di byte corrispondenti alla dimensione del tipo di dato a cui è associato. Il puntatore <code>p1</code> è un <code>unsigned char</code>, quindi si sposta di otto bit; il puntatore <code>p12</code> è uno <code>short int</code>, quindi si sposta di sedici bit. È questo il motivo per cui il secondo ciclo di lettura dura la metà del primo: perché la quantità di bit letta per ogni iterazione è doppia. Se mi fossi distratto e avessi copiato il codice del primo ciclo di lettura così com’è, senza dividere per due il numero di cicli, il puntatore avrebbe continuato a “camminare” in avanti nella memoria, oltre i confini dell’array e questo, come vedremo in seguito, non è assolutamente bene.<br />
Le <em>reference</em> sono degli alias delle variabili a cui sono associati. Come per i gibboni o i cigni, il legame fra una <em>reference</em> e la sua variabile dura tutta la vita. Mentre i puntatori possono avere un valore <code>NULL</code> e possono essere associati a variabili differenti nel corso dell’elaborazione, le <em>reference</em> devono sempre essere associate a una variabile e quell’associazione non può essere modificata successivamente.</p>
<pre><code>/** 
 * @file tipi-di-dato-reference.cpp
 * Utilizzo delle reference.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

int main()
{    
    /** Definisce una variabile di tipo int */
    int  v = 10;     

    /** Definisce una reference alla variabile v */
    int&amp; r = v;    

    /** I valori di v e r sono identici perché r è un&#39;alias di v */
    cout &lt;&lt; &quot;valori iniziali: v=&quot; &lt;&lt; v &lt;&lt; &quot;, r=&quot; &lt;&lt; r &lt;&lt; endl;

    /** Modifica il valore della variabile r */
    r = 20;

    /** Il valore di v sarà modificato di conseguenza */
    cout &lt;&lt; &quot;valori finali:   v=&quot; &lt;&lt; v &lt;&lt; &quot;, r=&quot; &lt;&lt; r &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Compilando ed eseguendo il codice, otterrai:</p>
<pre><code>% g++ src/cpp/tipi-di-dato-reference.cpp -o src/out/esempio
% src/out/esempio                                          
valori iniziali: v=10, r=10
valori finali:   v=20, r=20</code></pre>
<p>Approfondiremo i pro e i contro delle reference quando parleremo delle <a href="/man/funzioni">funzioni</a>.</p>
<hr />
<p>Dato che ciascun tipo di dato non è altro che un modo per vedere la memoria, è possibile fare delle conversioni da un tipo all’altro. Le conversioni possono essere <em>implicite</em> o <em>esplicite</em>. Le conversioni <em>implicite</em> sono quelle che avvengono quando un valore è copiato fra variabili di tipo compatibile:</p>
<pre><code>int  i = 0;
char c = i;</code></pre>
<p>In questo caso, assegnamo a una variabile di tipo <code>char</code> il valore di una variabile di tipo <code>int</code> e il compilatore ce lo lascia fare perché il valore dell’intero può essere salvato senza problemi anche nel singolo byte del <code>char</code>. Se volessimo rendere esplicita questa conversione, dovremmo utilizzare la sintassi:</p>
<pre><code>int  i = 0;
char c = (char) i;
char c = char (i);</code></pre>
<p>Le due forme sono equivalenti. La prima è quella che il C++ ha ereditato dal C; la seconda è chiamata <em>notazione funzionale</em>. Nell’esempio precedente, la variabile <code>valori</code> è un puntatore a <code>unsigned char</code>, ma abbiamo detto al sistema di considerarla un puntatore a <code>short int</code> con l’istruzione:</p>
<pre><code>duebyte * p2 = (duebyte*)valori;</code></pre>
<p>Il C++ ha anche altri modi per convertire un tipo di dato in un altro, ma siccome si applicano principalmente alle classi, li vedremo in seguito.</p>
<hr />
<p>Quello che ti ho appena detto del C++ vale anche per il C’hi++. Così come la “realtà” all’interno di un computer altro non è che una sequenza di valori binari che, aggregati fra di loro, costituiscono le entità gestite dal sistema, la realtà in cui noi viviamo altro non è che una manifestazione dell’azione dell’energia dell’Universo sulle particelle che costituiscono tutto ciò che esiste, ovvero gli <em>spazioni</em>.<br />
Puoi pensare all’Universo come a una versione tridimensionale di uno schermo di PC. Le immagini che vedi su questo schermo sono costituite da minuscoli puntini colorati, detti <em>pixel</em>. Quando lo schermo è spento, i pixel sono neri e non mostrano alcuna immagine; quando lo accendi, l’energia del catodo colpisce i pixel e li rende visibili. Tutto ciò che vedi, all’interno dello schermo, però, è illusorio. O meglio: esiste, ma non è ciò che sembra. Gli elementi delle finestre non sono tridimensionali, anche se hanno delle ombre e quando vedi il puntatore del mouse spostarsi da una finestra all’altra in realtà stai vedendo i pixel dello schermo che cambiano di colore È un’illusione auto-indotta e volontaria: il tuo cervello vede qualcosa, ma finge che sia altro, perché è più comodo così.<br />
La stessa cosa avviene con gli spazioni, solo che invece di essere disposti su una superficie piana, come i pixel dello schermo, gli spazioni sono una matrice tridimensionale e hanno quella che il Maestro Canaro definiva: “esistenza potenziale”; se sono irradiati di energia, acquisiscono massa e quindi esistenza, altrimenti non esistono. Quando il <em>Big Bang</em> irradia la sua Energia nell’Universo, questa colpisce gli spazioni dando loro una massa e generando tutto ciò che esiste, dagli atomi di elio della nebulosa di <em>Wolf–Rayet</em> alla tua maestra delle Elementari.<br />
Così come un <code>char</code>, <code>double</code> o <code>class</code> sono solo dei nomi convenzionali per degli insiemi di bit, anche <code>elio</code>, <code>tungsteno</code> o <code>cocomero</code> sono nomi convenzionali per delle quantità di energia. <em>Energia</em>, bada bene, non <em>spazioni</em>, perché gli spazioni sono fissi; quella che si muove è l’Energia. Quando tu sposti il braccio come hai fatto adesso, non stai realmente spostando il braccio, ma trasferendo l’energia che costituiva il tuo braccio da un gruppo di spazioni a un altro. E anche se restiamo immobili, qui, in questa stanza, l’energia di cui siamo costituiti continua a trasferirsi nella matrice degli spazioni perché il Pianeta in cui viviamo ruota intorno al suo asse e intorno al Sole; il Sole ruota intorno alla Via Lattea e la Via Lattea si muove a sua volta rispetto alle altre galassie. Né io né te siamo, adesso, costituiti dagli stessi spazioni che eravamo pochi secondi fa. Siamo un’immagine in movimento, come il puntatore del mouse, o come le luci delle decorazioni natalizie. Come disse Sant’Agostino, siamo, allo stesso tempo, reali e illusorii:</p>
<blockquote>
<p>E considerai tutte le cose che sono al di sotto di te e vidi che non si può dire in modo assoluto né che esistono né che non esistono: a loro modo esistono, perché derivano da te, non esistono perché non sono ciò che sei tu: ed esiste veramente ciò che permane immutabile. <a href="/man/note/#agostino" class="nota"></a></p>
</blockquote>
<p>Per i <em>Vedanta</em>, il Mondo ha la natura dell’Arte perché la realtà dell’arte-fatto è differente dalla realtà dell’arte-fice. Questa similitudine, oltre che per Platone, è valida anche per i linguaggi di programmazione: un oggetto all’interno di un programma esiste, ma non è realmente ciò che rappresenta, anche se a noi fa comodo ritenerlo tale. Come scrisse Ezra Pound<a href="/man/note/#pound" id="pound" class="nota"></a>, solo i sogni esistono realmente, perché la loro natura irreale rimane tale anche in una realtà illusoria.</p>
<hr />
<p>Gli spazioni definiscono anche i limiti delle nostre grandezze e delle nostre unità di misura. Pensa a una retta: teoricamente, è un insieme infinito di punti che si estende in due direzioni. I punti, però, sono privi di dimensione, quindi, per fare anche solo un piccolo tratto di retta, ne serve un numero infinito. In sostanza, secondo i matematici, in ciascuna retta coesistono due forme di infinito: quello sincategorematico della lunghezza e quello categoriematico della sequenza di punti. (O forse il contrario: non mi ricordo mai qual’è l’infinito in atto e quale quello potenziale.) Capisci bene che questa è una panzana: l’idea che se moltiplichi all’infinito il nulla tu possa ottenere qualcosa è solo un tentativo dei matematici di giustificare la loro vita sessuale.<br />
La retta è la rappresentazione ideale di un insieme finito di spazioni contigui. È molto, molto sottile, ma una dimensione ce l’ha. Anche il piano, con buona pace di René Guenon, è costituito da un insieme finito di spazioni contigui e per un singolo punto non passano infinite rette, ma un numero finito, per quanto alto, perché la granularità degli spazioni limita il numero delle possibili angolazioni. Stesso discorso vale per i numeri naturali: non li si può estendere all’infinito, ma solo fino al numero totale di spazioni attivi nell’Universo, perché qualsiasi numero superiore indicherebbe una quantità che non esiste e sarebbe quindi insensato.<br />
Gli spazioni definiscono anche l’unità minima di tempo, quella che il Maestro Canaro definiva scherzosamente lo “spazione-tempo”, ovvero l’intervallo di tempo necessario a uno spazione per acquisire tutta l’energia di uno degli spazioni con cui è a contatto. È questo il motivo per cui la velocità luce non può superare i trecento milioni di metri al secondo: perché è limitata dal tempo di trasferimento dell’energia fra gli spazioni.</p>
<hr />
<p>Anche il C’hi++ ritiene simili il Mondo e l’Arte, ma non solo per la loro natura. Il Mondo e l’Arte sono simili perché il loro scòpo è lo stesso.</p>
</section>
</section>
<a href="/man/commenti" class="left" title="Vai a: I commenti"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/struttura-dei-programmi" class="right" title="Vai a: Struttura dei programmi C++"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/tipi-di-dato" class="left" title="Vai a: I tipi di dato"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/operatori" class="right" title="Vai a: Gli operatori"><em></em></a>
<section id="struttura-dei-programmi-c-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Struttura dei programmi C++</a></h1>
<blockquote>
Wer den Computer will verstehen,<br />
Muss in Computers Lande gehen
</blockquote>
<section class="testo">
<p>La libertà sintattica e la concisione dei costrutti sono la caratteristica principale del C++.</p>
<p>Il C++, come tutti i linguaggi, ha una sua sintassi che definisce gli elementi del codice e il loro utilizzo all’interno dei programmi. Negli esempii che abbiamo visto finora, ho utilizzato alcuni di questi elementi senza spiegarti precisamente quale sia il loro ruolo, perché volevo darti un quadro d’insieme delle caratteristiche del linguaggio. Un po’ come quando arrivi a una festa e ti presentano gli altri invitati uno dietro l’altro e alla fine l’unica cosa che ti ricordi è il decolleté delle signore. Adesso però, dobbiamo fare un passo indietro ed esaminare questi elementi a uno a uno, cominciando da quello che è l’elemento principale di ciascun programma C++, ovvero la funzione <code>main</code>.</p>
<pre><code>int main(int argc, char** argv)
{    
    return 0;
}</code></pre>
<p>Quello qui sopra è il più piccolo programma in C++ che tu possa scrivere. È anche il più inutile, però, perché non fa nulla.<br />
L’esempio qui sotto è altrettanto inutile, ma un po’ più complesso:</p>
<pre><code>/** 
 * @file src/struttura-hello-world.cpp
 * Esempio minimo di programma C++.
 */
 
#include &lt;iostream&gt;

int main(int argc, char** argv)
{    
    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>Il suo output, come forse avrai intuito, è:</p>
<pre><code>% g++ struttura-hello-world.cpp -o ../out/esempio
% ../out/esempio 
Hello, World!</code></pre>
<p>La prima linea di codice:</p>
<pre><code>#include &lt;iostream&gt;</code></pre>
<p>non è un’istruzione, ma una direttiva per il preprocessore. Il preprocessore è un programma che elabora il codice e lo prepara per la compilazione, ne parleremo <a href="/man/preprocessore">in seguito</a>. Per il momento, ti basta sapere che questa istruzione fa sì che nel codice venga incluso il file <code>iostream.h</code>, che contiene, fra le altre cose, la dichiarazione dello <em>stream</em> <code>cout</code>, utilizzato nell’unica istruzione del programma.<br />
La seconda linea di codice:</p>
<pre><code>int main(int argc, char** argv)</code></pre>
<p>definisce la funzione <code>main</code>, specificando che avrà come valore di ritorno un <code>int</code> e due parametri: un intero e un puntatore a puntatori a <code>char</code>. Questi valori servono a gestire i parametri passati da riga di comando: l’intero <code>argc</code> (crasi di: <em>argument count</em>), specifica il numero di parametri presenti nella chiamata, nome del programma compreso, mentre il parametro <code>argv</code> (<em>argument vector</em>) è un array di puntatori a tutte le stringhe presenti nella linea di comando.<br />
Il corpo della funzione è racchiuso in una coppia di parentesi graffe <code>{}</code>. L’istruzione:</p>
<pre><code>std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</code></pre>
<p>scrive la stringa <code>Hello World!</code> sullo <em>stream</em> <code>std::cout</code> (<em>standard character output</em>), che solitamente corrisponde allo schermo del computer. L’operatore <code>&lt;&lt;</code>, in questo caso, notifica al sistema di inviare in output quanto si trova alla sua destra e torna una <em>reference</em> allo stream di output, in modo da poter essere ripetuto su una st­essa linea di codice, che è una forma più efficiente ed elegante di:</p>
<pre><code>std::cout &lt;&lt; &quot;Hello, World!&quot; ;
std::cout &lt;&lt; std::endl;</code></pre>
<p>Infine, l’istruzione:</p>
<pre><code>return 0;</code></pre>
<p>torna il valore <code>0</code> al programma chiamante (di solito, la <em>shell</em> del computer) per indicare l’assenza di errori nell’elaborazione. Il programma seguente mette in pratica i concetti visti finora:</p>
<pre><code>#include &lt;iostream&gt;

#define NO_ERRORI     0
#define NO_PARAMETRI  1

int main(int argc, char** argv)
{    
    int errore = NO_ERRORI;
    
    /** Se c&#39;è solo il nome del programma, errore */
    if(argc &lt; 2) {
        std::cerr &lt;&lt; &quot;Specificare un parametro!&quot; &lt;&lt; std::endl;
        return NO_PARAMETRI;
    }

    /** Stampa tutti i parametri ricevuti */
    for(int p=0; p &lt; argc; p++) {
        std::cout &lt;&lt; *argv++ &lt;&lt; std::endl;        
    }

    return 0;
}
</code></pre>
<p>Come ti ho detto, il C++ è un linguaggio <em>compilato</em>, quindi il codice, per poter essere eseguito, deve essere elaborato dal complilatore con il comando della <em>shell</em>:</p>
<pre><code>% g++ struttura-argc-argv.cpp -o src/out/esempio</code></pre>
<p>Il parametro <code>-o</code>permette di specificare il nome del file di output, in questo caso: <code>src/out/esempio</code>. Se non si defiisce questo valore, il compilatore genera un file di nome <code>a.out</code>.<br />
Il comando <em>shell</em>:</p>
<pre><code>% src/out/esempio; echo $?                                  </code></pre>
<p>è composto di due istruzioni, separate dal carattere <code>;</code>. La prima sitruzione esegue il file compilato; la seconda stampa a video il suo valore di ritorno. Se eseguiamo il programma senza parametri, otteniamo un messaggio e il codice di errore <code>1</code>:</p>
<pre><code>Specificare un parametro!
1</code></pre>
<p>Se invece eseguiamo il programma passandogli dei parametri, otteniamo questo:</p>
<pre><code>% src/out/esempio un due tre; echo $?
src/out/esempio
un
due
tre
0</code></pre>
<hr />
<p>Nessun programma degno di questo nome ha solo la funzione <code>main</code>, ma suddivide il suo lavoro in una serie di funzioni che svolgono compiti precisi e ben definiti. In un programma ben scritto, le funzioni presentano due caratteristiche, che gli anglosassoni e gli anglofili definiscono: <em>low coupling</em> e <em>high cohesion</em>.<br />
Con il termine <em>accoppiamento</em> di due funzioni si intende la quantità di informazioni che la funzione <em>A</em> deve avere riguardo la funzione <em>B</em> per poterla utlizzare. Ciascuna funzione si aspetta di ricevere una serie ben definita di parametri: la funzione <code>raddoppiaStipendio</code>, che abbiamo visto prima, si aspetta di ricevere un solo parametro, di tipo <code>long</code>:</p>
<pre><code>long raddoppiaStipendio(long stipendio);</code></pre>
<p>mentre un’ipotetica funzione <code>scorporaIVA</code> potrebbe richiederne due; l’importo dello stipendio e l’aliquota IVA:</p>
<pre><code>float scorporaIVA(long stipendio, float aliquota);</code></pre>
<p>In entrambi questi casi, tutto ciò di cui ha bisogno una terza funzione per richiamare <code>raddoppiaStipendio</code> o <code>scorporaIVA</code> è la la loro <em>interfaccia</em>, ovvero il numero, il tipo e l’ordine dei parametri da passare. Ora immagina che un programmatore maldestro abbia scritto la funzione <code>facciQualcosa</code> che può compiere più azioni distinte, in base ai parametri ricevuti:</p>
<pre><code>float facciQualcosa(long stipendio, int azione, float aliquota = 0)
{
    float valore = 0;
    /** Differenzia l&#39;azione in base al valore di azione */
    if(azione == 1) {
        valore = stipendio * 2;
    } else if(azione == 2) {
        valore = stipendio / ((100 + aliquota) / 100);
    }
    return valore;
}</code></pre>
<p>Per poter utilizzare questa funzione, non solo dobbiamo conoscere la sua interfaccia, ma dobbiamo anche sapere quali azioni corrispondono ai diversi valori del parametro <code>azione</code>. Questa è follia, <em>meshuggah</em>, perché, se un giorno l’autore la modificasse e decidesse che il valore <code>1</code> del parametro <code>azione</code> causa lo scorporo dell’IVA mentre il valore <code>2</code> causa il raddoppio dello stipendio, noi dovremmo modificare anche <em>tutte</em> le funzioni che l’hanno chiamata per adattarle alle nuove regole. Non solo perderemmo del tempo, ma se dimenticassimo di aggiornare una o più chiamate otterremmo un programma con un funzionamento errato.<br />
Il <em>coupling</em> è come il colesterlolo: più è basso, meglio è; quindi, per evitare errori, dobbiamo ridurlo, creando un <code>enum</code> a cui assegnare i possibili valori del parametro <code>azione</code>:</p>
<pre><code>enum Azione { raddoppia, scorpora }; </code></pre>
<p>Come spesso avviene, una singola riga di codice ben scritto ci permette di risparmiare tempo e di ottenere del codice più robusto, perché l’effetto del parametro <code>azione</code>, in questo modo, sarà del tutto indipendente dal suo valore numerico:</p>
<pre><code>enum Azione { raddoppia, scorpora }; 

float facciQualcosa(long stipendio, Azione azione, float aliquota = 0)
{
    float valore = 0;
    /** Agisce in base all&#39;etichetta, non al valore */
    if(azione == raddoppia) {
        valore = stipendio * 2;
    } else if(azione == scorpora) {
        valore = stipendio / ((100 + aliquota) / 100);
    }    
    return valore;
}</code></pre>
<p>La funzione <code>facciQualcosa</code> ha anche un altro difetto progettuale, oltre all’alto accoppiamento: manca di coesione interna. In un programma ben scritto, ciascuna funzione deve avere solo una.. funzione:</p>
<pre><code>inline long raddoppiaStipendio(long stipendio)
{
    return stipendio * 2;
}

inline float scorporaIVA(long stipendio, float aliquota)
{
    return (stipendio / ((100 + aliquota) / 100);
}</code></pre>
<p>Anche in un esempio così semplice, vedi bene che differenza ci sia, fra una funzione che può svolgere più azioni eterogenee e una funzione che svolge una singola azione, ben precisa. Riducendo la complessità della funzione, inoltre, abbiamo la possibilità di dichiararla come <a href="/man/funzioni#inline" class="xref">inline</a>, aumentando la velocità di esecuzuione del programma.</p>
<hr />
<p>La funzione <code>main</code> del C’hi++ è quello che gli scienziati chiamano: <em>Big Bang</em>. Così come l’atmosfera è agitata dallo scontro di masse di aria calda e fredda, l’Energia dell’Universo è costantemente sottoposta all’azione contrapposta di due forze: <em>Gravità</em>, che tende ad accorpare tutta la materia nell’Uno primgenio ed <em>Entropia</em>, che al contrario, tende a dividere. Poe lo aveva capito. In: <em>Eureka</em>, usa il termine <em>Elettricità</em> invece di: <em>Entropia</em>, ma la contrapposizione che descrive è corretta.<br />
Ciò che non è corretto (e non solo in Poe) è l’idea che l’espansione dell’Universo sia un evento unico. La vita dell’Universo è ciclica: quando è preponderante l’Entropia, l’Universo si espande, come in questo momento; quando “vince” la Gravità, l’Universo collassa su sé stesso e torna all’Uno. Ciò che evita la stasi in uno dei due punti estremi del ciclo — l’Uno e la morte termica — è una terza forza, che il Maestro Canaro chiamava: <a href="/man/mitopoietica#annosa-dicotomia"><em>l’annosa dicotomia fra ciò che desideriamo è ciò di cui abbiamo bisogno</em></a>.<br />
Così come una scatola di mattoncini Lego contiene tutti gli edifici che hai costruito e che costruirai in futuro, nell’Uno primigenio è concentrata tutta l’Energia dell’Universo e quindi ogni essere animato o inanimato che sia mai esistito o che mai esisterà. La Gravità è al suo punto estremo e una non-esistenza scorre in un non-tempo, che non può essere misurato perché non esistono eventi in base a cui farlo.<a href="/man/note#non-tempo" class="nota"></a> Non ci sono né morte, né sofferenza, né malattia, né separazione; l’Uno è, di fatto, ciò che la maggior parte degli esseri senzienti descrive e auspica come un Universo perfetto.<br />
L’Energia, inizialmente, è soddisfatta, ma a poco a poco l’appagamento per la raggiunta Unità scema e cresce invece il desiderio di qualcosa di diverso da quella cristallina perfezione. Così come di un vecchio amore si ricoda solo ciò che ci fa piacere ricordare, obliando ciò che non andava, l’Energia ripensa a quando l’Universo non era buio e vuoto, ma risplendeva della luce di innumerevoli stelle e si chiede se, in fondo, non sia quella, l’esistenza a cui ambisce, se non sia quello, in effetti, il Paradiso.<br />
Ha una chiara memoria degli errori e dei dolori delle passate esistenze (è stata lei, incarnata negli spazioni ad averli commessi), ma, come uno scacchista che debba giocare nuovamente una determinata apertura, pensa che stavolta andrà meglio, che non ripeterà gli sbagli fatti in precedenza e questo desiderio di un riscatto genera il <em>Big Bang</em>. L’Energia disintegra l’enorme buco nero in cui si era rannicchiata e si espande di nuovo nell’Universo, dando massa agli spazioni e generando la materia. L’Era della Gravità finisce e comincia una nuova Era dell’Entropia; qualcosa di molto simile a quello che trovi descritto nella <em>Bhagavad-Gita</em>:</p>
<blockquote>
<p>I cicli cosmici sono periodi temporali chiamati Manvantara, suddivisi al proprio interno in quattro ere o Yuga, ciascuna caratterizzata da una particolare qualità dell’esistenza. Si tratta di un ritorno periodico a condizioni di vita non uguali ma analoghe, da un punto di vista qualitativo, a quelle dei cicli precedenti, una successione di quattro ere che ricorda, su scala ridotta, l’alternarsi delle quattro stagioni.<a href="/man/note/#cicli" class="nota"></a></p>
</blockquote>
<p>Anche la Genesi biblica può essere considerata un’allegoria della cosmogonia spazionista (o viceversa): il Paradiso è l’Uno primigenio, mentre Adamo (<em>Puruṣa</em>) ed Eva (<em>Prakṛti</em>) sono ciò che ne causa la disgregazione, generando un Universo imperfetto e doloroso, aiutati dal <em>διάβολος</em>, ovvero da colui che <em>separa</em> o <em>scaglia attraverso</em>, altrimenti noto come: <em>Luci-fero</em>.<br />
In ottica spazionista, la domanda:</p>
<blockquote>
<p>Perché, se Dio è buono, nell’Universo che ha creato esistono il male e il dolore?</p>
</blockquote>
<p>non ha senso, perché non è Dio ad aver creato l’Universo, ma il Diavolo, così come sostenevano i Barbelognostici.</p>
<hr />
<p>Una volta, un discepolo chiese al Maestro Canaro come fosse possibile che l’Energia dell’universo avesse dei sentimenti o delle aspirazioni e se questa auto-coscienza non contrastava con l’idea che il C’hi++ sia una metafisica priva di elementi metafisici. Il Maestro Canaro rispose che il discepolo aveva ragione (un modo ellittico per dire che era un idiota). A lui piaceva credere che fosse così perché era un vecchio sentimentale, ma il discepolo era libero di pensare che fosse solo un artificio retorico, sfruttato per rendere più coinvolgente la narrazione. Spiegò poi che l’unica cosa in cui era necessario credere, anche in assenza di prove, è che l’Universo, alla fine di questa fase di espansione, sarebbe tornato a collassare nell’Uno.<br />
A quel punto, i casi sarebbero stati due: o sarebbe rimasto Uno per il resto del Tempo (ipotesi lecita, ma noiosa) oppure sarebbe esploso di nuovo, dando vita a un nuovo Universo. Anche in questo caso le ipotesi sarebbero state due. La prima è che un Big Bang possa avvenire solo in determinate condizioni e che quelle condizioni portino necessariamente a un Universo identico a quello come noi lo conosciamo adesso; quindi, se l’Uno esploderà di nuovo, ricomincerà tutto da capo. La seconda ipotesi è che ogni <em>Big Bang</em> avviene in circostanze e con modalità specifiche e che quindi, se l’Uno esploderà di nuovo, nascerà un nuovo Universo, che potrà avere pochi o nessun punto di contatto con quello corrente.<br />
Il Maestro Canaro disse che la prima ipotesi era possibile, ma poco probabile e che quindi avremmo dato per scontato che fosse la seconda, quella corretta: «Tanto, non cambia niente: se il tempo che abbiamo a disposizione per far esplodere e implodere l’Universo è infinito, per quanto bassa possa essere la probabilità che si verifichino due esplosioni uguali è impossibile che la cosa o prima o poi non avvenga. Come dice quel senza-Dio di Dawkins:</p>
<blockquote>
<p>Dato un tempo infinito o un numero di opportunità infinite, è possibile qualsiasi cosa.<a href="/man/note#dawkins-tempo" class="nota"></a></p>
</blockquote>
<p>In base allo stesso principio, dando per scontato che o prima o poi questo Universo tornerà a manifestarsi, è del tutto lecito pensare — non per fede, ma in base a un banale calcolo probabilistico — che anche ciò che c’è in esso possa o prima o poi tornare a essere. Noi compresi».</p>
</section>
</section>
<a href="/man/tipi-di-dato" class="left" title="Vai a: I tipi di dato"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/operatori" class="right" title="Vai a: Gli operatori"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/struttura-dei-programmi" class="left" title="Vai a: Struttura dei programmi C++"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/preprocessore" class="right" title="Vai a: Il preprocessore"><em></em></a>
<section id="gli-operatori-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Gli operatori</a></h1>
<blockquote>
question = 2b | ( ! 2b );
</blockquote>
<section class="testo">
<p>La varietà e soprattutto l’adattabilità degli operatori sono la caratteristica principale del C++.</p>
<p>Gli operatori sono degli elementi del linguaggio che permettono, appunto, di <em>operare</em> delle azioni sulle variabili o sui valori. Li possiamo classificare o in base al numero di operandi su cui agiscono:</p>
<ul>
<li>primarii</li>
<li>unarii</li>
<li>binarii</li>
<li>ternarii</li>
</ul>
<p>o, in maniera più funzionale al tuo libro, in base al tipo di operazione che compiono:</p>
<ul>
<li>aritmetici</li>
<li>logici</li>
<li>di relazione</li>
<li>bitwise</li>
<li>assegnazione</li>
</ul>
<p>Gli operatori <em>aritmetici</em> sono quelli che permettono di eseguire delle comuni operazioni di addizione, sottrazione, divisione o moltiplicazione sulle variabili:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">nome</th>
<th style="text-align: center;">descrizione</th>
<th style="text-align: center;">esempio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">+</td>
<td style="text-align: center;">addizione</td>
<td style="text-align: center;">x + y</td>
</tr>
<tr class="even">
<td style="text-align: center;">-</td>
<td style="text-align: center;">sottrazione</td>
<td style="text-align: center;">x - y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: center;">moltiplicazione</td>
<td style="text-align: center;">x * y</td>
</tr>
<tr class="even">
<td style="text-align: center;">\</td>
<td style="text-align: center;">divisione</td>
<td style="text-align: center;">x / y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">%</td>
<td style="text-align: center;">modulo</td>
<td style="text-align: center;">x % y</td>
</tr>
<tr class="even">
<td style="text-align: center;">++</td>
<td style="text-align: center;">incremento</td>
<td style="text-align: center;">x++</td>
</tr>
<tr class="odd">
<td style="text-align: center;">–</td>
<td style="text-align: center;">decremento</td>
<td style="text-align: center;">y–</td>
</tr>
</tbody>
</table>
<p>L’operatore modulo <code>%</code> permette di calcolare il resto della divisione fra due interi (per esempio: <code>15 % 4 = 3</code>) e non può essere utilizzato con numeri in virgola mobile.<br />
Gli operatori di incremento <code>++</code> e decremento <code>--</code> permettono di aumentare o di diminuire di un’unità il valore di una variabile. Quando questi operatori precedono la variabile, l’incremento o il decremento è calcolato immediatamente; se invece compaiono dopo la variabile, l’operazione di incremento o decremento avviene dopo il suo utilizzo:</p>
<pre><code>/** 
 * @file _man/src/operatori-pre-post.cpp
 * Utilizzo degli operatori di incremento e decremento.
 */

#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{   
    /** Definizione delle due variabili */
    int pre  = 5, post = 7; 

    /** Operatore di incremento, prima e dopo la variabile */
    cout &lt;&lt; &quot;pre-incremento: &quot; &lt;&lt; ++pre  &lt;&lt; endl;
    cout &lt;&lt; &quot;post-incremento:&quot; &lt;&lt; post++ &lt;&lt; endl;

    /** Operatore di decremento, prima e dopo la variabile */
    cout &lt;&lt; &quot;pre-decremento: &quot; &lt;&lt; --pre  &lt;&lt; endl;
    cout &lt;&lt; &quot;post-decremento:&quot; &lt;&lt; post-- &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/operatori-pre-post.cpp -o src/out/esempio 
&gt; src/out/esempio                                       
pre-incremento: 6
post-incremento:7
pre-decremento: 5
post-decremento:8</code></pre>
<p>Gli operatori <em>di relazione</em> permettono di verificare il rapporto fra due variabili:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">nome</th>
<th style="text-align: center;">descrizione</th>
<th style="text-align: center;">esempio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">==</td>
<td style="text-align: center;">uguaglianza</td>
<td style="text-align: center;">x == x</td>
</tr>
<tr class="even">
<td style="text-align: center;">!=</td>
<td style="text-align: center;">differenza</td>
<td style="text-align: center;">x != y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">maggiore di</td>
<td style="text-align: center;">x &gt; y</td>
</tr>
<tr class="even">
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">minore di</td>
<td style="text-align: center;">x &lt; y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&gt;=</td>
<td style="text-align: center;">maggiore o uguale a</td>
<td style="text-align: center;">x &gt;= y</td>
</tr>
<tr class="even">
<td style="text-align: center;">&lt;=</td>
<td style="text-align: center;">minore o uguale a</td>
<td style="text-align: center;">x &lt;= y</td>
</tr>
</tbody>
</table>
<p>Questi operatori tornano un valore booleano, vero o falso a seconda che la condizione sia verificata o no.<br />
L’operatore <code>==</code> torna <code>true</code> se gli operandi sono uguali, come nel verso:</p>
<blockquote>
<p>Io vidi il mio Signore con l’occhio del cuore.<br />
Gli chiesi: Chi sei?<br />
Rispose: Te! <a href="/man/note#attar" class="nota"></a></p>
</blockquote>
<p>L’operatore <code>!=</code> torna <code>true</code> se gli operandi non sono uguali; gli operatori <code>&gt;</code> e <code>&lt;</code> tornano <code>true</code>, rispettivamente, se l’operatore a sinistra è maggiore o minore dell’operando a destra; gli operatori <code>&gt;=</code> e <code>&lt;=</code> tornano <code>true</code> se l’operando a sinistra è maggiore o uguale oppure minore o uguale a quello a destra.<br />
Gli operatori <em>logici</em> permettono di compiere delle operazioni di logica booleana sulle variabili:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">nome</th>
<th style="text-align: center;">descrizione</th>
<th style="text-align: center;">esempio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">&amp;&amp;</td>
<td style="text-align: center;">AND logico</td>
<td style="text-align: center;">x &amp;&amp; y</td>
</tr>
<tr class="even">
<td style="text-align: center;">||</td>
<td style="text-align: center;">OR logico</td>
<td style="text-align: center;">x || y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">!</td>
<td style="text-align: center;">NOT logico</td>
<td style="text-align: center;">!(x &amp;&amp; y)</td>
</tr>
</tbody>
</table>
<p>L’operatore <code>&amp;&amp;</code> torna <code>true</code> se entrambe le variabili sono <code>true</code>; l’operatore <code>||</code> torna <code>true</code> se almeno una delle variabili è <code>true</code>; l’operatore <code>!</code> inverte il valore dell’operando: se è <code>true</code>, torna <code>false</code> e viceversa.<br />
Gli operatori binarii, o: <em>bitwise</em> permettono di effettuare delle operazioni sui valori binarii delle variabili:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">nome</th>
<th style="text-align: center;">descrizione</th>
<th style="text-align: center;">esempio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">&amp;</td>
<td style="text-align: center;">AND</td>
<td style="text-align: center;">x &amp; y</td>
</tr>
<tr class="even">
<td style="text-align: center;">|</td>
<td style="text-align: center;">OR (inclusivo)</td>
<td style="text-align: center;">x | y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">^</td>
<td style="text-align: center;">XOR (esclusivo)</td>
<td style="text-align: center;">x ^ y</td>
</tr>
<tr class="even">
<td style="text-align: center;">~</td>
<td style="text-align: center;">NOT</td>
<td style="text-align: center;">x ~ y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">»</td>
<td style="text-align: center;">shift a destra</td>
<td style="text-align: center;">x » y</td>
</tr>
<tr class="even">
<td style="text-align: center;">«</td>
<td style="text-align: center;">shift a sinistra</td>
<td style="text-align: center;">x « y</td>
</tr>
</tbody>
</table>
<p>L’operatore <code>&amp;</code> imposta a 1 un bit nel risultato se quel bit è 1 in entrambi gli operandi. L’operatore <code>|</code> imposta a 1 un bit nel risultato se quel bit è 1 in uno dei due operandi. L’operatore <code>^</code> imposta a 1 un bit nel risultato se quel bit è 1 in uno dei due operandi, ma non nell’altro. L’operatore <code>~</code> inverte i bit dell’operando. Gli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code> spostano rispettivamente a sinistra e a destra i bit dell’operando di destra per il numero di bit specificato dall’operando di destra.<br />
Gli operatori <em>di assegnazione</em> eseguono le operazioni che abbiamo visto finora e, in più, assegnano il valore risultante all’operando di sinistra:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">nome</th>
<th style="text-align: center;">descrizione</th>
<th style="text-align: center;">esempio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">=</td>
<td style="text-align: center;">uguaglianza</td>
<td style="text-align: center;">x = x</td>
</tr>
<tr class="even">
<td style="text-align: center;">+=</td>
<td style="text-align: center;">somma</td>
<td style="text-align: center;">x += y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-=</td>
<td style="text-align: center;">differenza</td>
<td style="text-align: center;">x -= y</td>
</tr>
<tr class="even">
<td style="text-align: center;">*=</td>
<td style="text-align: center;">moltiplicazione</td>
<td style="text-align: center;">x *= y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/=</td>
<td style="text-align: center;">divisione</td>
<td style="text-align: center;">x /= y</td>
</tr>
<tr class="even">
<td style="text-align: center;">%=</td>
<td style="text-align: center;">modulo</td>
<td style="text-align: center;">x %= y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&amp;=</td>
<td style="text-align: center;">AND</td>
<td style="text-align: center;">x &amp;= y</td>
</tr>
<tr class="even">
<td style="text-align: center;">|=</td>
<td style="text-align: center;">OR inclusivo</td>
<td style="text-align: center;">x |= y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">^=</td>
<td style="text-align: center;">OR esclusivo</td>
<td style="text-align: center;">x ^= y</td>
</tr>
<tr class="even">
<td style="text-align: center;">»=</td>
<td style="text-align: center;">shift a destra</td>
<td style="text-align: center;">x &lt;= y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">«=</td>
<td style="text-align: center;">shift a sinistra</td>
<td style="text-align: center;">x &lt;= y</td>
</tr>
</tbody>
</table>
<p>Per esempio, l’esperessione:</p>
<pre><code>x *= y</code></pre>
<p>equivale a:</p>
<pre><code>x = (x * y);</code></pre>
<p>Il prossimo esempio mostra l’utilizzo e il risultato di ciascun operatore:</p>
<pre><code>/** 
 * @file operatori-utilizzo.cpp
 * Esempio di utilizzo degli operatori.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;bitset&gt; 

using namespace std;

int main(int argc, char** argv)
{        
    int x = 12;
    int y = 4;

    cout &lt;&lt; &quot;Operatori aritmetici&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;x + y = &quot; &lt;&lt; x + y &lt;&lt; endl;
    cout &lt;&lt; &quot;x - y = &quot; &lt;&lt; x - y &lt;&lt; endl;
    cout &lt;&lt; &quot;x * y = &quot; &lt;&lt; x * y &lt;&lt; endl;
    cout &lt;&lt; &quot;x / y = &quot; &lt;&lt; x / y &lt;&lt; endl;
    cout &lt;&lt; &quot;x % y = &quot; &lt;&lt; x % y &lt;&lt; endl;
    cout &lt;&lt; &quot;x++   = &quot; &lt;&lt; x++ &lt;&lt; endl;
    cout &lt;&lt; &quot;x--   = &quot; &lt;&lt; x-- &lt;&lt; endl;
    cout &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Operatori logici&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;x &amp;&amp; y    = &quot; &lt;&lt; (x &amp;&amp; y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x || y    = &quot; &lt;&lt; (x || y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;!(x &amp;&amp; y) = &quot; &lt;&lt; !(x &amp;&amp; y) &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;Operatori di relazione&quot;  &lt;&lt; endl;
    cout &lt;&lt; &quot;x == y = &quot; &lt;&lt; (x == y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x != y = &quot; &lt;&lt; (x != y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x &gt; y  = &quot; &lt;&lt; (x  &gt; y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x &lt; y  = &quot; &lt;&lt; (x  &lt; y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x &gt;= y = &quot; &lt;&lt; (x &gt;= y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x &lt;= y = &quot; &lt;&lt; (x &lt;= y)  &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;Operatori bitwise&quot;  &lt;&lt; endl;
    cout &lt;&lt; &quot;bit x  = &quot; &lt;&lt; bitset&lt;8&gt;(x) &lt;&lt; endl;
    cout &lt;&lt; &quot;bit y  = &quot; &lt;&lt; bitset&lt;8&gt;(y) &lt;&lt; endl;
    cout &lt;&lt; &quot;x &amp; y  = &quot; &lt;&lt; bitset&lt;8&gt;(x &amp; y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x | y  = &quot; &lt;&lt; bitset&lt;8&gt;(x | y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x ^ y  = &quot; &lt;&lt; bitset&lt;8&gt;(x ^ y)  &lt;&lt; endl;
    cout &lt;&lt; &quot;x ~ y  = &quot; &lt;&lt; bitset&lt;8&gt;(~ y)    &lt;&lt; endl;
    cout &lt;&lt; &quot;x &gt;&gt; y = &quot; &lt;&lt; bitset&lt;8&gt;(x &gt;&gt; y) &lt;&lt; endl;
    cout &lt;&lt; &quot;x &lt;&lt; y = &quot; &lt;&lt; bitset&lt;8&gt;(x &lt;&lt; y) &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;Operatori di assegnazione&quot;  &lt;&lt; endl;
    cout &lt;&lt; &quot;x += y = &quot; &lt;&lt; (x += y) &lt;&lt; endl;
    cout &lt;&lt; &quot;x -= y = &quot; &lt;&lt; (x -= y) &lt;&lt; endl;
    cout &lt;&lt; &quot;x *= y = &quot; &lt;&lt; (x *= y) &lt;&lt; endl;
    cout &lt;&lt; &quot;x /= y = &quot; &lt;&lt; (x /= y) &lt;&lt; endl;
    cout &lt;&lt; &quot;x %= y = &quot; &lt;&lt; (x %= y) &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/operatori-utilizzo.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Operatori aritmetici
x + y = 16
x - y = 8
x * y = 48
x / y = 3
x % y = 0
x++   = 12
x--   = 13

Operatori logici
x &amp;&amp; y    = 1
x || y    = 1
!(x &amp;&amp; y) = 0

Operatori di relazione
x == y = 0
x != y = 1
x &gt; y  = 1
x &lt; y  = 0
x &gt;= y = 1
x &lt;= y = 0

Operatori bitwise
bit x  = 00001100
bit y  = 00000100
x &amp; y  = 00000100
x | y  = 00001100
x ^ y  = 00001000
x ~ y  = 11111011
x &gt;&gt; y = 00000000
x &lt;&lt; y = 11000000

Operatori di assegnazione
x += y = 16
x -= y = 12
x *= y = 48
x /= y = 12
x %= y = 0
</code></pre>
<p>Adesso dimmi: quanto valgono, le variabili <code>x</code> e <code>y</code>, alla fine del programma?</p>
<hr />
<p>Sono degli operatori anche i simboli: <code>sizeof</code>, <code>,</code>, <code>.</code>, <code>-&gt;</code>, <code>&amp;</code>, <code>*</code>, <code>()</code> e <code>()?:</code>. L’operatore <code>sizeof</code> lo abbiamo già visto parlando della <a href="/man/tipi-di-dato#sizeof">dimensione dei tipi di dato</a>, perché torna, appunto, la dimensione, in byte, della variabile o del tipo di dato che riceve come parametro.<br />
L’operatore di <em>cast</em> <code>()</code> permette di modificare il tipo di una variabile e lo abbiamo già utilizzato nella classe <code>Animale</code>, quando abbiamo parlato del <a href="/man/c-plus-plus#cast">polimorfismo</a>:</p>
<pre><code>const char getSesso() const {        
    return (char)_sesso;
} </code></pre>
<p>L’operatore condizionale <code>()?:</code> è l’unico operatore ternario del C++ e permette di scegliere fra due espressioni a seconda dell’esito di una condizione. La sua sintassi è:</p>
<pre><code>(&lt;condizione&gt;) ? &lt;istruzione vero&gt; : &lt;istruzione falso&gt;</code></pre>
<p>Scrivere:</p>
<pre><code>x = (a &gt; b) ? 4 : 5;</code></pre>
<p>è un modo elegante di scrivere:</p>
<pre><code>if(a &gt; b) {
    x = 4;
} else {
    x = 5;
}</code></pre>
<p>L’operatore virgola <code>,</code> serve ad alterare il modo in cui vengono valutate le espressioni. Quando due o più espressioni sono separate dall’operatore virgola, i risultati delle espressioni a sinistra sono ignorati e viene mantenuto solo il risultato dell’espressione più a destra. In questa espressione, per esempio, alle variabili <code>a</code> e <code>b</code> è prima assegnato il valore 1 e poi la variabile <code>b</code> è incrementata di 2:</p>
<pre><code>a = b = 1, b = b + 2;                      </code></pre>
<p>il valore finale di <code>a</code> e <code>b</code> sarà quindi di 1 e 3, mentre nell’espressione qui sotto sarà di 1 e 2:</p>
<pre><code>a = b = 1, b = b + 2, b = b - 1;          </code></pre>
<p>Gli operatori <code>.</code> e <code>-&gt;</code> servono a identificare i membri di una classe o di un altro dato aggregato. Se ti ricordi (ne dubito), li abbiamo visti per la prima volta parlando del <a href="/man/c-plus-plus#membro">polimorfismo</a> e li utilizzeremo quando ci occuperemo delle classi.<br />
Gli operatori <code>&amp;</code> e <code>*</code>, infine, tornano, rispettivamente, l’indirizzo di memoria di una variabile e un puntatore a una variabile:</p>
<pre><code>/** 
 * @file operatori-altri.cpp
 * Altri operatori del C++.
 */

#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{        
    int     a = 9;
    int     b = 4;

    /** Converte un valore intero in char */
    char    c = char(a * b);

    /** Assegna a t il valore più alto fra a e b */
    int     t = (a &gt; b) ? a : b;

    /** Salva nel puntatore p l&#39;indirizzo di memoria di a */
    int*    p = &amp;a;    

    /** Calcola la dimensione di un intero */
    size_t sa = sizeof(a);

    /** Calcola la dimensione di un puntatore a intero */
    size_t sp = sizeof(p);

    /** Mostra l&#39;indirizzo della variabile a */
    cout &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; p  &lt;&lt; endl;

    /** Mostra la dimensione delle variabili a e p */
    cout &lt;&lt; &quot;sa: &quot; &lt;&lt; sa &lt;&lt; endl;
    cout &lt;&lt; &quot;sp: &quot; &lt;&lt; sp &lt;&lt; endl;

    /** Mostra il risultato dell&#39;operazione ternaria */
    cout &lt;&lt; &quot;t : &quot; &lt;&lt; t  &lt;&lt; endl;

    /** Il codice ASCII 36 corrisponde alla lettera $x\ */
    cout &lt;&lt; &quot;c : &quot; &lt;&lt; c  &lt;&lt; endl;
    
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, otterrai:</p>
<pre><code>&gt; g++ src/cpp/operatori-altri.cpp -o src/out/esempio 
&gt; src/out/esempio                                    
&amp;a: 0x7ffee65bba5c
sa: 4
sp: 8
t : 9
c : $</code></pre>
<hr />
<p>L’ultimo operatore di cui dobbiamo parlare è anche quella con il nome più lungo: l’operatore di <em>risoluzione del campo d’azione</em> <code>::</code>. Oltre ad altri utilizzi connessi con la gestione dei dati delle classi, di cui parleremo in seguito, questo operatore permette di riferirsi a delle variabili con visibilità globale anche nei casi in cui queste vengano oscurate dalla ridefinizione di variabili locali con lo stesso nome:</p>
<pre><code>/** 
 * @file _man/src/operatori-risoluzione.cpp
 * Utilizzo dell&#39;operatore di risoluzione.
 */

#include &lt;iostream&gt;

using namespace std;

const char * Stringa = &quot;Stringa globale&quot; ;

int main(int argc, char** argv)
{   
    const char * Stringa = &quot;Stringa locale&quot; ;

    /** Stampa la stringa locale */
    cout &lt;&lt; Stringa   &lt;&lt; endl ;
    
    /** Utilizza l&#39;operatore per riferirsi alla variabile globale */
    cout &lt;&lt; ::Stringa &lt;&lt; endl ;

    return 0;
}
</code></pre>
<p>Compilando ed eseguendo questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/operatori-risoluzione.cpp -o src/out/esempio 
&gt; ./src/out/esempio                                       
Stringa locale
Stringa globale</code></pre>
<hr />
<p>La definizione dei concetti di <em>vero</em> e di <em>falso</em> è sempre frutto di un arbitrio. È inevitabile. Per i filosofi è <em>vero</em> tutto ciò che può essere descritto con le parole; per gli scienziati, tutto ciò che può essere descritto dalla matematica; per gli informatici è <em>vero</em> tutto quello che può essere descritto dal codice. Possiamo definire <em>falso</em> come il contrario di <em>vero</em>, ma non possiamo dedurre o inferire il concetto di <em>vero</em> perché, quale che sia la definizione prescelta, prima di poterla prendere per buona dovremo poterla considerare vera, ma ciò è impossibile perché non sappiamo ancora cosa sia, effettivamente, <em>vero</em>.<br />
Bertrand Russell disse che la condizione di <em>vero</em> o di <em>falso</em> è uno stato dell’organismo, determinato da condizioni esterne all’organismo;<a href="/man/note#russell" class="nota"></a> è un’affermazione vera.. o, meglio, <em>valida</em> anche per i computer: i valori booleani <em>vero</em> e <em>falso</em> sono due stati possibili per un’istruzione e spesso dipendono da condizioni esterne all’istruzione stessa, come la presenza di un file o un’azione dell’utente. La cosa interessante è che, anche per i computer, i valori che vengono interpretati come <em>vero</em> e <em>falso</em> sono del tutto arbitrarii e spesso specifici per un dato sistema. Prendi per esempio i programmi che gestiscono le basi di dati: per <em>Access</em>, il valore booleano <em>false</em> è <code>-1</code>; per le prime versioni di <em>MySQL</em> è <code>f</code>; per Postgres o Oracle, è <code>0</code>.<br />
Il computer non ha <em>in sé</em> il concetto di <em>vero</em> o di <em>falso</em>, ma solo l’associazione dei valori booleani <em>true</em> e <em>false</em> a una determinata sequenza di bit. <em>Vero</em> e di <em>falso</em>, quindi, sono dei valori simbolici che noi inseriamo nella logica del computer, traducendo nel suo linguaggio un concetto che è proprio del nostro mondo; un riferimento esogeno che può generare delle apparenti conraddizioni come, per esempio, il fatto che tutti i valori digitali siano basati su grandezze analogiche (la carica magnetica di un nastro, un’infossatura nella superificie di un CD o la tensione all’interno di un circuito), o dei veri e proprii paradossi, come il fatto che, nelle schede perforate, il valore <code>1</code> sia associato al vuoto del foro, mentre il valore <code>0</code> sia associato alla presenza della carta; di fatto, una negazione logica della realtà.<br />
Questi paradossi, apparenti o reali che siano, non causano alcun problema al sistema, a patto vengano condivisi da tutti gli attori al suo interno. Il paradosso delle schede perforate (buco = 0, carta = 1) era condiviso sia dalle macchine Hollerith che dalle perforatrici delle schede, perciò, le elaborazioni che ne derivavano erano corrette, indipendentemente dal valore relativo attribuito ai concetti di <em>vero</em> e di <em>falso</em> all’interno del sistema. Da questo punto di vista, non possiamo che dare ragione a William James, quando dice che un’idea è <em>vera</em> fintanto che credere in essa è utile per le nostre vite.</p>
<hr />
<p>Anche gli esseri umani, come i computer, devono riferire le proprie convinzioni a schemi di valori preesistenti perché buona parte dei principii e dei valori su cui modelliamo la nostra e l’altrui esistenza non hanno un riscontro oggettivo nei fatti: sono solo convizioni o convenzioni che abbiamo deciso di adottare, così come il fatto che <code>true</code> equivalga al valore binario <code>000000001</code> e <code>false</code> a <code>00000000</code>.<br />
Prendi la ricchezza, per esempio: si dice che i soldi non danno la felicità ed è vero; nemmeno essere poveri rende felici, ma questo non lo dice nessuno. Comunque, una delle persone più ricche che ho conosciuto non poteva avere figli. Possedeva case in diversi Paesi, uno yacht e perfino un aereo personale, ma non poteva avere qualcosa che anche l’uomo più povero della Terra può facilmente ottenere. Che senso aveva, la sua ricchezza? Era reale?<br />
Si definisce: <em>prestigio</em> qualcosa che sembra ciò che non è, come i giochi degli illusionisti, mentre <em>successo</em> non è che il participio passato del verbo <em>succedere</em>: tutto ciò che è avvenuto in passato è, per definizione, “successo”; malgrado ciò, molte persone, sotto l’influsso dell’Annosa Dicotomia, dedicano la propria vita alla ricerca o dell’uno o dell’altro o di entrambi. La <em>fama</em> è altrettanto aleatoria: quante persone sono state famose e ora sono dimenticate? Gli inventori della ruota e del fuoco hanno cambiato per sempre la storia della nostra specie e del mondo con le loro scoperte, ma nessuno sa chi siano stati. In tempi più recenti, il pittore Giovanni Baglione fu molto famoso, alla fine del sediccesimo Secolo, ma se ci ricordiamo di lui oggi è solo per via dei suoi rapporti con Caravaggio e, comunque, la loro fama terminerà con la nostra specie, insieme a quella di Shakespeare, Leonardo o Einstein.<br />
Non sono inconsistenti solo i valori mondani, come fama successo o denaro, ma anche quelli che consideriamo usualmente “nobili”, come il rispetto della vita altrui. Se tu mi chiedi perché non si debba uccidere un uomo, ti risponderò che uccidere è sbagliato perché tutto il male che fai, lo stai facendo a te stesso; penso che sia vero perché me lo ha insegnato il Maestro Canaro, che aveva visto il codice del programma dell’Universo. Se invece lo chiedi a un cristiano o a un ebreo, lui ti risponderà che è vietato dai Dieci Comandamenti che Dio ha dato a Mosé; loro pensano che sia vero perché è scritto nella Bibbia, che è la Parola di Dio. Se infine lo chiedi a un paladino del laicismo, ti risponderà che l’omicidio, per il nostro ordinamento giuridico, è un reato; ciò dev’essere vero, perché le nostre Leggi applicano i concetti espressi nella nostra Costituzione la quale, a sua volta, si rifà ai principii di libertà e uguaglianza della <em>Dichiarazione dei Diritti dell’Uomo e del Cittadino</em> francese, che a sua volta si rifaceva alla <em>Dichiarazione di Indipendenza</em> americana, che a sua volta riprendeva le idee di Locke e Montesquieu.<br />
Nessuna di queste affermazioni è valida di per sé: sono tutte fondate su una qualche forma di fede — religiosa o laica che sia — in chi ha promulgato la Legge o il Principio.<br />
È, applicato all’etica, lo stesso meccanismo che si utilizza per certificare un server Web. Quando tu accedi al sito Web della tua banca, sai che è davvero il server della tua banca perché possiede un certificato digitale che attesta la sua identità, firmato digitalmente da un ente certificatore detto <em>Certification Authority</em> (o, più brevemente: <em>CA</em>). Tu sai che l’ente certificatore è davvero chi dice di essere perché anche lui ha un suo certificato, firmato da un’altro ente certificatore, chiamato: <em>root CA</em>. La <em>root CA</em> garantisce per la CA intermedia che a sua volta garantisce per la tua banca. Sfortunatamente, però, né i legislatori né i loro certificatori ideologici sono sottoposti alle regole e ai controlli che deve rispettare una <em>Certification Authority</em> e spesso è accaduto che chi ha definito delle regole sia stato anche il primo a non tenerne conto.<br />
Mosé, con il sesto Comandamento ancora fresco di stampa, chiese ai figli di Levi:</p>
<blockquote>
<p>Ognuno di voi si metta la spada al fianco; percorrete l’accampamento da una porta all’altra di esso, e ciascuno uccida il fratello, ciascuno l’amico, ciascuno il vicino!<a href="/man/note#levi" class="nota"></a></p>
</blockquote>
<p>Gli Americani, che scrissero:</p>
<blockquote>
<p>We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness.</p>
</blockquote>
<p>commerciavano in schiavi e hanno sterminato i Nativi Americani per rubar loro le terre. I Francesi, il cui motto era:</p>
<blockquote>
<p>Liberté, Égalité, Fraternité</p>
</blockquote>
<p>hanno applicato questi principii a colpi di ghigliottina. L’ONU, che nel 1948 ha pubblicato la <em>Dichiarazione Universale dei Diritti Umani</em> ha al suo vertice dei Paesi che sono i principali produttori di armi del Mondo<a href="/man/note#armi" class="nota"></a> e che violano costantemente quelle stesse regole da loro promosse.<br />
Attenzione, però: il fatto che i principii laici di pace, uguaglianza e libertà derivino, in ultima analisi, dalle convinzioni<a href="/man/note#self-evident" class="nota"></a> di un gruppo di credenti<a href="/man/note#credenti" class="nota"></a>, non vuol dire che siano sbagliati, ma che non gli si può attribuire nessuna veridicità oggettiva; possiamo solo accettarli per fede, così come i dogmi religiosi. <em>Scegliamo</em> di credere in uno schema di valori, così come potremmo scegliere di credere negli UFO: non abbiamo convinzioni innate, se non l’egoismo.<br />
Le persone per bene hanno una cosa in comune con i malandrini: pensano che il resto del Mondo sia come loro, ma si sbagliano. Noi troviamo condivisibile, quasi pleonastico, che ciascun essere umano abbia diritto alla vita, alla libertà e a una giustizia imparziale, perché siamo stati educati con questi valori, ma qualcuno con un differente livello culturale potrebbe non ritenere queste affermazioni altrettanto evidenti <em>in sé</em>.<br />
Per gli autori della <em>Dichiarazione di Indipendenza</em> era <em>self-evident</em> che tutti gli uomini fossero stati creati uguali, ma sei Stati del Sud, nelle loro Costituzioni, precisarono che si stava parlando di uomini liberi, non degli schiavi<a href="/man/note#freemen" class="nota"></a>.<br />
I nazisti utilizzarono le macchine Hollerith per censire e sterminare gli ebrei; furono anche aggiunte delle colonne alle schede perforate per poter gestire i dati relativi alla religione<a href="/man/note#black" class="nota"></a>. Noi oggi critichiamo sia loro sia chi li aiutò a farlo, ma forse i nostri nipoti criticheranno noi per la tolleranza che abbiamo mostrato nei confronti di chi ci vende il petrolio per le nostre automobili; la stessa tolleranza che loro mostreranno a chi li rifornirà di materie prime per le batterie, o di acqua.</p>
<hr />
<p>Scegliamo un ethos perché rende migliore la nostra vita, non perché ci sta simpatico l’autore. Il Maestro Canaro, per esempio, era convinto che il Libro dell’Esodo fosse il resoconto di un esperimento alieno su una popolazione isolata nel deserto per due generazioni (“capisci: la circoncisione serviva a identificare i maschi e l’appartenenza al gruppo era stabilita in base alla madre perché così era verificabile grazie ai mitocondri”); ciò non ostante, regolava la sua vita e le sue decisioni in base a una sua versione “laicizzata” dei dieci Comandamenti di Mosé:</p>
<blockquote>
<ol>
<li>Il senso della vita è capire il senso della vita.</li>
<li>Non cercare il senso della vita nelle cose terrene.</li>
<li>Ciò che conta è come ti comporti, non quello che dici.</li>
<li>Dedica parte del tuo tempo alla ricerca spirituale (v. punto 1).</li>
<li>Non giudicare i tuoi genitori finché non ti sarai trovato in situazioni simili alle loro.</li>
<li>Non uccidere senza un valido motivo (per definire il concetto di “valido motivo” v. punti 1-10).</li>
<li>Ci sono tante donne non sposate: tròmbati quelle.</li>
<li>Non prendere ciò che non ti appartiene, di qualunque cosa si tratti.</li>
<li>Non fare falsa testimonianza contro il tuo prossimo.</li>
<li>Non desiderare ciò che appartiene ad altri; se riesci a non desiderare nulla è anche meglio.</li>
</ol>
</blockquote>
<p>Quando gli chiesi perché avesse scelto proprio quelle regole, mi rispose: “Se li avessi seguiti anche da giovane, adesso avrei molti rimorsi in meno.”</p>
</section>
</section>
<a href="/man/struttura-dei-programmi" class="left" title="Vai a: Struttura dei programmi C++"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/preprocessore" class="right" title="Vai a: Il preprocessore"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/operatori" class="left" title="Vai a: Gli operatori"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/memoria" class="right" title="Vai a: La memoria"><em></em></a>
<section id="il-preprocessore-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Il preprocessore</a></h1>
<blockquote>
Tutte le potenze, tranne quella di 1, crescono
</blockquote>
<section class="testo">
<p>Le direttive al preprocessore sono la caratteristica principale del C++.</p>
<p>Negli esempi precedenti abbiamo visto alcune istruzioni particolari, perché hanno un carattere <code>#</code> all’inizio e non hanno un carattere <code>;</code> alla fine:</p>
<pre><code>#include &lt;iostream&gt;

#define NO_ERRORI    0
#define NO_PARAMETRI 1</code></pre>
<p>Queste istruzioni sono delle <em>direttive al pre-processore</em> e possono essere di tre tipi:</p>
<ul>
<li>direttive di inclusione;</li>
<li>definizioni e macroistruzioni;</li>
<li>direttive condizionali.</li>
</ul>
<p>Le <span id="inclusione">direttive di inclusione</span> sono quelle che si utilizzano più comunemente e servono a importare nel codice le definizioni delle funzioni di libreria, delle macroistruzioni e dei simboli necessari per la corretta compilazione dei programmi. Questi elementi, per comodità, sono isolati all’interno di alcuni file, detti <em>file di include</em>. Quando il preprocessore incontra una direttiva <code>include</code>, la sostituisce con il contenuto del file a cui fa riferimento. Per esempio, se più di un programma dovesse usare la Classe <code>Colore</code> o la struttura <code>ColoreRGB</code> che abbiamo utilizzato nel programma che visualizza la dimensione dei <a href="/man/tipi-di-dato#principali">principali tipi di dato del C++</a>, questi dovrebbero essere isolati in un file separato con estensione <code>.h</code>, a indicare che si tratta di un <em>header file</em>:</p>
<pre><code>#ifndef _CLASS_COLORE
#define _CLASS_COLORE 1

#define  RGB_RED    0xFF0000
#define  RGB_GREEN  0x00FF00
#define  RGB_BLUE   0x0000FF

#ifdef LANG_IT
    #define  STR_RGB    &quot;colore RGB&quot;
    #define  STR_RED    &quot;rosso&quot;
    #define  STR_GREEN  &quot;verde&quot;
    #define  STR_BLUE   &quot;blu&quot;
#else 
    #define  STR_RGB    &quot;RGB color&quot;
    #define  STR_RED    &quot;red&quot;
    #define  STR_GREEN  &quot;green&quot;
    #define  STR_BLUE   &quot;blue&quot;
#endif

#include &lt;iostream&gt;

using namespace std;

/** Definisce un tipo di dato enumerato di nome RGB */
enum RGB { red = RGB_RED, green = RGB_GREEN, blue = RGB_BLUE };

/** Definisce una struttura che contiene un colore RGB e un nome */
struct ColoreRGB {
    RGB  valore;
    const char* nome;        
};

/** 
 * Definisce la classe Colore, che contiene una struct 
 * coloreRGB e una funzione che ne mostra il nome.
 */
class Colore {
public:
    ColoreRGB coloreRgb;        
    void nome_colore() {
        cout &lt;&lt; STR_RGB &lt;&lt; &quot;: &quot;;
        switch(coloreRgb.valore) {
            case red  : cout &lt;&lt; STR_RED  ; break;
            case green: cout &lt;&lt; STR_GREEN; break;
            case blue : cout &lt;&lt; STR_BLUE ; break;
        }
        cout &lt;&lt; endl;
    }        
};

#endif /* _CLASS_COLORE */
</code></pre>
<p>Il file verrebbe poi incluso nel codice dei programmi che ne fanno uso con una direttiva <code>include</code>:</p>
<pre><code>/** 
 * @file src/preprocessore-main.cpp
 * Mostra i valori possibili per i principali tipi di dato del C++.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

#define LANG_IT
#include &quot;colore.h&quot;
#undef LANG_IT

#ifdef LANG_IT
    #define  STR_BOOL   &quot;booleano&quot;
    #define  STR_CHAR   &quot;carattere&quot;
    #define  STR_INT    &quot;intero&quot;
    #define  STR_DEC    &quot;decimale&quot;
    #define  STR_ARRAY  &quot;array&quot;
    #define  STR_VERDE  &quot;verde&quot;
#else 
    #define  STR_BOOL   &quot;boolean&quot;
    #define  STR_CHAR   &quot;character&quot;
    #define  STR_INT    &quot;integer&quot;
    #define  STR_DEC    &quot;decimal&quot;
    #define  STR_ARRAY  &quot;array&quot;
    #define  STR_VERDE  &quot;green&quot;
#endif

using namespace std;

int main()
{    
    /** Dichiara una serie di variabili */
    bool    booleano = false;
    char    carattere = &#39;C&#39;;
    int     intero = 1234567890;
    float   decimale = 3.14;
    char    array[] = &quot;abcdefghilmnopqrstuvz&quot;;
    RGB     enumerato = green;
    
    /** Crea un oggetto di tipo Colore */
    Colore  colore;    
    
    /** 
     * Assegna un valore ai dati della struttura coloreRgb 
     * all&#39;interno dell&#39;oggetto di tipo Colore.
     */
    colore.coloreRgb.valore = enumerato;   
    colore.coloreRgb.nome = STR_VERDE;     

    /** Mostra il valore delle variabili */
    cout &lt;&lt; setw(10) &lt;&lt; STR_BOOL  &lt;&lt; &quot;: &quot; &lt;&lt; booleano   &lt;&lt; endl;
    cout &lt;&lt; setw(10) &lt;&lt; STR_CHAR  &lt;&lt; &quot;: &quot; &lt;&lt; carattere  &lt;&lt; endl;
    cout &lt;&lt; setw(10) &lt;&lt; STR_INT   &lt;&lt; &quot;: &quot; &lt;&lt; intero     &lt;&lt; endl;
    cout &lt;&lt; setw(10) &lt;&lt; STR_DEC   &lt;&lt; &quot;: &quot; &lt;&lt; decimale   &lt;&lt; endl;
    cout &lt;&lt; setw(10) &lt;&lt; STR_ARRAY &lt;&lt; &quot;: &quot; &lt;&lt; array      &lt;&lt; endl;
    
    /** Mostra il nome del colore */
    colore.nome_colore();
    
    return 0;
}
</code></pre>
<p>Questo esempio utilizza due forme distinte per la direttiva <code>include</code>:</p>
<pre><code>#include &lt;iostream&gt;
#include &quot;colore.h&quot; </code></pre>
<p>La prima forma serve a includere i file di sistema, come, appunto, <code>iostream</code>, che contiene le definizioni degli <em>stream</em> standard del C++; la seconda forma si utilizza per i file specifici dell’applicazione; nel nostro caso, <code>colore.h</code>.<br />
I file di include possono includere a loro volta altri file; per esempio, <code>colore.h</code> include <code>iostream</code>, perché utilizza lo <em>stream</em> <code>cout</code>. Anche il nostro codice di esempio, però, include <code>iostream</code> e questo potrebbe causare un errore di compilazione se il precompilatore effettuasse due volte l’inclusione, perché sarebbbe come se dichiarassimo due volte la stessa funzione. Per questo motivo, all’inizio del nostro file di include (ma anche di <code>iostream</code>) troviamo un altro tipo di diretttive al preprocessore, le cosiddette: <span id="condizionali">direttive condizionali</span>:</p>
<pre><code>#ifndef _CLASS_COLORE
#define _CLASS_COLORE 1

...

#endif /* _CLASS_COLORE */</code></pre>
<p>Le direttive condizionali sono:</p>
<table>
<thead>
<tr class="header">
<th>direttiva</th>
<th>valore</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>#if</code></td>
<td>se non zero</td>
</tr>
<tr class="even">
<td><code>#ifdef</code></td>
<td>se definito</td>
</tr>
<tr class="odd">
<td><code>#ifndef</code></td>
<td>se non definito</td>
</tr>
<tr class="even">
<td><code>#else</code></td>
<td>altrimenti</td>
</tr>
<tr class="odd">
<td><code>#elif</code></td>
<td>altrimenti se</td>
</tr>
<tr class="even">
<td><code>#endif</code></td>
<td>fine del blocco condizionale</td>
</tr>
</tbody>
</table>
<p>Quando il preprocessore legge la prima direttiva nel file di include, verifica che sia definito un valore per <code>_CLASS_COLORE</code>. Se <code>_CLASS_COLORE</code> non ha un valore associato, il preprocessore esegue l’istruzione successiva, che gli assegna il valore 1, poi inserisce nel file chiamante tutto il codice fino all’istruzione <code>#endif</code>. Se invece <code>_CLASS_COLORE</code> ha già un valore associato perché è già stata inclusa da altri file, il preprocessore salta direttamente alla direttiva <code>#endif</code> senza riscrivere le tre dichiarazioni.</p>
<p>Le istruzioni seguenti definiscono delle costanti numeriche per i colori dell’<code>enum RGB</code>:</p>
<pre><code>#define  RGB_RED    0xFF0000
#define  RGB_GREEN  0x00FF00
#define  RGB_BLUE   0x0000FF</code></pre>
<p>Le direttvive al preprocessore permettono di definire anche delle costranti stringa:</p>
<pre><code>#define  STR_GREEN  &quot;verde&quot;</code></pre>
<p>Questa è una buona cosa, perché, come imparerai con l’esperienza, avere delle stringhe <em>hardcoded</em> all’interno dei programmi causa sempre dei problemi e soprattutto lega il tuo codice a un determinato linguaggio:</p>
<pre><code>colore.coloreRgb.nome = &quot;verde&quot;;     

/** Mostra il valore delle variabili */
cout &lt;&lt; &quot;booleano:&quot;    &lt;&lt; booleano   &lt;&lt; endl;
cout &lt;&lt; &quot;carattere:&quot;   &lt;&lt; carattere  &lt;&lt; endl;
cout &lt;&lt; &quot;intero:&quot;      &lt;&lt; intero     &lt;&lt; endl;
cout &lt;&lt; &quot;decimale:&quot;    &lt;&lt; decimale   &lt;&lt; endl;
cout &lt;&lt; &quot;array:&quot;       &lt;&lt; array      &lt;&lt; endl;</code></pre>
<p>Questo può essere accettabile in un programma di esempio, ma è una scelta miope per un programma reale, specie se le stringhe si ripetono in contesti diversi:</p>
<pre><code>char stringa[] = &quot;ebete&quot;;

...

cout &lt;&lt; 6 &lt;&lt; &quot;ebete&quot; &lt;&lt; endl;
</code></pre>
<p>perché se la stringa dovesse variare (e stai pur certo che succederà), tu dovrai modificare tutte le righe di codice in cui compare. Al contrario, se definisci delle costanti per tutte le stringhe che utilizzi nel tuo codice, la correzione sarà unica:</p>
<pre><code>#define STR_COME_SEI = &quot;astuto&quot;;

char stringa[] = STR_COME_SEI;

...

cout &lt;&lt; 6 &lt;&lt; STR_COME_SEI &lt;&lt; endl;
</code></pre>
<p>Unite alle direttive condizionali, le definizioni di costanti stringa ti permettono di avere un codice multilingua:</p>
<pre><code>#ifdef LANG_IT
    #define  STR_RGB    &quot;colore RGB&quot;
    #define  STR_RED    &quot;rosso&quot;
    #define  STR_GREEN  &quot;verde&quot;
    #define  STR_BLUE   &quot;blu&quot;
#else 
    #define  STR_RGB    &quot;RGB color&quot;
    #define  STR_RED    &quot;red&quot;
    #define  STR_GREEN  &quot;green&quot;
    #define  STR_BLUE   &quot;blue&quot;
#endif</code></pre>
<p>La definizione della costante che determina la condizione (in questo caso, <code>LANG_IT</code>) può avvenire o nel codice del programma che include il file con definizioni:</p>
<pre><code>#define LANG_IT
#include &quot;colore.h&quot;</code></pre>
<p>o direttamente da riga di comando, come parametro di compilazione:</p>
<pre><code>% g++ ./cpp/preprocessore-main.cpp -D LANG_IT -o ./out/esempio
% ./out/esempio                                               
  booleano: 0
 carattere: C
    intero: 1234567890
  decimale: 3.14
     array: abcdefghilmnopqrstuvz
colore RGB: verde
% g++ ./cpp/preprocessore-main.cpp -D LANG_EN -o ./out/esempio
% ./out/esempio                                               
   boolean: 0
 character: C
   integer: 1234567890
   decimal: 3.14
     array: abcdefghilmnopqrstuvz
RGB color: green</code></pre>
<p>È possibile eliminare una <code>#define</code> precedentemente assegnata per mezzo della direttiva <code>#undef</code>:</p>
<pre><code>#define LANG_IT
#include &quot;preprocessore-colore.h&quot;
#undef LANG_IT

#ifdef LANG_IT
    #define  STR_BOOL   &quot;booleano&quot;
    #define  STR_CHAR   &quot;carattere&quot;
    #define  STR_INT    &quot;intero&quot;
    #define  STR_DEC    &quot;decimale&quot;
    #define  STR_ARRAY  &quot;array&quot;
    #define  STR_VERDE  &quot;verde&quot;
#else 
    #define  STR_BOOL   &quot;boolean&quot;
    #define  STR_CHAR   &quot;character&quot;
    #define  STR_INT    &quot;integer&quot;
    #define  STR_DEC    &quot;decimal&quot;
    #define  STR_ARRAY  &quot;array&quot;
    #define  STR_VERDE  &quot;green&quot;
#endif</code></pre>
<p>L’output di questo codice, sarà:</p>
<pre><code>% g++ src/cpp/preprocessore-main.cpp -D LANG_EN -o src/out/esempio
% ./src/out/esempio                                               
   boolean: 0
 character: C
   integer: 1234567890
   decimal: 3.14
     array: abcdefghilmnopqrstuvz
colore RGB: verde</code></pre>
<hr />
<p>Il preprocessore può essere sfruttato anche per creare delle <em>macro-istruzioni</em> che possano essere utilizzate con tipi diversi di dati.</p>
<pre><code>#define MAGGIORE(a,b) ((a &gt; b) ? a : b) </code></pre>
<p>Quando il precompilatore trova una chiamata alla macro MAGGIORE, all’interno del codice, la sostituisce con l’istruzione corrispondente, rimpiazzando i parametri <code>a</code> e <code>b</code> con le variabili contenute nella chiamata.</p>
<pre><code>/** 
 * @file src/preprocessore-macro.cpp
 * Esempio di macro-istruzione del precompilatore.
 */

#include &lt;iostream&gt;

using namespace std;

/**
*  Definzione di una macro istruzione che
*  torna il maggiore fra due parametri.
*/
#define MAGGIORE(a,b) ((a &gt; b) ? a : b) 

int main ()
{     
    /** 
     *  Il codice di queste istruzioni è sostituito
     *  con quello associato alla macro:
     *      
     *      cout &lt;&lt; ((109 &gt; 122) ? 109 : 122) &lt;&lt; endl;    
     *      cout &lt;&lt; ((0.4 &gt; 0.7) ? 0.4 : 0.7) &lt;&lt; endl;    
     *      cout &lt;&lt; ((&#39;a&#39; &gt; &#39;z&#39;) ? &#39;a&#39; : &#39;z&#39;) &lt;&lt; endl;    
    */
    cout &lt;&lt; MAGGIORE(209, 122) &lt;&lt; endl;    
    cout &lt;&lt; MAGGIORE(0.4, 0.7) &lt;&lt; endl;    
    cout &lt;&lt; MAGGIORE(&#39;y&#39;, &#39;z&#39;) &lt;&lt; endl;    
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/preprocessore-macro.cpp -o src/out/esempio
&gt; src/out/esempio                                         
209
0.7
z</code></pre>
<p>Le macro del precompilatore sono eseguite prima che il codice sia compilato, quindi possono essere sftuttate anche per creare delle funzioni ex-novo.</p>
<pre><code>/** 
 * @file src/preprocessore-hashtag.cpp
 * Esempii di macro-istruzioni del precompilatore.
 */

#include &lt;iostream&gt;

using namespace std;
 
/** Definisce la macro-istruzione */
#define FUNZIONE(nome, parametro) int fnz_##nome() { return parametro; }

/** 
*   Durante la precompilazone, questa macro 
*   sarà sosituita dall&#39;istruzione:
*       
*     int fnz_macro(12) { return 12; }
*/
FUNZIONE(macro, 12)
 
/** 
*   Definisce una macro che stampa un testo a video:
*/
#define OUTPUT(testo) cout &lt;&lt; testo &lt;&lt; endl;
 
/** 
*   Definisce una macro che unisce la stringa &quot;Pippo&quot;
*   al parametro ricevuto in input:
*/
#define PIPPO &quot;Pippo&quot;
#define APPENDI(nome) PIPPO # nome
 
int main()
{
    /** 
    *   La funzione fnz_macro ora non esiste, ma esisterà 
    *   al termine della pre-compilazione del codice:
    */
    cout &lt;&lt; fnz_macro() &lt;&lt; endl;
 
    /** Stampa una stringa a video usando le altre due macro */
    OUTPUT(APPENDI(Pluto));               
}
</code></pre>
<p>Questo esempio fa uso di due operatori proprii del preprocessore:</p>
<ul>
<li>l’operatore di <em>stringification</em> <code>#</code> (mi rifiuto di tradurre questo termine), che converte il parametro successivo in una stringa, aggiungendogli i doppi apici ed aggiungendo dei <em>backlslash</em> a eventuali doppi apici presenti nel parametro;</li>
<li>l’operatore di <em>concatenazione</em> <code>##</code>, che unisce in un’unica stringa il parametro precedente e successivo.<br />
Se compili ed esegui questo codice, ottieni:</li>
</ul>
<pre><code>&gt; g++ src/cpp/preprocessore-hashtag.cpp -o src/out/esempio 
&gt; src/out/esempio                                         
12
PippoPluto</code></pre>
<p>Le macro-istruzioni del precompilatore sono uno strumento molto potente, ma devono essere utilizzate con oculatezza perché, essendo generate <strong>prima</strong> che dell’avvio della compilazione, non sono sottoposte ad alcun controllo di congruenza per il tipo dei parametri utilizzati. Questo, come vedremo <a href="/man/polimorfismo#funzioni-template" class="xref">in seguito</a>, può generare degli errori molto subdoli e difficili da identificare.</p>
<hr />
<p>Le tre forze che regolano la vita dell’Universo — Gravità, Entropia e Annosa Dicotomia — non influenzano solo la fisica, ma anche l’etica. Esistono valori che potremmo definire: “entropici” e valori “gravitazionali”. I valori legati all’Entropia sono quelli che tendono a disgiungere e a esaltare il singolo rispetto alla massa, come la libertà, la ricchezza, il successo o la fama; i valori legati alla Gravità sono quelli che, al contrario, uniscono gli individui, come l’<em>égalité</em> e la <em>fraternité</em> dei Francesi, ma senza la ghigliottina.<br />
<a href="/man/operatori#effimeri" class="xref">Ieri</a> abbiamo visto come i valori legati all’Entropia siano effimeri — non potrebbe essere altrimenti, per una forza che tende alla disgregazione — e di come chi li persegua sia spesso vittima dell’Annosa Dicotomia, ma questo non vuol dire che li si debba ripudiare. Non fare l’errore di pensare che ci sia una forza buona e una cattiva, come in <em>Star Wars</em>: sia la Gravità che l’Entropia sono necessarie per una corretta evoluzione dell’Universo. Il Maestro Canaro, che anche in tarda età amava molto andare in bicicletta, una volta mi disse che l’equilibrio dell’Universo è come l’equilibrio di un ciclista che percorra una strada sterrata in salita: non deve tenere il peso troppo in avanti, perché altrimenti la ruota posteriore perderebbe trazione e comincerebbe a slittare, ma non deve nemmeno tenere il peso troppo indietro, perché altrimenti la ruota anteriore si alleggerirebbe e non sarebbe più possibile sterzare.<br />
Considerata la rispettabile quantità di cadute e contusioni collezionate dal Maestro Canaro nel corso delle sue escursioni in sella, ti consiglio di valutare solo il valore metaforico di questo insegnamento, ovvero che ci deve essere un bilanciamento fra Gravità ed Entropia, perché senza la Gravità, l’Universo è inutile, ma senza l’Entropia è noioso. In questo momento, l’Universo è in fase di espansione sotto l’influsso dell’Entropia ed è quindi normale che ci sia una preponderanza di azioni tendenti alla separazione. Per mantenere l’equilibrio, quindi, bisogna incentivare le attività e i valori che tendono a riunire, come l’amore o l’arte.<br />
Molte persone pensano che amore e arte siano dei concetti vaghi e aleatorii, ma solo perché ne fraintendono l’essenza, ritenendoli dei concetti auto-esplicativi, che non occorre definire; qualcosa di simile alla definizione di “<em>pornografia</em>” che diede il Giudice Potter Steward, a proposito del film <em>Les Amants</em> di Louis Malle:</p>
<blockquote>
<p>I shall not today attempt further to define the kinds of material I understand to be embraced within that shorthand description; and perhaps I could never succeed in intelligibly doing so. But I know it when I see it, and the motion picture involved in this case is not that.<a href="/man/note/#steward" class="nota"></a></p>
</blockquote>
<p>Questo approccio entropico/soggettivo, per quanto corretto nel caso di <em>Les Amants</em>, è chiaramente sbagliato in termini generali: tutte le parole, anche quelle più comuni, possono essere interpretate in maniera differente da chi le ascolta o le utilizza. Così come la parola: <em>pesce</em>, per quanto banale, può non avere lo stesso valore per un biologo marino, un ecologista o per un pescatore, anche la parola <em>arte</em> può assumere significati diversi per un gallerista, per un artista o per un Papa.<br />
È altrettanto sbagliata l’interpretazione entropico/romantica che comunemente si attribuisce alle parole: <em>amore</em> e <em>arte</em>. L’amore non è il sentimento vago che ha fatto la fortuna di poeti, musici e letterati, ma uno stato (più o meno persistente) del nostro organismo in cui riteniamo che qualcuno o qualcosa sia più importante di noi stessi. Di contro, l’Arte (ti prego di scrivere questo termine con l’iniziale maiuscola, nel tuo libro) non è l’esaltazione della personalità di un singolo, ma è — e dev’essere — la traccia del nostro cammino alla ricerca del Senso della Vita: Dio, per chi ci crede, o la Perfezione per i non credenti. Approfondiremo quest’ultimo concetto <a href="/man/ereditarieta#arte" id="arte" class="xref">in séguito</a>; qui e ora, come direbbe Céline Dion, <em>let’s talk about love</em>.</p>
<hr />
<p>Tutti noi agiamo in base a degli schemi di valori che determinano le nostre scelte. L’istinto di sopravvivenza, solitamente, ci spinge a porre la nostra persona al vertice di questa piramide, ma alle volte può capitarci di eleggere a nostro bene supremo qualcuno o qualcosa diverso da noi stessi. Quel senza Dio di Dawkins ha dimostrato come l’attaccamento che noi proviamo per i nostri parenti sia direttamente proporzionale al numero di cromosomi che condividiamo con essi e che quindi può essere riconducibile al desiderio primordiale di perpetuare il nostro patrimonio genetico<a href="/man/note/#selfish" class="nota"></a>. Questa interpretazione ribonucleica dell’amore funziona molto bene per i rapporti di sangue (padre/figlio, nonno/nipote, zio/nipote ecc.), ma non spiega l’amore fra mamma e papà o fra nonno e nonna — almeno, nelle famiglie che non ritengono l’incesto una pratica accettabile.<br />
L’<em>egoismo dei geni</em> non spiega nemmeno altre forme d’amore come l’amor di Patria, che spinge i giovani a sacrificare la propria vita in guerra, l’amore per il prossimo, che porta il missionario a sacrificare la sua vita per aiutare i malati o l’amore per una forma di arte, uno sport o un lavoro. La realtà è che l’amore è una <em>backdoor</em>, o, meglio: una bomba a tempo, che viene inserita di nascosto nel tuo software, per essere certi che farai la cosa giusta quando arriverà il momento.<br />
L’amore è l’unica forza allo stesso tempo gravitazionale ed entropica. Gravitazionale, perché unisce gli individui; entropica, perché li porta a riprodursi, replicando il loro DNA in qualcos’<em>altro</em>. Ti spinge a restare in casa, davanti a una tela, uno spartito o un foglio bianco o ti fa uscire, su una sella, una pista o con una macchina fotografica in mano. Ti porta in cima a una montagna o in una baraccopoli; al Polo o nel deserto; ti getta nel mare, ma non ti viene a salvare, come nella canzone; ti fa lasciare un lavoro sicuro perché non riconosci più la persona che vedi nello specchio la mattina o ti fa restare in un monastero, anche se.<br />
E questa è la parte facile; poi c’è l’amore fra gli individui.<br />
Ti sei mai innamorato? No? be’, succederà. Ci sono due modi, di innamorarsi: o conosci una persona e te ne innamori o conosci una persona e scopri che è lei (o lui) che hai sempre amato. Il primo è il caso più comune; il secondo caso, non è un caso.<br />
Il Maestro Canaro una volta disse (ma non credo fosse farina del suo sacco):</p>
<blockquote>
<p>Le donne cercano per tutta la vita il loro uomo ideale; nel frattempo, si sposano.</p>
</blockquote>
<p>Questo è vero per tutti, uomini e donne. Il tuo DNA contiene i geni che hanno fatto nascere l’amore fra i tuoi genitori: occhi verdi, spalle larghe, un bel seno o magari un bel sedere<a href="/man/note/#orologiaio" class="nota"></a>. Allo stesso modo, dentro di te potrebbe esserci qualcosa che ti spingerà a cercare e ad amare una persona in particolare, perché quella persona è importante per la tua vita. Quando (se) la incontrerai, avrai l’impressione di conoscerla da sempre e capirai che tutte le volte che ti sei innamorato, ti sei innamorato di lei, anche se non la conoscevi ancora. Sfortunatamente, questo non vuol dire che la vostra storia durerà o che vivrete per sempre felici e contenti, come nelle favole. Anzi.<br />
Il Cielo non è interessato alla tua felicità, ma al miglioramento, che, come ogni forma di crescita, ha il suo prezzo. Tutti sanno che il Maestro Canaro risolse il <em>Koan Mu</em> in una notte di profondo dolore dopo la morte di un cane di nome Lele. Molti, per ciò, ritengono il cane Lele un <em>Bodhisattva</em> che diede la vita per generare nel Maestro la prima scintilla dell’Illuminazione. Hanno ragione, ma solo in parte, perché la morte del cane Lele fu solo una delle cause dell’amarezza di quella notte. Il Maestro Canaro mi disse che buona parte del dolore era stato causato da una donna, che lui amava e dalla quale era stato ferito. Il motivo per cui me lo raccontò è lo stesso per cui io lo sto raccontando ora a te: anni dopo, quando il Maestro aveva già definito le basi del C’hi++, lui tornò da quella donna e la ringraziò per il torto che gli aveva fatto, perché lo aveva messo nella condizione d’animo necessaria a capire qualcosa a cui altrimenti avrebbe potuto non arrivare mai.<br />
Ringraziare chi ci fa del bene con azioni gentili fa parte dell’educazione; ringraziare chi ci fa del bene attraverso il male non è facile, ma è necessario per far sì che quell’azione venga ripetuta anche nelle prossime esistenze.</p>
</section>
</section>
<a href="/man/operatori" class="left" title="Vai a: Gli operatori"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/memoria" class="right" title="Vai a: La memoria"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/preprocessore" class="left" title="Vai a: Il preprocessore"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/funzioni" class="right" title="Vai a: Le funzioni"><em></em></a>
<section id="la-memoria-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">La memoria</a></h1>
<blockquote>
cogito ∴ sum()
</blockquote>
<section class="testo">
<p>La gestione della memoria è la caratteristica principale del C++.</p>
<p>Come ti ho detto, tutti i linguaggi di programmazione sono un modo di vedere la memoria del computer. Quando tu <em>dichiari</em> una variabile con un’istruzione come:</p>
<pre><code>signed int a = 1;</code></pre>
<p>in realtà, stai dicendo al compilatore di prendere un’area di memoria di 32 bit (un <code>int</code> è grande 4 byte, ricordi?), associarle il nome <code>a</code> e scriverci dentro il valore binario:</p>
<pre><code> 00000000 00000000 00000000 00000001</code></pre>
<p>Come puoi vedere, la maggior parte della variabile è inutilizzata, quindi, se hai a che fare con valori minori di 65.535, è meglio usare degli <code>short int</code>, che occupano solo due byte.<br />
Allo stesso modo, se dichiari la stringa:</p>
<pre><code> const char* motto = &quot;Cogito ergo sum&quot;;</code></pre>
<p>stai chiedendo al compilatore di prendere un’area di memoria di 16 byte, salvarne l’indirizzo iniziale nella variabile <code>motto</code> e poi scriverci dentro i 15 caratteri della frase più un ultimo carattere, con valore <code>0</code>, che indica la fine della stringa.<br />
Puoi usare questo metodo se sai in anticipo quanto saranno grandi le variabili con cui avrai a che fare, ma se invece devi gestire dei valori di grandezza variabile (per esempio, l’input di un utente), hai due possibilità: o riservi preventivamente una quantità abbondante di spazio, o la allochi sul momento, in base alle tue necessità. Il primo caso va bene se devi gestire pochi dati di dimensioni ridotte, ma se devi gestire molte variabili di grandi dimensioni, l’allocazione dinamica, anche se più complessa da gestire, è più efficiente.<br />
Il codice seguente è un esempio di gestione statica della memoria:</p>
<pre><code>/** 
 * @file memoria-statica.cpp
 * Gestione statica della memoria.
 */
 
#include &lt;iostream&gt;

/** Definisce la dimensione della stringa */
#define DIM_STRINGA 200

using namespace std;

int main(int argc, char** argv)
{    
    /** Riserva uno spazio di 200 caratteri */
    char stringa[DIM_STRINGA];

    /** 
    * Qui dovrebbe controllare che le stringhe ci siano 
    * e che, sommate, siano più corte di 200 caratteri.. 
    */
    
    /** Copia le stringhe nell&#39;area di memoria */
    sprintf(stringa, &quot;%s %s&quot;, argv[1], argv[2]);

    /** Stampa la stringa a video */
    cout &lt;&lt; stringa &lt;&lt; endl;
        
    return 0;
}
       
</code></pre>
<p>Se lo compili e lo esegui, passando due stringhe come parametri, ottieni questo output:</p>
<pre><code>% g++ src/cpp/memoria-statica.cpp -o src/out/esempio                
% src/out/esempio &quot;Stringa uno&quot; &quot;Stringa due&quot;
Stringa uno Stringa due</code></pre>
<p>Questo codice funziona se devi gestire solo due stringhe che, sommate, hanno meno di 200 caratteri: una condizione piuttosto restrittiva. Puoi aumentare il numero di stringhe e la dimensione dello spazio in memoria, ma otterresti un programma che è o sovra o sotto dimensionato. Questa non è buona programmazione. Il buon programmatore non deve sprecare risorse; per lui, il proverbiale bicchiere non è né mezzo pieno né mezzo vuoto: è grande il doppio del necessario.</p>
<pre><code>/** 
 * @file memoria-dinamica.cpp
 * Gestione dinamica della memoria.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    /** 
    * Qui dovrebbe controllare che le stringhe ci siano.. 
    */
   
    /** Legge la lunghezza delle due stringhe */        
    size_t len1 = strlen(argv[1]);
    size_t len2 = strlen(argv[2]);

    /** 
     * Alloca un&#39;area di memoria grande quanto le due
     * stringhe più un carattere di spazio e un
     * carattere terminatore.
     */   
    size_t lunghezza = len1 + len2 + 2; 
    char* stringa = new char[lunghezza];

    /** Copia le stringhe nell&#39;area di memoria */
    sprintf(stringa, &quot;%s %s&quot;, argv[1], argv[2]);

    /**
     * Mostra l&#39;indirizzo dell&#39;area di memoria,
     * la sua dimensione e il suo contenuto
     */
    cout &lt;&lt; (void*)stringa &lt;&lt; endl;
    cout &lt;&lt; lunghezza      &lt;&lt; endl; 
    cout &lt;&lt; stringa        &lt;&lt; endl;
    
    /** Libera la memoria allocata */
    delete[] stringa;
    
    return 0;
}
</code></pre>
<p>L’output di questo programma, molto più parsimonioso della sua versione statica, è il seguente:</p>
<pre><code>% src/out/esempio &quot;Stringa uno&quot; &quot;Stringa due&quot;        
0x7fead1405910
24
Stringa uno Stringa due

% src/out/esempio &quot;Stringa uno&quot; &quot;Stringa due più lunga&quot;
0x7fbb6e405910
35
Stringa uno Stringa due più lunga

% src/out/esempio &quot;Stringa uno&quot; &quot;&quot;                     
0x7fcf8f405910
13
Stringa uno </code></pre>
<p>La parola-chiave <code>new</code> permette di allocare una determinata quantità di memoria e torna un puntatore al primo indirizzo dell’area allocata:</p>
<pre><code>char* stringa = new char[lunghezza];</code></pre>
<p>Il puntatore <code>stringa</code>, adesso, contiene l’indirizzo dell’area di memoria allocata dall’istruzione <code>new</code>. Se lo passiamo come parametro all’operatore <code>&lt;&lt;</code>, dato che si tratta di un puntatore a <code>char</code>, verrà visualizzato come una stringa:</p>
<pre><code>cout &lt;&lt; stringa &lt;&lt; endl;</code></pre>
<p>Per conoscere il suo valore effettivo, dobbiamo convertirlo in un puntatore <code>void</code> con un’operazione di <a href="/man/tipi-di-dato#casting">casting</a>:</p>
<pre><code>cout &lt;&lt; (void*)stringa &lt;&lt; endl;</code></pre>
<p>Il lato negativo dell’allocazione dinamica della memoria è che, mentre un buffer statico “vive” quanto il blocco di istruzioni in cui è stato creato, la memoria allocata dinamicamente rimane occupata fino a che non viene liberata con un’istruzione <code>delete</code>:</p>
<pre><code>delete[] stringa;</code></pre>
<p>Il prossimo esempio dovrebbe aiutarti a capire come funziona la visibilità delle variabili nel C++:</p>
<pre><code>/** 
 * @file memoria-visibilita.cpp
 * Visibilità delle variabili.
 */
 
#include &lt;iostream&gt;

using namespace std;

/** 
 * Le variabili definite all&#39;esterno delle funzioni
 * si chiamano &quot;variabili globali&quot; e sono visibili
 * in tutto il codice. 
 */
const char* stringa = &quot;Stringa globale&quot;;

void funz() 
{    
    /** 
     * Le variabili definite all&#39;interno di una 
     * funzione sono visibili solo all&#39;interno
     * della funzione stessa. 
     */
    const char* stringa = &quot;Stringa esterna&quot;;
    
    /** Blocco di codice generico */
    {
        /** 
         * Le variabili definite all&#39;interno di un 
         * blocco di codice sono visibili solo 
         * all&#39;interno del blocco di codice. 
         */
        const char* stringa = &quot;Stringa interna&quot;;
        
        /** Mostra la variabile interna */
        cout &lt;&lt; &quot;blocco: &quot; &lt;&lt; stringa &lt;&lt; endl;
    }

    /** 
     * Qui è visibile la variabile esterna. 
     */
    cout &lt;&lt; &quot;funz:   &quot; &lt;&lt; stringa &lt;&lt; endl;

    /** 
     * L&#39;operatore :: permette di accedere alla 
     * variabile globale. 
     */
    cout &lt;&lt; &quot;funz:   &quot; &lt;&lt; ::stringa &lt;&lt; endl;
    
}

int main(int argc, char** argv)
{    
    /** Richiama la funzione esterna */
    funz();

    /** 
     * La funzione main non definisce una variabile
     * &quot;stringa&quot;, quindi mostra la variabile globale. 
     */
    cout &lt;&lt; &quot;main:   &quot; &lt;&lt; stringa &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, otterrai:</p>
<pre><code>% g++ src/cpp/memoria-visibilita.cpp -o src/out/esempio
% src/out/esempio                                      
blocco: Stringa interna
funz:   Stringa esterna
funz:   Stringa globale
main:   Stringa globale</code></pre>
<p>Come vedi, la stringa definita globalmente è visibile sia nella funzione <code>main</code> che nella funzione <code>funz</code>; la variabile definita all’inizio della funzione <code>funz</code> è visibile all’interno della funzione stessa, ma non nel blocco di codice, dove è visibile la nuova variabile <code>stringa</code>. L’ “aspettativa di vita” di ciascuna variabile dipende dal punto in cui è stata definita: la prima variabile esisterà per tutta la durata del programma; la seconda variabile viene creata quando si richiama la funzione <code>funz</code> e viene eliminata quando la funzone termina; la variabile all’interno del blocco di codice esiste solo per due istruzioni, poi il blocco di codice finisce e viene eliminata.<br />
Al contrario, quando un’area di memoria è allocata dinamicamente, rimane occupata fino a che il programma (o, più precisamente: il programmatore) non la rilascia con un’istruzione <code>delete</code>. Se il programma fa una sola chiamata, come nel nostro esempio, il fatto che una cinquantina di byte non siano disponibili per qualche minuto non crea grossi problemi (lo so per certo perché, nella prima versione dell’esempio, avevo dimenticato di aggiungere l’istruzione <code>delete</code> alla fine e il computer ha continuato a funzionare lo stesso), se però quello stesso programma continuasse a girare sullo stesso computer per lungo tempo, a poco a poco esaurirebbe tutta la memoria disponibile, causandone il blocco.<br />
Per questo motivo, il linguaggio con la “J” ha un sistema di <em>garbage collection</em> che, come le squadre di pulizia dei Servizi Segreti, provvede a eliminare le prove dell’incompetenza dei suoi programmatori prima che questa arrechi danno ai sistemi. Qualcuno ti dirà che non è vero, che i programmatori “J” sono dei professionisti competenti, ma ragiona: se esiste un sistema di raccolta dei rifiuti, ci dovrà pur essere qualcuno che li produce, no?</p>
<hr />
<p>Come le variabili del C++, anche gi esseri umani sono chiamati a vivere, svolgono il loro compito e alla fine vengono rimossi dal sistema. Le risorse che occupiamo sono un insieme di spazioni, invece che delle sequenze di byte, ma ciò che comunemente definiamo: <em>noi</em> non è altro che un modo di vedere le trasizioni di energia all’interno del sistema. A differenza delle variabili del software, però, gli esseri umani sono capaci di valutare l’esito delle loro scelte o delle loro azioni e possono decidere se ripetere quella scelta o quell’azione in altri cicli di vita dell’Universo. Siamo, allo stesso tempo, una parte del programma, i <em>beta-tester</em> e gli sviluppatori e, se ci accorgiamo di un’istruzione errata, possiamo modificarla nelle successive “esecuzioni” del programma, così come un giocatore di scacchi evita di ripetere una mossa che si è rivelata perdente. In questo modo, genereremo a una nuova variante della storia che, come una variante scacchistica, potrà rivelarsi migliore o peggiore di quelle precedenti.<br />
Un <em>Koan</em> molto famoso parla dello <em>Zen di ogni istante</em>:</p>
<blockquote>
<p>Gli studenti di Zen stanno con i loro maestri almeno dieci anni prima di presumere di poter insegnare a loro volta. Nan-in ricevette la visita di Tenno, che, dopo aver fatto il consueto tirocinio era diventato insegnante. Era un giorno piovoso, perciò Tenno portava zoccoli di legno e aveva con sé l’ombrello. Dopo averlo salutato, Nan-in disse: “Immagino che tu abbia lasciato gli zoccoli nell’anticamera. Vorrei sapere se hai messo l’ombrello alla destra o alla sinistra degli zoccoli”. Tenno, sconcertato, non seppe rispondere subito. Si rese conto che non sapeva portare il suo Zen in ogni istante. Diventò allievo di Nan-in e studiò ancora sei anni per perfezionare il suo Zen di ogni istante.<a href="/man/note#zen" class="nota"></a></p>
</blockquote>
<p>Il Maestro Canaro detestava questo <em>Koan</em> perché era molto distratto. Se Nan-in l’avesse fatta a lui, la domanda, probabilmente l’avrebbe guardato con aria infastidita e gli avrebbe chiesto: “Quali zoccoli?”. Malgrado ciò, ne riconosceva l’importanza perché più prestiamo attenzione a tutto ciò che facciamo, più errori riusciremo a identificare e, si spera, a correggere.</p>
<hr />
<p>Un’altra differenza fra gli esseri umani e il codice C++ è il nostro rapporto con l’operatore <code>delete</code>.<br />
Gli uomini hanno sempre avuto paura della morte e, da Gilgamesh in poi, hanno sempre cercato di sfuggirle o di annulare il suo operato. Arte, religione, scienza: potremmo dire che tutto ciò che di buono abbiamo prodotto come specie nasce dal naturale rifiuto della transitorietà della nostra esistenza. La morte è stata la causa e, talvolta, il soggetto dei migliori frutti del nostro ingegno. Tutte queste creazioni, nel tempo, hanno creato un bozzolo culturale che, da un lato, ci ha protetto dalla paura e, dall’altro, ci ha dato degli ideali comuni per cui lottare, anche se non sempre a fin di bene. Negli ultimi due secoli, però, la Scienza ha squarciato questo bozzolo, privando gli esseri umani delle loro bugie confortanti e sostituendole con delle certezze inquietanti, mentre il suo figlio scemo (il Movimento del ‘68) ha spazzato via delle parti sicuramente rivedibili, ma fondamentali della nostra Società senza darle nulla in cambio, tranne la minigonna.<br />
C’è un aneddoto apocrifo sul Maestro Canaro che parla proprio di questo:</p>
<blockquote>
Un giorno, la zia del Maestro Canaro lo chiamò e gli disse che il suo computer non funzionava più.<br />
«Si accende, ma non si connette a Internet e non riesce a spedire la posta elettronica. Ti prego, vieni ad aggiustarlo.»<br />
Il Maestro Canaro allora si recò dalla zia e le chiese di mostrargli il computer che non funzionava. La zia lo condusse nel suo studio e accese il PC portatile che era poggiato sulla scrivania. Come previsto, il computer si avviò regolarmente, ma quando il Maestro Canaro cercò di aprire il browser, comparve un messaggio di errore. Il Maestro allora provò ad aprire il programma per la posta elettronica, ma anche questa volta comparve un messaggio di errore.<br />
Sotto lo sguardo sempre più accorato di sua zia, il Maestro Canaro esaminò le impostazioni di rete, verificò che il modem funzionasse e fece un aggiornamento dei file di sistema, ma il problema rimase; così, il Maestro afferrò il computer e lo gettò dalla finestra.<br />
«Ma cosa hai fatto?!» esclamò la zia, esterrefatta.<br />
«Non funzionava, così l'ho buttato,» rispose il Maestro.<br />
«Ma non si poteva aggiustare?» chiese la zia, che ancora non riusciva a capacitarsi di ciò che era successo.<br />
«Forse sì, ma ci sarebbe voluto un sacco di tempo: meglio buttarlo via.»<br />
«E io adesso come lavoro, senza computer?» chiese la zia, attonita. Il Maestro Canaro si strinse nelle spalle.<br />
«Non ne ho idea, ma tanto non avresti potuto lavorare nemmeno con quello, perché era rotto.»<br />
«Lo so che era rotto!» esclamò la zia. «Ma quando una cosa necessaria è rotta, la si aggiusta, non la si butta via!»<br />
Lungi dall'apparire contrito, il Maestro Canaro si alzò in piedi e, fissando negli occhi la zia, esclamò:<br />
«E allora, voi, nel Sessantotto?!»
</blockquote>
<p>L’Umanità, messa di fronte all’ineluttabilità della fine e, allo stesso tempo, privata del conforto della religione e del sostegno della famiglia, ha reagito come un paziente a cui sia diagnosticato un male incurabile, elaborando il suo dolore secondo le cinque fasi definite dalla dottoressa Kübler Ross<a href="/man/note#kubler" class="nota"></a>:</p>
<p><em>Negazione:</em> così come l’Epoca vittoriana aveva il tabù del sesso, la nostra “cultura” ha il tabù della morte: i nostri bis-nonni fingevano di non avere interessi carnali, noi fingiamo che la morte non esista. La neghiamo a parole, usando dei giri di parole per non nominarla: “Se n’è andato”, “Non c’è più”, “È scomparso”, neanche si stesse parlando di un evaso o di un illusionista. La neghiamo nei fatti, isolando i moribondi nelle corsie d’ospedale, lontani dalle loro case e dai loro cari. La neghiamo nei nostri pensieri e nelle nostre azioni, perché altrimenti l’insensatezza delle nostre vite, spese inseguendo il miraggio effimero del successo<a href="/man/note#successo" class="nota"></a> diventerebbe evidente e innegabile.</p>
<p><em>Rabbia:</em> anche se rabbia e aggressività sono sempre state presenti nella nostra storia, dalla metà del Secolo scorso, oltre che dall’oppressione e dal disagio, hanno cominciato a fiorire rigogliose anche dal benessere. Gli scontri fra <em>Mods</em> e <em>Rockers</em> negli anni ‘60, le lotte armate degli anni ‘70, il <em>Punk</em> e, in tempi più recenti, i <em>foreign fighters</em> e l’aggressività nei <em>social-network</em>: nessuno di questi fenomeni nasce nei ghetti o da uno stato di bisogno, sono tutti degli <em>hobby</em> del Ceto medio.</p>
<p><em>Negoziazione:</em> nel 1982 Jane Fonda pubblicò una videocassetta nella quale insegnava a fare ginnastica aerobica<a href="/man/note#aerobica" class="nota"></a> nel salotto di casa a chiunque potesse permettersi di spendere sessanta Dollari<a href="/man/note#sessanta" class="nota"></a> per un VHS. Fu una delle videocassette più vendute di tutti i tempi e diede il via a una moda che divenne uno stile di vita per milioni di persone. La mania del <em>fitness</em>, insieme al rifiorire della spiritualità <em>New Age</em>, sono stati il modo in cui i popoli civilizzati hanno cercato di venire a patti con la nuova, terrificante realtà presentata loro dalla Scienza, prendendo atto dei proprii errori e cercando di porvi rimedio cambiando stile di vita. Sfortunatamente, però, gli pseudo-mistici non hanno mai capito che recitare il <em>Sutra del Loto</em> perché credi che possa aiutarti a realizzare i tuoi desiderii è una contraddizione in termini. La religione è come gli antibiotici: non fa effetto se non prendi la dose intera.</p>
<p><em>Depressione:</em> la sindrome depressiva è la seconda malattia più diffusa al Mondo, dopo i disturbi cardiaci, segno evidente che la fase di negoziazione non ha sortito gli effetti sperati. Fallito ogni tentativo di combattere la realtà, l’Uomo del terzo Millennio ha cercato scampo nella fuga. Così come il Giappone dei Tokugawa, si è rinchiuso in sé stesso<a href="/man/note#isolamento" class="nota"></a>, ma senza il rifiorire delle arti che si accompagnò al <em>Sakoku</em><a href="/man/note#sakoku" class="nota"></a>, perché la Realtà non è un predatore, che possiamo sperare di seminare. La realtà è ovunque e anche isolandoci non possiamo sfuggirle; anzi: la solitudine genera un <em>feedback</em> che amplifica lo stato di malessere e rende ancora più difficile e improbabile il raggiungimento dello stadio successivo.</p>
<p><em>Accettazione:</em> il solo modo per salvarsi è rinunciare agli insegnamenti dei cattivi maestri del passato e accettare il fatto di non essere delle gocce d’acqua uniche e insostituibili, ma di far parte del mare. Chi vuole, potrà credere che in quel mare ci sia Poseidone; gli altri saranno liberi di pensare che ci siano solo pesci, molluschi e alghe: non ha importanza; ciò che conta è sottrarsi all’influenza separatrice dell’Entropia e riacquistare un senso di appartenenza a qualcosa che va oltre le nostre brevi e limitate esistenze. Solo così, potremo vincere la nostra battaglia contro l’Annosa Dicotomia. Solo così, potremo smettere di inseguire una fama transeunte e trovare forza nella consapevolezza del fatto che ciascuno di noi può modificare l’evoluzione dell’Mondo con le sue azioni.<br />
Secondo lo <em>Yoga Sutra Bhāṣya</em><a href="/man/note#yoga" class="nota"></a>:</p>
<blockquote>
<p>Il Mondo intero subisce una mutazione a ogni istante; così, tutte le qualità esteriori del Mondo dipendono da questo istante presente.</p>
</blockquote>
<p>Così come tutti gli istanti sono importanti, per il Mondo, ciascun essere è importante per l’Universo, se svolge il compito che gli è stato assegnato; anche qualcuno o qualcosa che apparentemente è insignificante. È noto che il Maestro Canaro raggiunse il primo stato di Illuminazione quando vide un arbusto crescere su una parete di roccia a picco sul mare. Un arbusto apparentemente inutile: i suoi semi non avrebbero mai raggiunto una terra dove germogliare e i suoi rami erano troppo esili perché un uccello ci potesse costruire il suo nido; malgrado ciò, la caparbietà con cui quella pianta svolgeva il ruolo che gli era stato assegnato, permise al Maestro Canaro di capire ciò che molti libri non erano riusciti a spiegargli, posando la prima pietra di quello che sarebbe sato poi il suo insegnamento.<br />
Quello che noi percepiamo come il nostro “valore” è relativo. Pensa alla variabile <code>a</code> che abbiamo visto all’inizio:</p>
<pre><code>00000000 00000000 00000000 00000001</code></pre>
<p>Il bit iniziale vale <code>0</code>, che è un valore nullo, se lo consideri individualmente, ma se invece lo valuti in rapporto ai due byte a cui appartiene, diventa il valore da cui <a href="/man/tipi-di-dato#modificatori">dipende il segno della variabile</a>. Se per un caso il valore di quel bit diventasse <code>1</code>, il valore della variabile <code>a</code> diventerebbe negativo, con delle ripercussioni imprevedibili sul programma. Molte, troppe persone sono come quel bit e pensano di valere zero perché considerano il proprio valore solo in termini soggettivi. Mesmerizzati dall’Annosa Dicotomia, spendono tutte le loro energie cercando di valere <code>1</code> e si distraggono così da quello che sarebbe stato il loro destino, con conseguenze molto più gravi di un’alterazione di segno in una variabile.</p>
<hr />
<p>Il buon programmatore deve sempre controllare che il suo codice non contenga dei difetti e ciò che ti ho appena detto ne ha uno, piuttosto grave: può essere utilizzato come pretesto per creare un sistema di caste che limiti le possibilità di crescita di coloro che effettivamente sono destinati ad aumentare il loro valore. La domanda quindi è: come può, un bit o un essere senziente, decidere quale sia il suo valore esatto? Sicuramente non può dirglielo un’Autorità costituita né tanto meno una consuetudine. La famiglia può dargli dei suggerimenti, ma non può decidere per lui: i genitori hanno sicuramente più esperienza dei figli, ma non sono infallibili. La risposta è in una frase di Jacopone da Todi:</p>
<blockquote>
<p>Prima devi sape’ perché stai ar monno.<br />
Quanno sai er perché, te devi impara’ a stacce .</p>
</blockquote>
<p>In queste due frasi è racchiuso il senso della Vita: capire quale sia il proprio ruolo e svolgerlo al meglio delle proprie possibilità, senza farsi influenzare dalle mode e soprattutto senza cadere vittima dell’Annosa Dicotomia.<br />
Il C++ è un linguaggio a tipizzazione forte<a href="/man/note#tipizzazione" class="nota"></a>, perciò, quando si dichiara una variabile, le si deve sempre assegnare un tipo di dato:</p>
<pre><code>bool    booleano  = false;
char    carattere = &#39;C&#39;;
int     intero    = 1234567890;
float   decimale  = 3.14;
char    array[]   = &quot;abcdefghilmnopqrstuvz&quot;;</code></pre>
<p>Allo stesso modo, tutto ciò che esiste ha delle capacità che sono funzionali al suo ruolo nell’Universo. Suonare, scrivere, recitare, insegnare, convincere, guidare, amare: a ciascuno di noi, l’Universo dà uno strumento e un banco di lavoro, anche se il ruolo che ci verrà assegnato non sempre è evidente fin dalla nascita. Prendi Lech Walesa, per esempio (è l’unico Nobel per la Pace che mi viene in mente che non fosse laureato): lui cominciò a lavorare come elettricista navale, ma le sue capacità lo trasformarono in un leader politico<a href="/man/note#walesa" class="nota"></a>. Oppure, meglio, pensa a te stesso: se avessi voluto, a diciott’anni avresti potuto lasciare l’Ordine, tornare a casa e diventare un <em>vice-qualcosa</em> nell’azienda della tua famiglia, invece sei rimasto qui a scrivere il tuo libro. Sarà stata la scelta giusta? Cosa si aspettava, l’Universo, da te? che, come monaco, rendessi il Mondo un luogo migliore con la tua Bibbia per smanettoni o che, come manager, migliorassi le condizioni di vita dei dipendenti della tua azienda? Lo scopriremo solo quando torneremo a essere Uno; fino ad allora, potremo solo fare delle supposizioni, oppure chiederci: quale è stato, il motivo della tua scelta? Se sei rimasto qui per pigrizia o perché avevi paura del Mondo o della tua famiglia, hai fatto un errore. Se sei rimasto perché non desideri il lusso o il potere, potresti aver fatto la scelta giusta. Forse. Se sei rimasto, anche se sarebbe stato più facile e comodo tornare in seno alla tua famiglia, perché pensavi che restando qui saresti stato più utile, o sei terribilmente ingenuo o hai fatto la cosa giusta.<br />
A ogni modo, bisogna sempre fare bene il proprio mestiere, quale che sia, perché non sappiamo come e quando dovremo renderci utili. Una volta, un amico del Maestro Canaro, appena tornato dal Giappone, gli disse:</p>
<blockquote>
<p>La differenza fra noi e i Giapponesi è che se tu, qui, metti uno a pulire i cessi, quello si sente disprezzato e lavora male, mentre un giapponese cerca di diventare il miglior pulitore di cessi di tutto il Paese.</p>
</blockquote>
<p>Un altro modo per capire se si è nel giusto, è in base all’amore. L’amore è la droga perfetta: dà assuefazione come il <em>crack</em> e ti fa credere di saper volare, come l’LDS; è il miele con cui la Vita attira le formiche dei nostri pensieri, facendole andare dove vuole lei. Quindi, se quello che ti spinge ad agire è una qualche forma di amore — e non solo amore per qualcuno, ma anche per qualcosa, che sia il mare, la montagna, uno sport, una forma di arte o un lavoro — è molto probabile che tu stia facendo ciò che devi.<br />
Nell’ottica della gestione della memoria, l’amore ha anche un altro utilizzo, riassunto nel precetto:</p>
<blockquote>
<p>Amiamo ciò che ci ucciderà (se tutto va bene)</p>
</blockquote>
<p>Adesso, però, è tardi e questa lezione è stata fin troppo lunga; ne parleremo un’altra volta.</p>
</section>
</section>
<a href="/man/preprocessore" class="left" title="Vai a: Il preprocessore"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/funzioni" class="right" title="Vai a: Le funzioni"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/memoria" class="left" title="Vai a: La memoria"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/istruzioni-condizionali" class="right" title="Vai a: Istruzioni condizionali"><em></em></a>
<section id="le-funzioni-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Le funzioni</a></h1>
<blockquote>
Call me: IsNull
</blockquote>
<section class="testo">
<p>Le funzioni sono la caratteristica principale del C++.</p>
<p>Lo scopo delle funzioni è di migliorare la gestione del codice. È possibile scrivere un programma che abbia solo la funzione <code>main</code>, ma questo ha un senso solo per programmi molto semplici, come alcuni degli esempii che abbiamo visto finora. Il flusso di un programma <em>non banale</em>, come direbbe Stroutsup, sarà sempre suddiviso in più funzioni perché in questo modo il codice sarà più facile da leggere, da correggere e da modificare.</p>
<pre><code>/** 
 * @file tipi-di-dato-dimensione.cpp
 * Mostra la dimensione dei principali tipi di dato del C++.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

int main()
{    
    int w = 12;
    
    cout &lt;&lt; setw(w) &lt;&lt; &quot;bool: &quot;   &lt;&lt; sizeof(bool)   &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;char: &quot;   &lt;&lt; sizeof(char)   &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;int: &quot;    &lt;&lt; sizeof(int)    &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;float: &quot;  &lt;&lt; sizeof(float)  &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Questo è il codice di un esempio che abbiamo visto nella lezione sui <a href="/man/tipi-di-dato">tipi di dato</a>. Se decidessimo di modificare il modo in cui il programma mostra i dati all’utente, dovremmo intervenire su tutte le righe del programma, cosa che sarebbe noiosa e potrebbe generare degli errori. Al contrario, se isoliamo la funzione di visualizzazione, le eventuali modifiche o correzioni dovranno essere applicate solo in un punto. Il codice dell’esempio successivo è un esempio, perfettibile, di questo approccio:</p>
<pre><code>/** 
 * @file tipi-di-dato-limiti.cpp
 * Mostra i valori possibili per i principali tipi di dato del C++.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;limits&gt;

using namespace std;

/**
 * Funzione template che mostra la dimensione e i 
 * valori minimi e massimi per un tipo di dato.
 */
template&lt;typename T&gt;
void dimensione()
{
    cout &lt;&lt; sizeof(T) &lt;&lt; &quot; bytes,&quot;
         &lt;&lt; setw(4)   &lt;&lt; &quot;da:&quot;   
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::min()
         &lt;&lt; setw(4)   &lt;&lt; &quot;a:&quot;    
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::max() 
         &lt;&lt; endl;
}

int main()
{    
    /** Variazione della dimensione e dei valori del tipo int */
    cout &lt;&lt; setw(16) &lt;&lt; &quot;int: &quot;; 
    dimensione&lt;int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned int: &quot;; 
    dimensione&lt;unsigned int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;short int: &quot;; 
    dimensione&lt;short int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned short: &quot;; 
    dimensione&lt;unsigned short&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;long int: &quot;; 
    dimensione&lt;long int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned long: &quot;; 
    dimensione&lt;unsigned long&gt;();
    
    return 0;
}
</code></pre>
<p>Ogni volta che nel tuo codice ci sono delle istruzioni che si ripetono, valuta la possibilità di isolarle in una funzione. Per esempio, nella funzione <code>main</code> del programma qui sopra ci sono delle funzioni di output ripetute, cosa che complica la lettura del codice, ne rende laboriosa la modifica e aumenta la probabilità di fare degli errori, perché sei tu che definisci la stringa con il nome del tipo di dato e devi fare attenzione a scrivere il valore giusto ogni volta:</p>
<pre><code>cout &lt;&lt; setw(16) &lt;&lt; &quot;int: &quot;; 
...
cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned int: &quot;; 
...
cout &lt;&lt; setw(16) &lt;&lt; &quot;short int: &quot;; 
...
cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned short: &quot;; 
...
cout &lt;&lt; setw(16) &lt;&lt; &quot;long int: &quot;; 
...
cout &lt;&lt; setw(16) &lt;&lt; &quot;unsigned long: &quot;; </code></pre>
<p>Nel caso specifico, si trattava di una scelta inevitabile perché, essendo uno dei primi esempii che ti ho fatto, non volevo complicarti troppo le idee, ma non è questo il modo corretto di scrivere codice. È sbagliato (o, quanto meno, rischioso) mischiare elaborazione dei dati e funzioni di interfaccia, specie in questo caso, dove parte dell’output è già demandato a una funzione specifica. Meglio lasciare che sia la funzione <code>dimensione</code> a gestire tutto l’output, mentre la funzione <code>main</code> si limiterà a definire il flusso dell’elaborazione, richiamando la funzione di output per i tipi di dato che ci interessano:</p>
<pre><code>/** 
 * @file funzioni-limiti-modificato.cpp
 * Esempio sui limiti del C++ con output in un&#39;unica funzione.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;limits&gt;
#include &lt;typeinfo&gt;
#include &lt;cxxabi.h&gt;

using namespace std;

/** 
 * Mostra il nome, la dimensione e i valori minimi 
 * e massimi per il tipo di dato corrente.
 */
template&lt;typename T&gt;
void dimensione()
{
    cout &lt;&lt; setw(14)  
         &lt;&lt; abi::__cxa_demangle(typeid(T).name(), NULL, NULL, NULL) 
         &lt;&lt; &quot;: &quot;
         &lt;&lt; sizeof(T) &lt;&lt; &quot; bytes,&quot;
         &lt;&lt; setw(4)   &lt;&lt; &quot;da:&quot;   
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::min()
         &lt;&lt; setw(4)   &lt;&lt; &quot;a:&quot;    
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::max() 
         &lt;&lt; endl;
}

/** 
 * Il nuovo codice della funzione main:  più compatto 
 * e più facile da leggere o modificare.
 */
int main(int argc, char** argv)
{    
    dimensione&lt;int&gt;();
    dimensione&lt;short int&gt;();
    dimensione&lt;unsigned short&gt;();
    dimensione&lt;long int&gt;();
    dimensione&lt;unsigned long&gt;();
    return 0;
}
</code></pre>
<p>L’istruzione:</p>
<pre><code>abi::__cxa_demangle(typeid(T).name(), NULL, NULL, NULL);</code></pre>
<p>mostra il tipo di dato della variabile corrente. Per il momento, accettala in maniera dogmatica; ti spiegherò il comportamento dell’operatore <code>::</code> quando parleremo delle classi.<br />
L’output di questo codice è identico a quello dell’esempio precedente; anzi: è un po’ meglio, perché ho ridotto la spaziatura della prima colonna da 16 a 14 caratteri e l’ho fatto modificando solo un’istruzione <code>setw(14)</code>, contro le sei del codice precedente:</p>
<pre><code>% g++ src/cpp/funzioni-limiti-modificato.cpp -o src/out/esempio
% src/out/esempio                                              
           int: 4 bytes, da:          -2147483648  a:           2147483647
         short: 2 bytes, da:               -32768  a:                32767
unsigned short: 2 bytes, da:                    0  a:                65535
          long: 8 bytes, da: -9223372036854775808  a:  9223372036854775807
 unsigned long: 8 bytes, da:                    0  a: 18446744073709551615</code></pre>
<hr />
<p>Le funzioni sono uno dei <a href="/man/tipi-di-dato#funzioni">tipi di dato</a> del C++ e, come tutti i tipi di dato, possono essere <em>dichiarate</em> e <em>definite</em>.<br />
La <span id="dichiarazione">dichiarazione</span> di una funzione stabilisce il suo tipo di ritorno e i parametri richiesti in input:</p>
<pre><code>float scorporaIVA(long stipendio, float aliquota);</code></pre>
<p>La <span id="definizione">definizione</span> di una funzione, ne stabilisce il comportamento:</p>
<pre><code>float scorporaIVA(long stipendio, float aliquota)
{
    float valore;
    valore = stipendio / ((100 + aliquota) / 100);
    return valore;
}</code></pre>
<p>Come ti ho detto quando abbiamo parlato dei <a href="/man/linguaggi-di-programmazione">linguaggi di programmazione</a>, la generazione di un file eseguibile avviene in due fasi: per prima cosa il compilatore converte il codice C++ in un <em>file oggetto</em>, poi il <em>linker</em> trasforma i file oggetto (potrebbero essere più d’uno) in un unico eseguibile. Perché questo processo possa funzionare, la <em>dichiarazione</em> di una funzione deve essere presente in tutti i brani di codice che la utilizzano, per consentire al compilatore di controllare che l’utilizzo che se ne fa sia corretto; la <em>definizione</em>, al contrario, deve comparire solo una volta.</p>
<pre><code>/** 
 * @file funzioni-stipendio-main.cpp
 * Funzione main del programma con file oggetto separati.
 */
#include &lt;iostream&gt; 

/** 
 * Dichiarazione della funzione raddoppiaStipendio. 
 * L&#39;ho messa qui per semplicità: di solito, le dichiarazioni
 * si trovano in un file di include separato.
 */
float raddoppiaStipendio(float stipendio);

/**
 * La funzione main richiama la funzione raddoppiaStipendio,
 * che è definita in un altro file sorgente.
 */
int main(int argc, char** argv)
{        
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;    
    return 0;
}
</code></pre>
<pre><code>/** 
 * @file funzioni-stipendio-funz.cpp
 * Funzione del programma con file oggetto separati.
 */

/** 
 * Definizione della funzione raddoppiaStipendio. 
 */
float raddoppiaStipendio(float stipendio)
{
    return stipendio * 2;
}
</code></pre>
<p>Se compiliamo separatamente i due file qui sopra, aggiungendo il parametro <code>-c</code>, che dice al compilatore di generare solo il file oggetto senza richiamare il linker per la generazione di un eseguibile:</p>
<pre><code>% g++ -c src/cpp/funzioni-stipendio-main.cpp -o src/out/main.o
% g++ -c src/cpp/funzioni-stipendio-funz.cpp -o src/out/funz.o</code></pre>
<p>e poi generiamo un file eseguibile utilizzando i due file oggetto:</p>
<pre><code>% g++ -o src/out/esempio src/out/main.o src/out/funz.o        </code></pre>
<p>otterremo tre file, due <em>object-file</em> e il file eseguibile <code>esempio</code>, che darà il risultato atteso:</p>
<pre><code>% ls -1 src/out                                               
esempio
funz.o
main.o

% src/out/esempio                                             
3000</code></pre>
<p>Ma siccome io sono pigro, negli esempii che ti farò, utilizzerò sempre un comando unico per la compilazione e il <em>linking</em> dei programmi:</p>
<pre><code>g++ src/cpp/funzioni-stipendio-funz.cpp  \                                                       
    src/cpp/funzioni-stipendio-main.cpp  \
    -o src/out/esempio
% src/out/esempio                                                                                 
3000</code></pre>
<p>Se non dichiarassimo la funzione <code>raddoppiaStipendio</code> nel file che contiene la funzione <code>main</code>, il compilatore ci darebbe l’errore:</p>
<pre><code>src/cpp/funzioni-stipendio-main.cpp:19:18: error: use of undeclared identifier &#39;raddoppiaStipendio&#39;
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;                     ^
1 error generated.</code></pre>
<p>Otterremmo lo stesso errore se definissimo una funzione dopo che un altra parte del programma l’ha richiamata:</p>
<pre><code>/** 
 * @file funzioni-stipendio-errore.cpp
 * Funzione che genera un errore di compilazione.
 */
#include &lt;iostream&gt; 

/**
 * La funzione main richiama la funzione raddoppiaStipendio,
 * ma il compilatore ancora non sa che esiste: errore.
 */
int main(int argc, char** argv)
{        
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;    
    return 0;
}

/** 
 * Definizione della funzione raddoppiaStipendio DOPO
 * il suo utilizzo da parte della funzione main. 
 */
float raddoppiaStipendio(float stipendio)
{
    return stipendio * 2;
}
</code></pre>
<pre><code>g++ -c src/cpp/funzioni-stipendio errore.cpp                                                    

src/cpp/funzioni-stipendio-errore.cpp:13:18: error: use of undeclared identifier &#39;raddoppiaStipendio&#39;
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;    
                 ^
1 error generated.
</code></pre>
<p>Quando si scrive un programma in un unico file sorgente, o si definiscono le diverse funzioni prima che vengano utilizzate, mettendo la funzione <code>main</code> in fondo, oppure le si deve dichiarare all’inizio del file. (In realtà, non occorre metterle tutte all’inizio del file, basta che la dichiarazione preceda l’utilizzo, ma è più scomodo: mettile all’inizio.)<br />
Avresti ottenuto un errore di compilazione anche se avessi provato a separare in due file distinti la funzione <code>main</code> e la funzione <code>dimensione</code> dell’esempio qui sopra, anche se avessi dichiarato <code>dimensione</code> prima del suo utilizzo nella funzione <code>main</code>:</p>
<pre><code>% g++ src/cpp/funzioni-limiti-main.cpp -c -o src/out/main.o         
src/cpp/funzioni-limiti-main.cpp:19:5: error: use of undeclared identifier &#39;dimensione&#39;
    dimensione&lt;int&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:19:19: error: expected &#39;(&#39; for function-style cast or type construction
    dimensione&lt;int&gt;();
               ~~~^
src/cpp/funzioni-limiti-main.cpp:19:21: error: expected expression
    dimensione&lt;int&gt;();
                    ^
src/cpp/funzioni-limiti-main.cpp:20:5: error: use of undeclared identifier &#39;dimensione&#39;
    dimensione&lt;short int&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:20:22: error: expected &#39;(&#39; for function-style cast or type construction
    dimensione&lt;short int&gt;();
               ~~~~~ ^
src/cpp/funzioni-limiti-main.cpp:21:5: error: use of undeclared identifier &#39;dimensione&#39;
    dimensione&lt;unsigned short&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:21:25: error: expected &#39;(&#39; for function-style cast or type construction
    dimensione&lt;unsigned short&gt;();
               ~~~~~~~~ ^
src/cpp/funzioni-limiti-main.cpp:22:5: error: use of undeclared identifier &#39;dimensione&#39;
    dimensione&lt;long int&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:22:21: error: expected &#39;(&#39; for function-style cast or type construction
    dimensione&lt;long int&gt;();
               ~~~~ ^
src/cpp/funzioni-limiti-main.cpp:23:5: error: use of undeclared identifier &#39;dimensione&#39;
    dimensione&lt;unsigned long&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:23:25: error: expected &#39;(&#39; for function-style cast or type construction
    dimensione&lt;unsigned long&gt;();
               ~~~~~~~~ ^</code></pre>
<p>Questo avviene perché i <code>template</code> non sono vere funzioni, ma solo degli schemi che il compilatore utilizza per generare la versione corretta del codice. La dichiarazione delle funzioni template, quindi deve comprendere anche la loro definizione, per dare modo al compilatore di gestire appropriatamente la chiamata<a href="/man/note#template" class="nota"></a>.</p>
<hr />
<p>Prima ti ho detto di <em>valutare</em> la possibilità di isolare in una funzione le istruzioni che si ripetono all’interno del tuo codice, perché non sempre creare una funzione è la scelta corretta.<br />
Il software, come molte attività umane, è il frutto di una serie di compromessi e tu dovrai fare scelte architetturali differenti a seconda del tipo di programma che devi realizzare. Un buon software, oltre che funzionare correttamente, dovrebbe essere veloce, facile da modificare e richiedere poche risorse di sistema. Alle volte, però, si deve sacrificare una di queste caratteristiche positive per esaltarne un’altra. Per esempio, se dovessi scrivere un software estremamente veloce, potrebbe essere meglio avere delle istruzioni duplicate che delle chiamate a funzione, perché richiamare una funzione causa inevitabilmente dei rallentamenti. Però, se replichi delle istruzioni, non solo aumenti le dimensioni del programma, ma lo rendi anche più difficile da leggere e da modificare, che è male.<br />
In questi casi, l’aumento delle dimensioni del codice è inevitabile, ma le <em>funzioni inline</em> ti permettono di mantenere il codice leggibile e modificabile:</p>
<pre><code>/** 
 * @file funzioni-inline-1.cpp
 * Esempio di codice con istruzioni ripetute.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt;

#define S_FILENAME  &quot;src/out/esempio.txt&quot;

using namespace std;

int main(int argc, char** argv)
{        
    /** 
     * Crea una variabile di classe ofstraeam 
     * per gestire il file di output  */
    ofstream doc;

    /** Apre il file di output */
    doc.open (S_FILENAME);
    cout &lt;&lt; &quot;ho aperto il file &quot; &lt;&lt; endl;

    /** Scrive sul file di output */
    doc &lt;&lt; &quot;Testo del documento.\n&quot;;
    cout &lt;&lt; &quot;ho scritto sul file&quot; &lt;&lt; endl;

    /** Chiude il file di output */
    doc.close();
    cout &lt;&lt; &quot;ho chiuso il file&quot; &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Compilando ed eseguendo il codice qui sopra, ottieni:</p>
<pre><code>% g++ src/cpp/funzioni-inline-1.cpp -o src/out/esempio
% ./src/out/esempio                                   
ho aperto il file 
ho scritto sul file
ho chiuso il file</code></pre>
<p>Le istruzioni di output nell’esempio si differenziano solo per il testo da visualizzare e potrebbero benissimo essere isolate in una funzione autonoma.</p>
<pre><code>/** 
 * @file funzioni-inline-2.cpp
 * Esempio di codice con funzione di output unica.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

#define S_FILENAME  &quot;src/out/esempio.txt&quot;

using namespace std;

/** Funzione di output unica */
void log(const char* messaggio)
{
    /** Mostra il messaggio a video */
    cout &lt;&lt; messaggio &lt;&lt; endl;
}

int main(int argc, char** argv)
{        
    /** Crea una variabile per gestire il file di output */
    ofstream doc;

    /** Apre il file di output */
    doc.open (S_FILENAME);
    log(&quot;ho aperto il file&quot;);

    /** Scrive sul file di output */
    doc &lt;&lt; &quot;Testo del documento.\n&quot;;
    log(&quot;ho scritto sul file&quot;);

    /** Chiude il file di output */
    doc.close();
    log(&quot;ho scritto il file&quot;);

    return 0;
}
</code></pre>
<p>L’output di questo programma è identico a quello dell’esempio precedente, ma se aggiungi la parola chiave <code>inline</code> prima del tipo di ritorno della funzione <code>log</code>:</p>
<pre><code>inline void log(const char* messaggio)
{
    /** Mostra il messaggio a video */
    cout &lt;&lt; messaggio &lt;&lt; endl;
}</code></pre>
<p>e compili nuovamente il programma, vedrai che la dimensione del file eseguibile è aumentata, perché il compilatore ha sostituito tutte le chiamate a funzione con una copia del codice della funzione stessa. Anche se le dimensioni dell’eseguibile sono aumentate, il codice è ancora facilmente leggibile e modificabile:</p>
<pre><code>/** 
 * @file funzioni-inline-3.cpp
 * Esempio di funzione inline.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

#define LOG_DEBUG   1
#define LOG_AVVISO  2
#define LOG_ERRORE  3

#define S_DEBUG     &quot;debug&quot;
#define S_AVVISO    &quot;avviso&quot;
#define S_ERRORE    &quot;errore&quot;

#define ERR_NO_FILE_NAME  -1
#define ERR_NO_FILE_OPEN  -2

using namespace std;

/** Funzione di output inline */
inline void log(const char* messaggio, int livello)
{
    /** Definisce la spaziatura del primo campo */
    cerr &lt;&lt; setw(7);  
    
    /** Scrive il livello del messaggio */
    switch(livello) {
        case LOG_DEBUG:  cerr &lt;&lt; S_DEBUG ; break;
        case LOG_AVVISO: cerr &lt;&lt; S_AVVISO; break;
        default:         cerr &lt;&lt; S_ERRORE; break;
    }
    
    /** Scrive il testo del messaggio */
    cerr &lt;&lt; &quot;: &quot; &lt;&lt; messaggio &lt;&lt; endl;
}

int main(int argc, char** argv)
{        
    /** Crea una variabile per gestire il file di output */
    ofstream doc;

    /** Puntatore per il nome del file di output */
    const char* filename = NULL;

    /** Se manca il nome del file di output, errore */
    if(argc &lt; 2) {
        log(&quot;specificare il path del file&quot;, LOG_ERRORE);
        return ERR_NO_FILE_NAME;
    }
    
    /** Legge il nome del file di output */
    filename = argv[1];
    
    /** Prova ad aprire il file di output */    
    doc.open (argv[1]);
    
    /** Se c&#39;è stato un errore, lo segnala ed esce */
    if(!doc.is_open()) {
        log(&quot;impossibile aprire il file&quot;, LOG_ERRORE);    
        return ERR_NO_FILE_OPEN;    
    }
    
    /** OK, il file è pronto */
    log(&quot;ho aperto il file&quot;, LOG_AVVISO);

    /** Scrive sul file di output */
    doc &lt;&lt; &quot;Testo del documento.\n&quot;;
    log(&quot;ho scritto sul file&quot;, LOG_DEBUG);

    /** Chiude il file di output */
    doc.close();
    log(&quot;ho chiuso il file&quot;, LOG_AVVISO);

    return 0;
}
</code></pre>
<p>Se compili il codice e lo esegui, ottieni:</p>
<pre><code>% g++ src/cpp/funzioni-inline-3.cpp -o src/out/esempio

% src/out/esempio                                     
 errore: specificare il path del file

% src/out/esempio /esempio.txt                        
 errore: impossibile aprire il file

% src/out/esempio src/out/esempio.txt                 
 avviso: ho aperto il file
  debug: ho scritto sul file
 avviso: ho chiuso il file</code></pre>
<p>Per la cronaca: nel secondo caso, il programma fallisce perché l’utente non ha privilegi di scrittura nella <em>root-directory</em>.</p>
<hr />
<p>L’esistenza di una funzione <code>inline</code> ricorda un po’ un passo del <em>Samyutta Nikaya</em>:</p>
<blockquote>
<p>Non esiste distinzione fra un essere, la sua funzione e il tempo della sua apparizione. Gli esseri appaiono dalla non-esistenza, esistono per un istante e poi cessano di esistere. La loro esistenza, attività e azione sono un’unica cosa. Passato e futuro sono meri nomi.<a href="/man/note#samyutta" class="nota"></a></p>
</blockquote>
<p>In generale, comunque, il ciclo di vita di una funzione prevede tre fasi distinte: la <em>dichiarazione</em>, la <em>definizione</em> e il suo successivo utilizzo:</p>
<pre><code>/** Dichiarazione */
float raddoppiaStipendio(float stipendio);

/** Definizione */
float raddoppiaStipendio(float stipendio)
{
    return stipendio * 2;
}

/** Chiamata */
float importo = raddoppiaStipendio(1500);
</code></pre>
<p>Solo la funzione <code>main</code> fa eccezione a questa regola, perché non richiede una dichiarazione e non viene richiamata da altre funzioni. La variabile <code>float stipendio</code>, che compare fra parentesi sia nella dichiarazione che nella definizione della funzione, viene detta: <em>parametro</em> della funzione. Il valore <code>1500</code> che viene attribuito al parametro nella chiamata a funzione, è detto: <em>argomento</em>. Queste variabili sono chiamate anche: <em>parametri formali</em>, nel caso della dichiarazione e della definizione e: <em>parametri attuali</em>, nel caso della chiamata.<br />
Quando richiami una funzione, le puoi passare gli argomenti in tre modi: per <em>valore</em>, per <em>riferimento</em>, per <em>puntatore</em>:</p>
<pre><code>/** 
 * @file funzioni-argomenti.cpp
 * Esempio di gestione degli argomenti di una funzione.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

using namespace std;

/**
*   Chiamata per valore: tutto quello che succede qui
*   alle variabili a e b non influenza le variabili 
*   x e y della funzione chiamante.
*/
void perValore(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
    return;
}

/**
*   Chiamata per reference: tutto quello che succede qui
*   alle variabili a e b è come se fosse fatto alle variabili
*   x e y della funzione chiamante.
*/
void perRiferimento(int &amp;a, int &amp;b)
{
    int tmp = a;
    a = b;
    b = tmp;
    return;
}

/**
*   Chiamata per puntatore: anche qui, quello che succede 
*   alle variabili a e b avviene anche alle variabili x e y 
*   della funzione chiamante, ma il codice è meno chiaro.
*/
void perPuntatore(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
    return;
}

int main(int argc, char** argv)
{        
    int  x = 11; int  y = 22;    
    cout &lt;&lt; setw(20) &lt;&lt; &quot;Valore iniziale: x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;
    
    int* p = &amp;x;
    int&amp; r = x;
    
    cout &lt;&lt; &quot;p:&quot; &lt;&lt; p &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;

    /**
    *   Passaggio per valore: l&#39;argomento della chiamata
    *   a funzione è il valore delle variabili x e y:
    */
    perValore(x,y);
    cout &lt;&lt; setw(20) &lt;&lt; &quot;perValore: x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;

    /**
    *   Passaggio per reference: l&#39;argomento della chiamata
    *   a funzione sono le variabili x e y, ma la funzione 
    *   utilizzerà dei loro alias, non il loro valore:
    */
    perRiferimento(x,y);
    cout &lt;&lt; setw(20) &lt;&lt; &quot;perRiferimento: x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;

    /**
    *   Passaggio per puntatore: l&#39;argomento della chiamata
    *   è esplicitamente l&#39;indirizzo delle variabili x e y:
    */
    perPuntatore(&amp;x,&amp;y);
    cout &lt;&lt; setw(20) &lt;&lt; &quot;perPuntatore: x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>L’output di questo programma è:</p>
<pre><code>% g++ src/cpp/funzioni-argomenti.cpp -o src/out/esempio
% src/out/esempio                                      
Valore iniziale: x=11, y=22
      perValore: x=11, y=22
 perRiferimento: x=22, y=11
   perPuntatore: x=11, y=22</code></pre>
<p>Passare la <em>reference</em> a una variabile come argomento di una funzione equivale a passarle la variabile stessa. Questo può essere un bene nel caso di funzioni che richiedano in input oggetti di grosse dimensioni o che abbiano la necessità di modificare direttamente il valore delle variabili passategli come parametri, ma va evitato in qualsiasi altro caso, perché permette al programma di modifi­care il valore di una variabile in maniera subdola, che può essere molto difficile da scoprire in caso di errori.<br />
Un’altra cosa da sapere, a proposito dei parametri delle funzioni, è che possono avere dei valori di default:</p>
<pre><code>/** 
 * @file _man/src/funzioni-parametri-default.cpp
 * Esempio di funzione con parametri di default.
 */

#include &lt;iostream&gt;

using namespace std;

/** Funzione con parametri di default  */
void stampaValore(int valore = 0)
{
    /** Stampa a video il valore del parametro */
    cout &lt;&lt; &quot;Valore: &quot; &lt;&lt; valore &lt;&lt; endl;
}

int main(int argc, char** argv)
{        
    /** Richiama la funzione con un argomento */
    stampaValore(123);

    /** Richiama la funzione senza argomenti */
    stampaValore();

    return 0;
}
</code></pre>
<p>L’output di questo programma sarà:</p>
<pre><code>% g++ src/cpp/funzioni-parametri-default.cpp -o src/out/esempio
% src/out/esempio 
Valore: 123
Valore: 0</code></pre>
<p>Il valore di default del parametro deve essere indicato nella dichiarazione della funzione. Ricordati però che, quando si assegna un valore di default a uno dei parametri di una funzione, bisogna fare altrettanto con tutti i parametri che lo seguono, se ce ne sono:</p>
<pre><code>void funz1(float f, void * ptr = NULL);        // OK
void funz2(double d, int b = 2, char c = &#39;c&#39;); // OK
void funz3(int i = 3, int n );                 // ERRORE!</code></pre>
<p>I valori di default si utilizzano quando a uno o più parametri della funzione è assegnato spesso un determinato valore. Per esempio, se la funzione <code>log</code> che abbiamo visto nell’esempio precedente fosse richiamata prevalentemente con uno stesso valore per il parametro <code>livello</code>, glielo si potrebbe assegnare come default:</p>
<pre><code>inline void log(const char* messaggio, int livello = LOG_AVVISO);</code></pre>
<p>rendendo la scrittura del codice più facile e veloce:</p>
<pre><code>log(&quot;ho aperto il file&quot;);

doc &lt;&lt; &quot;Testo del documento.\n&quot;;
log(&quot;ho scritto sul file&quot;, LOG_DEBUG);

doc.close();
log(&quot;ho chiuso il file&quot;);</code></pre>
<hr />
<p>In una delle nostre <a href="/man/programmatore">prime chiacchierate</a>, ti ho detto che il Buon Programmatore, mentre scrive il codice, si chiede sempre se possa esistere sistema più efficiente di fare ciò che sta facendo. Oggi ne hai avuto una dimostrazione: abbiamo migliorato il primo esempio del paragrafo sulle funzioni <code>inline</code> unificando la gestione dei messaggi in un’unica funzione e poi l’abbiamo migliorato ancora rendendo quella funzione <code>inline</code>. C’è un problema, però: l’output del programma:</p>
<pre><code>% ./src/out/esempio                                   
ho aperto il file 
ho scritto sul file
ho chiuso il file</code></pre>
<p>va bene solo se il file da gestire è uno solo, come nel nostro caso. Se però ci fossero due (o più) file di input o di output, sarebbe utile sapere a <em>quale</em> file si riferisca il messaggio. Per risolvere il problema, potremmo aumentare il numero di parametri formali della funzione <code>log</code>:</p>
<pre><code>void log(int livello, const char* messaggio, const char* file);</code></pre>
<p>ma il nuovo parametro sarebbe inutile nel caso di chiamate come:</p>
<pre><code>log(LOG_ERRORE, &quot;specificare il path del file&quot;);</code></pre>
<p>In alternativa, potremmo definire il messaggio all’interno della funzione chiamante:</p>
<pre><code>string s1 = &quot;ho chiuso il file: &quot;;
string s2 = filename;
string s3 = s1 + s2;
log(LOG_AVVISO, s3.c_str());</code></pre>
<p>ma questo renderebbe il codice più pesante, più complicato e più lento; inoltre, trasferirebbe nelle funzioni chiamanti parte delle funzionalità di output che avevamo felicemente isolato nella funzione <code>log</code>.<br />
La soluzione corretta per questo tipo di problemi sono le <em>funzioni con parametri variabili</em>.<br />
Un esempio tipico di questo tipo di funzioni lo abbiamo visto con la funzione del linguaggio C <code>printf</code>, che ha un primo argomento che serve a determinare il tipo e il numero degli argomenti che seguono:</p>
<pre><code>/** Dichiarazione, nel file stdio.h */
int printf(const char *format, ...) ;

/** Utilizzo */
printf(&quot;stringa: %s; intero: %d&quot;, &quot;codice errore&quot;, -1);
</code></pre>
<p>Per indicare degli argomenti variabili, nella dichiarazione di una funzione, si utilizzano tre punti, dopo i parametri fissi:</p>
<pre><code>void log(int livello, int n_parametri, ...);</code></pre>
<p>Nella definizione della funzione, per gestire i parametri, è necessario creare un ciclo di lettura utilizzando tre marco definite nel file <code>stdarg.h</code>:</p>
<pre><code>void va_start(va_list ap, lastfix);
type va_arg(va_list ap, type);
void va_end(va_list ap);</code></pre>
<p><code>va_start</code> inizializza la lista di variabili <code>ap</code> affinché possa ricevere gli argomenti variabili; il parametro <code>lastfix</code> specifica quale sia l’ultimo parametro fisso della funzione.</p>
<p><code>va_arg</code> torna il successivo parametro nella lista <code>ap</code>; il parametro <code>type</code> indica il tipo di dato del parametro.</p>
<p><code>va_end</code> termina l’elaborazione dei parametri e deve essere sempre chiamata prima che la funzione termini.</p>
<pre><code>/** 
 * @file funzioni-variabili.cpp
 * Esempio di funzione con parametri variabili.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

#define LOG_DEBUG   1
#define LOG_AVVISO  2
#define LOG_ERRORE  3

#define S_DEBUG     &quot;debug&quot;
#define S_AVVISO    &quot;avviso&quot;
#define S_ERRORE    &quot;errore&quot;

#define ERR_NO_FILE_NAME  -1
#define ERR_NO_FILE_OPEN  -2

#define S_ERR_NO_FILE_NAME  &quot;specificare il path del file&quot;
#define S_ERR_NO_FILE_OPEN  &quot;impossibile aprire il file:&quot;

using namespace std;

/** Funzione di output con parametri variabili */
void log(int livello, int n_parametri, ...)
{

    /** Definisce la spaziatura del primo campo */
    cerr &lt;&lt; setw(8);  
    
    /** Scrive il livello del messaggio */
    switch(livello) {
        case LOG_DEBUG:  cerr &lt;&lt; S_DEBUG ; break;
        case LOG_AVVISO: cerr &lt;&lt; S_AVVISO; break;
        default:         cerr &lt;&lt; S_ERRORE; break;
    }

    /** Scrive il carattere di separazione */
    cerr &lt;&lt; &quot; | &quot;;

    /** Dichiara la variabile per la lista dei parametri */    
    va_list lista_parametri;
    
    /** 
     * Inizializza la lista dei parametri e considera
     * tutti gli argomenti dopo n_parametri come variabili.
     */
    va_start(lista_parametri, n_parametri);

    /** Legge tutti i parametri nella lista e li scrive a video */
    for(int p = 1; p &lt;= n_parametri; p++) {        
        cerr &lt;&lt; va_arg(lista_parametri, char*) ;        
    }    

    /** Chiude la lista dei parametri */        
    va_end(lista_parametri);
    
    /** Scrive il testo del messaggio */
    cerr &lt;&lt; endl;

}

int main(int argc, char** argv)
{        
    /** Crea una variabile per gestire il file di output */
    ofstream doc;

    /** Puntatore per il nome del file di output */
    const char* filename = NULL;

    /** Se manca il nome del file di output, errore */
    if(argc &lt; 2) {
        log(LOG_ERRORE, 1, S_ERR_NO_FILE_NAME);
        return ERR_NO_FILE_NAME;
    }
    
    /** Legge il nome del file di output */
    filename = argv[1];
    
    /** Prova ad aprire il file di output */    
    doc.open (argv[1]);
    
    /** Se c&#39;è stato un errore, lo segnala ed esce */
    if(!doc.is_open()) {
        log(LOG_ERRORE, 2, S_ERR_NO_FILE_OPEN, filename);    
        return ERR_NO_FILE_OPEN;    
    }
    
    /** OK, il file è pronto */
    log(LOG_AVVISO, 2, &quot;ho aperto il file: &quot;, filename);

    /** Scrive sul file di output */
    doc &lt;&lt; &quot;Testo del documento.\n&quot;;
    log(LOG_DEBUG, 2, &quot;ho scritto sul file: &quot;, filename);

    /** Chiude il file di output */
    doc.close();
    log(LOG_AVVISO, 2,  &quot;ho chiuso il file: &quot;, filename);

    return 0;
}
</code></pre>
<p>L’output di questo codice è:</p>
<pre><code>% g++ src/cpp/funzioni-variabili.cpp -o src/out/esempio

% src/out/esempio                    
  errore | specificare il path del file

% src/out/esempio /esempio.txt 
  errore | impossibile aprire il file:/esempio.txt

% src/out/esempio src/out/esempio.txt
  avviso | ho aperto il file: src/out/esempio.txt
   debug | ho scritto sul file: src/out/esempio.txt
  avviso | ho chiuso il file: src/out/esempio.txt```</code></pre>
<hr />
<p>A questo punto, non mi resta che parlarti delle funzioni che richiamano sé stesse, ovvero, le <em>funzioni ricorsive</em>:</p>
<pre><code>/** 
 * @file /src/funzioni-ricorsiva.cpp
 * Esempio di funzione ricorsiva.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione della funzione ricorsiva */
long fattoriale(int n);

/** Funzione main prima della definizione */
int main(int argc, char** argv)
{   
    int n = 9;
    cout &lt;&lt; n &lt;&lt; &quot;! = &quot; &lt;&lt; fattoriale(n) &lt;&lt; endl;
    return 0;
}

/** Definizione della funzione ricorsiva */
long fattoriale(int n)
{
    long fatt = 1;
    if(n &gt; 1) {
        fatt = n * fattoriale(n-1);
    }
    return fatt;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/funzioni-ricorsiva.cpp -o src/out/esempio
&gt; src/out/esempio                                      
 1 2 3 4 5 6 7 8 9</code></pre>
<p>Attenzione, però: una funzione che richiama sé stessa, se non è scritta bene, può generare una ricorsione in[de]finita, come due specchi posti l’uno di fronte all’altro. Lo spazio prospettico all’interno degli specchi è inesauribile, ma la memoria dei computer, per quanto estesa, ha i suoi limiti e un numero eccessivo di ricorsioni potrebbe generare uno <em>stack overflow</em>.<a href="/man/note#stack" class="nota"></a> Per questo motivo, bisogna ricorrere alla ricorsione solo nei casi in cui è indispensabile, preferendole, quando possibile, le <a href="https://chiplusplus.org/man/istruzioni-iterative">istruzioni iterative</a> e applicando sempre dei meccanismi di controllo della profondità di ricorsione che prevengano un sovraccarico dello stack.<br />
Un altro tipo di ricorsione di cui diffidare è quella con cui si cerca, alle volte, di dare credibilità a una convinzione priva di fondamenti reali utilizzando un’altra convinzione simile.</p>
<hr />
<p>In un romanzo sulla vita dello spadaccino giapponese Myamoto Musashi c’è una frase che è la logica conseguenza del suggerimento di Jacopone da Todi:</p>
<blockquote>
<p>Non bisogna interferire nel funzionamento dell’Universo, ma prima è necessario capire quale sia, il funzionamento dell’Universo<a href="/man/note/#musashi" class="nota"></a></p>
</blockquote>
<p>Il problema dei romanzi è che ti dicono spesso cosa fare, ma non ti spiegano quasi mai come farlo, o perché.<br />
Diffida dei maestri che sanno solo insegnare, perché tutto ciò che ti raccontano l’hanno imparato dai libri. Un buon maestro deve eccellere in qualcosa, che sia la scherma, il tiro con l’arco, la carpenteria o la manutenzione delle motociclette. Può non essere <em>il</em> migliore, ma deve essere <em>fra i</em> migliori; solo così, saprai che le sue idee sono valide. Al contrario, i maestri che non sono mai usciti da una scuola, non hanno mai dovuto mettere le loro idee alla prova dei fatti. Ti insegnano ciò che pensano sia giusto, ma ciò che è giusto o vero in una scuola, non sempre è altrettanto vero o giusto nel mondo reale.<br />
È facile essere dei santi, in un monastero, fra persone che hanno la tua stessa cultura e i tuoi stessi principii; il difficile è restare dei santi anche fuori. Il Buddha Shakyamuni predicò la Benevolenza Universale perché visse in India, duemilaseicento anni fa, ma se fosse rimasto imbottigliato nel traffico di una città, dopo una giornata di lavoro, forse le sue idee sarebbero state più simili a quelle di Nietzsche.<br />
Per fortuna, Musashi — quello vero, il Samurai —, fu sempre molto chiaro sia su ciò che è giusto fare che sul modo di ottenerlo. Nel <em>Libro dei Cinque Anelli</em>, diede ai suoi discepoli nove regole di vita:</p>
<blockquote>
<ul>
<li>Non pensare in maniera disonesta.</li>
<li>La Via è nel costante allenamento.</li>
<li>Pratica molte arti.</li>
<li>Conosci la Via e i modi di tutti i mestieri.</li>
<li>Distingui vantaggi e svantaggi di ogni cosa.</li>
<li>Sviluppa una comprensione intuitiva delle cose.</li>
<li>Percepisci anche ciò che non può essere visto con gli occhi.</li>
<li>Presta attenzione anche alle cose più insignificanti.</li>
<li>Non perdere tempo in attività inutili.</li>
</ul>
</blockquote>
<p>Nel <em>Dokkodo</em>, scritto una settimana prima della sua morte, fu ancora più specifico:</p>
<blockquote>
<ul>
<li>Non agire in maniera contraria al tuo destino.</li>
<li>Non ricercare una vita facile.</li>
<li>Non avere pregiudizi od ostilità per qualcosa.</li>
<li>Pensa a te stesso con leggerezza e in maniera profonda agli altri.</li>
<li>Sii distaccato dal desiderio.</li>
<li>Non avere rimpianti per ciò che hai fatto.</li>
<li>Non essere geloso degli altri.</li>
<li>Non avere attaccamento per alcuna cosa.</li>
<li>Non portare rancore.</li>
<li>Non pensare alla vita sentimentale.</li>
<li>Non avere né preferenze né avversioni.</li>
<li>Sii indifferente al luogo in cui vivi.</li>
<li>Non ricercare il cibo per il suo gusto.</li>
<li>Fà che le future generazioni non siano legate ad armi antiche.</li>
<li>Evita le superstizioni e i taboo.</li>
<li>Utilizza solo gli strumenti necessarii e non conservare ciò che è inutile.</li>
<li>Sii preparato a morire.</li>
<li>Quando sei vecchio, ciò che possiedi non ha molta importanza.</li>
<li>Rispetta Buddha e gli Dei, ma non contare sul loro aiuto.</li>
<li>Non abbandonare il tuo onore, anche se ciò significa abbandonare la vita.</li>
<li>Non deviare mai dalla Via.</li>
</ul>
</blockquote>
<p>Queste regole, che hanno permesso a Musashi di arrivare alla venerabile età di sessant’anni<a href="/man/note/#eta" class="nota"></a>, dopo essere sopravvissuto vittorioso ad altrettanti combattimenti con tutti i migliori spadaccini del suo tempo, possono aiutarti a capire quale sia il funzionamento dell’Universo e cosa fare per non perturbarlo.<br />
La pratica delle arti, siano esse intellettuali o marziali, e la conoscenza dei mestieri, unite all’attenzione per tutto ciò che ti circonda, aumenteranno il tuo bagaglio di esperienza e ti permetteranno di distinguere i pro e i contro di ogni situazione. Questo ti libererà dal demone dell’invidia, perché imparerai che tutte le condizioni, anche quelle apparentemente idilliache, hanno dei lati negativi. Il passo successivo sarà affrancarsi dal desiderio e dall’attaccamento alle cose: così come la funzione <code>log</code> ha bisogno di sapere quali siano i parametri fissi e quali siano quelli variabili, tu dovrai imparare a distinguere i tuoi desiderii dalle tue necessità, per sfuggire all’influsso dell’Annosa Dicotomia.<br />
La Via, con la “V” maiuscola è simile a una via con la “v” minuscola. Lungo la via, incontri dei cartelli stradali, che ti indicano la direzione in cui procedere o la velocità da tenere, e dei cartelloni pubblicitarii, che ti segnalano delle attrazioni nelle vicinanze e ti invitano a deviare dal tuo cammino per andarle a visitare. Allo stesso modo, lungo la Via, troverai delle necessità, che ti instraderanno verso la tua destinazione e dei desiderii, che ti dis-trarranno dal tuo percorso e ti at-trarranno verso destinazioni alternative. Se tu agirai in base alle necessità, saprai sempre che ti stai muovendo nella direzione giusta, anche quando sarai costretto a rallentare o a percorrere strade che non gradisci. Se invece agirai in base ai desiderii andrai di qua e di là, come “un asino privo di briglie” e quando alla fine tornerai sulla strada giusta, potresti non avere più il tempo per arrivare alla tua destinazione.</p>
<hr />
<p>Ti ho parlato delle regole di Musashi non perché siano le uniche disponibili, ma perché sono estremamente personali. Attingono ai principii di altre discipline, come il Buddismo, il Bushido o il Tao, ma sono <em>something else</em>, come direbbe Eddie Cochran. Tu dovrai fare altrettanto: imparare tutto ciò che puoi, tanto dai buoni quanto dai cattivi maestri, e poi definire le tue regole di vita, che potranno essere uguali, simili o del tutto differenti da quelle che ti sono state insegnate.<br />
La Via, così come la Verità, è una modella, che ciascuno di noi ritrae dal suo punto di vista, cercando di intuire il corpo che si cela dietro alle pieghe del drappeggio. Ritrarla nello stesso modo in cui l’ha fatto un altro sarebbe sbagliato, perché il tuo punto di vista non è uguale al suo, ma guardarla da più punti di vista può aiutarti a capire meglio la sua forma. Musashi dice di prestare attenzione anche alle cose insignificanti, Nan-in e Tenno sviluppano il loro <em>Zen di ogni istante</em>, Wittgenstein nei suoi <em>Diari</em>, scrive:</p>
<blockquote>
<p>Solo una cosa, è necessaria: essere capace di osservare tutto ciò che ti accade. Concentrarsi! Dio mi aiuti!</p>
</blockquote>
<p>È chiaro che stanno tutti dipingendo la stessa immagine, anche se ciascuno lo fa con il suo stile. È per questo motivo, che Musashi prescrive di conoscere la Via degli altri mestieri: perché c’è sempre qualcosa da imparare, da chi fa bene il suo lavoro. Questo, per esempio, è il parallelo che lui fa fra lo stratega e il carpentiere:</p>
<blockquote>
<p>Per edificare una casa è necessaria un’accurata scelta dei materiali. Per i pilastri esterni si sceglieranno dei tronchi diritti e senza nodi, mentre per quelli interni si possono usare dei tronchi diritti con qualche piccolo difetto. Per le soglie, gli architravi, gli infissi e le porte scorrevoli si useranno i legni migliori per l’aspetto, anche se non sono troppo robusti, e così via. Per le parti strutturali non è importante l’aspetto estetico quanto la robustezza. Il legname meno pregiato e con molti nodi viene invece utilizzato per i ponteggi e, alla fine, viene bruciato.<a href="/man/note/#5anelli" class="nota"></a></p>
</blockquote>
<p>Ciò che è vero per il carpentiere, cambiando il punto di vista, è vero anche per lo stratega e potrà esserlo anche per te, se ti troverai ai gestire un progetto o un gruppo di lavoro. Anche come programmatore, comunque, dovrai tenerti costantemente aggiornato sulle tecniche e sui linguaggi di programmazione e dovrai conoscere il modo in cui lavora chi si occupa delle basi-dati o dei sistemi. Dovrai essere capace di identificare i malfunzionamenti anche se non hanno effetti sull’interfaccia grafica e potrai riuscirci solo se presterai attenzione anche al più piccolo dettaglio. Cambiano i nomi, perché sono passati quattro secoli, ma i problemi restano gli stessi, così come le soluzioni.<br />
Del resto, arte, scienza, filosofia e religione sono tutti tentativi di dare una risposta alle stesse domande sulla nostra esistenza. Dato che l’oggetto di studio è lo stesso, è più che normale che, alle volte, le risposte si somiglino, allo stesso modo in cui l’algoritmo per il calcolo del fattoriale di un numero sarà più o meno lo stesso, indipendentemente dal linguaggio di programmazione.</p>
</section>
</section>
<a href="/man/memoria" class="left" title="Vai a: La memoria"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/istruzioni-condizionali" class="right" title="Vai a: Istruzioni condizionali"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/funzioni" class="left" title="Vai a: Le funzioni"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/istruzioni-iterative" class="right" title="Vai a: Istruzioni iterative"><em></em></a>
<section id="istruzioni-condizionali-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Istruzioni condizionali</a></h1>
<blockquote>
Fare qualcosa d’intenzionale implica capire che esistono delle alternative, e sceglierne una; e questi sono attributi dell’intelligenza
</blockquote>
<section class="testo">
<p>Le istruzioni condizionali sono l’elemento più importante del codice.</p>
<p>Ogni programma deve saper reagire correttamente al variare delle condizioni di utilizzo; per far ciò, si utilizzano le cosiddette <em>istruzioni condizionali</em>, che permettono di definire il comportamento del sistema a seconda che una determinata condizione si riveli vera o falsa.<br />
Il C++ possiede due tipi di istruzione condizionale: le sequenze <code>if-else</code> e l’istruzione <code>switch</code>.<br />
La forma generale delle istruzioni <code>if-else</code> è la seguente:</p>
<pre><code>if ( &lt;condizione&gt; ) {
    // istruzioni da eseguire se la condizione è vera
} else {
    // istruzioni da eseguire se la condizione è falsa
}</code></pre>
<p>Se l’espressione condizionale all’inizio del codice è vera, il programma eseguirà il primo blocco di istruzioni; se no, eseguirà il secondo blocco di istruzioni.</p>
<pre><code>if ( a &gt; 8 ) {
    cout &lt;&lt; &quot;maggiore&quot; &lt;&lt; endl;
} else {
    cout &lt;&lt; &quot;minore&quot; &lt;&lt; endl;
}</code></pre>
<p>Se la condizione falsa non richiede alcuna azione specifica, il secondo blocco di istruzioni può essere omesso:</p>
<pre><code>typedef Importo unsigned long;

Importo raddoppiaStipendio(Importo stipendioCorrente)
{
    if ( stipendioCorrente &gt; 0 ) {
        stipendioCorrente *= 2; 
    }    
    return stipendioCorrente;   
}</code></pre>
<p>Allo stesso modo, le parentesi graffe possono essere omesse se il blocco istruzioni che racchiudono è costituito da una singola istruzione:</p>
<pre><code>if ( a &gt; 8 ) 
    cout &lt;&lt; &quot;maggiore&quot; &lt;&lt; endl;
else
    cout &lt;&lt; &quot;minore&quot; &lt;&lt; endl;</code></pre>
<p>Personalmente, trovo che questa forma sia inelegante e che renda il codice meno chiaro, favorendo quindi gli errori. La utilizzo solo nelle istruzioni di gestione degli errori, dove il flusso del programma si interrompe bruscamente, perché l’aspetto sgraziato dell’istruzione evidenzia l’eccezione, rendendo il codice più auto-esplicativo.</p>
<pre><code>if ( divisore == 0 ) 
    throw std::runtime_error(&quot;errore&quot;);</code></pre>
<p>Se le condizioni da valutare sono più di due, si possono concatenare più istruzioni condizionali utilizzando l’istruzione <code>else if</code>, che permette di definire una condizione alternativa alla prima e di associarle un blocco di codice. Anche in questo caso, si può chiudere la sequenza con un’istruzione <code>else</code>, definendo un blocco di istruzioni da eseguire se non si verifica nessuna delle condizioni previste.</p>
<pre><code>if ( &lt;prima condizione&gt; ) {
    /*
     * istruzioni da eseguire se 
     * la prima condizione è vera
    */
} else if ( &lt;seconda condizione&gt; ) {
    /*
     * istruzioni da eseguire se 
     * la prima condizione è vera
     */
} else {
    /*
     * istruzioni da eseguire se nessuna
     * delle due condizioni è vera
     */
}</code></pre>
<p>Le istruzioni <code>if-else</code> influenzano la leggibilità del codice; è una cosa di cui il buon programmatore deve sempre tenere conto. Il C++ è un linguaggio indipendente dalla formattazione, quindi, una stessa istruzione può essere scritta in molte maniere diverse:</p>
<pre><code>if ( &lt;condizione&gt; )
{
    ...
}
else
{
    ...
}</code></pre>
<p>o, pure:</p>
<pre><code>if ( &lt;condizione&gt; ) {
    ...
} else {
    ...
}</code></pre>
<p>o perfino:</p>
<pre><code>if ( &lt;condizione&gt; ) { ...} else { ... }</code></pre>
<p>Se le istruzioni sono poche e semplici, una forma vale l’altra (fatte salve le questioni di stile, ovviamente), ma se il flusso del programma fosse, come di solito avviene, più complesso, è necessario fare in modo che la forma dell’istruzione semplifichi la scrittura, la lettura e un’eventuale correzione del codice.<br />
Immagina un brano di codice che debba fare una verifica all’inizio dell’elaborazione e, a seconda dell’esito, eseguire una sequenza di istruzioni o inviare un messaggio di errore:</p>
<pre><code>if ( &lt;condizione&gt; ){
    /*
     * righe di codice da
     * eseguire in caso la
     * condizione sia vera
     */
} else {
    /* gestione dell&#39;errore */
}</code></pre>
<p>Se le istruzioni da eseguire in caso di buon successo della verifica sono poche e semplici, questa sequenza non darà problemi, ma se, al contrario, le istruzioni fossero tante e complesse, leggendo il codice potresti arrivare all’istruzione <code>else</code> e non ricordarti più a quale condizione fosse associata. In questi casi, io preferisco la forma:</p>
<pre><code>if ( &lt;errore&gt; ) {
    /* gestione dell&#39;errore */
} else {
    /*
     * righe di codice da
     * eseguire in caso la
     * condizione sia vera
     */
}</code></pre>
<p>Dato che la gestione dell’errore non richiederà mai più di qualche riga di codice, potrai capire a colpo d’occhio tutto il flusso del programma, indipendentemente dalla lunghezza del secondo blocco di istruzioni.<br />
Tutto questo, ovviamente, non vuole essere né un invito né una giustificazione per la scrittura di istruzioni complesse. A meno che non sia necessario limitare le chiamate a funzione per garantire un’alta velocità di esecuzione, è sempre meglio scomporre il flusso del programma in una serie di funzioni distinte e specializzate. Renderai il tuo programma un po’ più lento (o, meglio: un po’ meno veloce), ma il codice sarà molto più facile da leggere o da modificare.<br />
Immagina adesso un brano di codice che richieda molte condizioni <code>if</code> concatenate:</p>
<pre><code>esito = 0;

if ( &lt;condizione 1&gt; ) {
    esito = 1;
} else if ( &lt;condizione 2&gt; ) {
    esito = 2;
} else if ( &lt;condizione 3&gt; ) {
    esito = 3;
} else {
    esito = 9;
}

return esito</code></pre>
<p>Questa forma, per quanto corretta e formalmente ineccepibile, potrebbe rivelarsi difficile da gestire se le condizioni da considerare fossero molto complesse o numerose. Il buon programmatore, allora, può decidere di contravvenire alla (giusta) norma che prescrive di non inserire delle istruzioni <code>return</code> all’interno del codice, e scrivere la sequenza in questo modo:</p>
<pre><code>esito = 0;

if ( &lt;condizione 1&gt; ) {
    return 1;
}
if ( &lt;condizione 2&gt; ) {
    return 2;
} 
if ( &lt;condizione 3&gt; ) {
    return 3;
} 

return 9</code></pre>
<p>Non ti sto dicendo che sia giusto scrivere così e vedi da solo che il codice è rozzo e inelegante, ma ci potrebbero essere dei casi in cui sia questa, la forma da preferire. Per esempio, per un sistema che generi del codice in maniera automatica, è molto più semplice gestire delle istruzioni <code>if</code> isolate che delle condizioni <code>if-else</code> concatenate. Pensa a una <em>stored-procedure</em> che debba controllare l’integrità referenziale dei parametri ricevuti:</p>
<pre><code>CREATE FUNCTION utente_insert (
  _id_classe INTEGER
, _id_gruppo INTEGER
, _username  VARCHAR(255)
, _cognome   VARCHAR(80)
, _nome      VARCHAR(80)
)
RETURNS INTEGER DETERMINISTIC
BEGIN
    DECLARE _id    INTEGER DEFAULT -1;
    DECLARE _count INTEGER DEFAULT 0;

    SELECT count(*) INTO _count FROM classe WHERE (id = _id_classe);
    IF _count = 0 THEN
        RETURN -2;
    END IF;

    SELECT count(*) INTO _count FROM gruppo WHERE (id = _id_gruppo);
    IF _count = 0 THEN
        RETURN -3;
    END IF;

    IF (_username IS NULL) OR (_username = &#39;&#39;) THEN
        RETURN -4;
    END IF;
    
    IF (_cognome IS NULL) OR (_cognome = &#39;&#39;) THEN
        RETURN -5;
    END IF;

    IF (_nome IS NULL) OR (_nome = &#39;&#39;) THEN
        RETURN -6;
    END IF;

    ...
</code></pre>
<p>Se scrivi il codice in questa maniera, puoi inserire o rimuovere un parametro (e i relativi controlli) senza alterare il resto del codice, cosa che non avverrebbe se tu concatenassi le istruzioni <code>if</code>. Perderai un po’ di velocità di esecuzione, ma il codice sarà molto più facile da scrivere o da modificare.<br />
Attento, però: mettere in sequenza delle semplici istruzioni <code>if</code> è cosa ben diversa dal creare una catena di istruzioni <code>else-if</code> perché, se in caso di errore non blocchi l’elaborazione con un’istruzione <code>return</code>, il programma andrà avanti verificando le condizioni seguenti e l’errore nella prima condizione potrebbe ripercuotersi sul codice successivo:</p>
<pre><code>/** Qui comincia il male.. **/
if ( divisore == 0 ) {
    cout &lt;&lt; &quot;Errore: divisione per zero&quot; &lt;&lt; endl;
}

/** ..e il peggio lo segue **/
if ( (dividendo / divisore) &gt; 1 ) {
    ...
}</code></pre>
<p>Non avendo un’istruzione <code>return</code> il codice della prima verifica non bloccherà l’esecuzione della funzione, che andrà in errore quando proverà a eseguire una divisione per zero.</p>
<hr />
<p>L’istruzione <code>switch</code> permette di gestire più casi, basandosi sulla valutazione di una espressione:</p>
<pre><code>switch(&lt;espressione&gt;)
{
    case &lt;costante&gt; : istruzioni... [break];
    case &lt;costante&gt; : istruzioni... [break];
    ...
    default: istruzioni...
}</code></pre>
<p>Le parole-chiave <code>case</code> e <code>default</code> identificano i valori gestiti dall’istruzione <code>switch</code>. I <code>case</code> possono (ed è utile che siano) più di uno, ma le costanti associate a ciascuno di essi devono avere dei valori diversi. La condizione <code>default</code>, al contrario, deve essere unica.<br />
L’esecuzione dell’istruzione inizia al <code>case</code> la cui costante è uguale al valore dell’espressione di <code>switch</code> e termina alla parola chiave <code>break</code>. Se l’espressione ha un valore non previsto dai <code>case</code>, l’istruzione esegue il codice associato all’etichetta <code>default</code>:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

#define POS_NESSUNO -1
#define POS_ERRORE   0
#define POS_MERCURIO 1
#define POS_VENERE   2
#define POS_TERRA    3
#define POS_MARTE    4
#define POS_GIOVE    5
#define POS_SATURNO  6
#define POS_URANO    7
#define POS_NETTUNO  8
#define POS_PLUTONE  9

using namespace std;

int main(int argc, char** argv)
{    
    int pianeta;
    
    /** 
     * Legge i parametri di input.
     * Se ce ne sono, prova a convertire il primo parametro 
     * in un intero. Se il parametro non è un intero, la 
     * funzione atoi torna 0. 
     */
    if(argc &gt; 1) {
        pianeta = atoi(argv[1]);
    } else {
        pianeta = POS_NESSUNO;
    }
    
    /** Gestisce i casi possibili */
    switch( pianeta ) {
        case POS_ERRORE:   cout &lt;&lt; &quot;Valore non valido&quot;; 
            break;
        case POS_MERCURIO: cout &lt;&lt; &quot;Mercurio&quot;;          
            break;
        case POS_VENERE:   cout &lt;&lt; &quot;Venere&quot;;            
            break;
        case POS_TERRA:    cout &lt;&lt; &quot;Terra&quot;;             
            break;
        case POS_MARTE:    cout &lt;&lt; &quot;Marte&quot;;             
            break;
        case POS_GIOVE:    cout &lt;&lt; &quot;Giove&quot;;             
            break;
        case POS_SATURNO:  cout &lt;&lt; &quot;Saturno&quot;;           
            break;
        case POS_URANO:    cout &lt;&lt; &quot;Urano&quot;;             
            break;          
        case POS_NETTUNO:  cout &lt;&lt; &quot;Nettuno&quot;;           
            break;          
        case POS_PLUTONE:  cout &lt;&lt; &quot;Plutone&quot;;           
            break;
        default:
            cout &lt;&lt; &quot;Inserire un valore da: &quot; 
                 &lt;&lt; POS_MERCURIO 
                 &lt;&lt; &quot; a &quot; 
                 &lt;&lt; POS_PLUTONE;                    
    }
    
    cout &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Compilando ed eseguendo questo codice, otterrai:</p>
<pre><code>% g++ src/cpp/istruzioni-condizionali-switch.cpp -o src/out/esempio
% src/out/esempio                                                  
Inserire un valore da: 1 a 9
% src/out/esempio 4
Marte
% src/out/esempio terra
Valore non valido</code></pre>
<p>In sostanza: con una <code>break</code> alla fine di ciascun caso, l’istruzione <code>switch</code> è una forma più elegante (ed efficiente) dell’istruzione <code>if - else if</code>:</p>
<pre><code>if(piaeta == POS_ERRORE) {
   cout &lt;&lt; &quot;Valore non valido&quot;; 
} else if(pianeta == POS_MERCURIO) {
    cout &lt;&lt; &quot;Mercurio&quot;; 
} else if(pianeta == POS_VENERE) {
    cout &lt;&lt; &quot;Venere&quot;;   
} else if ..         </code></pre>
<p>Se tu togliessi le interruzioni <code>break</code> alla fine di ciascun caso, l’output del programma sarebbe:</p>
<pre><code>% src/out/esempio 4    
MarteGioveSaturnoUranoNettunoPlutoneInserire un valore da: 1 a 9</code></pre>
<p>che in questo caso non ha senso, ma che può essere la scelta adatta se due casi possibili vanno elaborati nella stessa maniera.<br />
Un’ultima cosa: ricordati sempre che, per dichiarare delle variabili all’interno dei <code>case</code>, è necessario aggiungere delle parentesi graffe; altrimenti, avrai un errore in fase di compilazione:</p>
<pre><code>switch( x ) {
    case 1: 
        int y = 9;      /** errore di complilazione */
        cout &lt;&lt; x + y; 
        break;
    case 2: {
        int y = 2;      /** corretto */
        cout &lt;&lt; x + y ; 
        break;
    }
    default:
        cout &lt;&lt; &quot;default&quot; &lt;&lt; endl; 
}
</code></pre>
<hr />
<p>La vita ci chiede spesso di fare delle scelte condizionali. Quando ciò avviene, hai due possibilità: o fai la scelta più conveniente per te o fai la scelta che ti sembra più conveniente per il maggior numero di persone per il più lungo periodo di tempo possibile. Nel primo caso sarai un vettore di Entropia, mentre nel secondo caso sarai un paladino della Gravità.<br />
Come sai, per il C’hi++ la scelta esatta (inteso come participio passato del verbo <em>esigere</em>) è la seconda: tutta la materia non è che la manifestazione di una unica Energia, quindi ha poco senso distinguerci gli uni dagli altri; dobbiamo invece ragionare come Saʿdi di Shirāz, quando dice:</p>
<blockquote>
<p>Son membra d’un corpo solo i figli di Adamo, da un’unica essenza quel giorno creati. E se uno tra essi a sventura conduca il destino, per le altre membra non resterà riparo.<a href="/man/note#saadi" class="nota"></a></p>
</blockquote>
<p>Cercare il proprio tornaconto personale a discapito degli altri è sbagliato. Bisogna comportarsi bene e cercare di convincere anche gli altri a fare altrettanto, perché, come recita il <em>Mantiq al-Tayr</em>:</p>
<blockquote>
<p>tutto il male o il bene che feci, in verità lo feci solo a me stesso<a href="/man/note#mantiq" class="nota"></a>.</p>
</blockquote>
<p>Ma come si fa a capire cosa sia <em>bene</em>? Ci sono casi in cui è facile dare la scelta giusta, come nel caso del maestro Zen Bokuju<a href="/man/note#bokuju" class="nota"></a>:</p>
<pre><code>switch( stimolo ) {
    case fame:  
        azione = mangio; 
        break;
    case sonno: 
        azione = dormo; 
        break;
    case sete:  
        azione = bevo; 
        break;
}</code></pre>
<p>ma altre volte ci troviamo di fronte a scelte più complesse:</p>
<blockquote>
<p>Una ragazza è rimasta incinta a séguito di una violenza: può decidere di abortire?</p>
</blockquote>
<p>oppure:</p>
<blockquote>
<p>Un uomo, condannato per omicidio, in carcere ha ucciso altri due carcerati e una guardia: va condannato a morte o no?</p>
</blockquote>
<p>Se queste domande le fai a un cattolico, lui — coerentemente con il suo Credo — ti risponderà che no, non è possibile né abortire né condannare a morte perché la vita è un dono di Dio e nessuno ce ne può privare. Se invece queste domande le poni a un Giudice, avrai risposte diverse a seconda della Nazione a cui appartiene, perché mentre sottrarre dei beni materiali è considerato un reato ovunque, esistono degli Stati in cui è permesso sottrarre a un individuo il bene più prezioso che ha.<br />
Un tempo, i credenti mettevano al rogo gli scienziati, accusandoli di eresia; il 6 Giugno del 1945, però, la Scienza ha mostrato al Mondo il suo potere ed è diventata di fatto il nuovo Dio per milioni di persone; da allora, le parti si sono invertite e adesso sono gli scienziati a mettere al rogo ogni forma di spiritualità. Il problema è che se privi la giurisprudenza di una base spirituale, quello che otterrai sono Leggi <em>pret-a-porter</em>, rimedii temporanei a delle esigenze contingenti. Nella migliore delle ipotesi.<br />
La teocrazia è un errore, ma anche la <em>a</em>-teocrazia dev’essere evitata. La Fede è stata la colla che ha tenuto unita la nostra società per quasi duemila anni. Forse quella colla era solo una nostra invenzione, ma lo sono anche gli Stati, il denaro, i Diritti Umani, le Leggi<a href="/man/note#sapiens" class="nota"></a>. Nessuno di questi concetti così importanti per la nostra Società esiste davvero, ma li utilizziamo lo stesso perché, come il linguaggio <em>C</em>, pur essendo solo delle convenzioni, sono utili al loro scòpo.<br />
Ora che questa colla non c’è più, le scelte dei legislatori non sono più mosse dal perseguimento di un obiettivo comune (corretto o sbagliato che fosse), ma dalla ricerca dell’approvazione di un elettorato composto in buona parte da zombie culturali<a href="/man/note#istat" class="nota"></a> e da egoisti che perseguono unicamente il proprio interesse momentaneo: il pascolo ideale per demagoghi con aspirazioni dittatoriali. La minoranza di idealisti e di persone colte, priva di valori trascendenti, non può che agire in base ai propri sentimenti o ai propri auspici e subisce inevitabilmente il malefico influsso dell’Annosa Dicotomia: fanno scelte che puntano al bene comune, ma si tratta di un bene comune molto spesso miope e temporaneo. Come scacchisti mediocri, vedono ciò che è bene qui e ora, ma non riescono a valutarne le conseguenze a lungo termine.<br />
Pensa a quale potrebbe essere, secondo te, la soluzione giusta alle due domande che ti ho fatto e poi pensa al <em>motivo</em> quella soluzione ti appare giusta. Perché permettiamo la soppressione di un feto che non ha fatto del male a nessuno, mentre lasciamo in vita chi ne ha già fatto? Vogliamo fare la cosa giusta o vogliamo solo sentirci buoni?<br />
Il Maestro Canaro si fece molti nemici con la sue idee sull’aborto. Anche alcune persone che inizialmente lo avevano appoggiato lo accusarono di cercare l’appoggio della Chiesa Cattolica, mentre stava solo applicando il precetto del <em>Metta Sutra</em> che predica la felicità non solo per tutti coloro che sono nati, ma anche per coloro che devono nascere:</p>
<blockquote>
<p>bhåtà và sambhavesã và sabbe sattà bhavantu sukhitattà<a href="/man/note#metta" class="nota"></a></p>
</blockquote>
<p><em>bhåtà</em> quelli che sono nati<br />
<em>và</em> o<br />
<em>sambhavesã</em> quelli che cercano la nascita<br />
<em>và</em> o<br />
<em>sabbe</em> tutti<br />
<em>sattà</em> gli esseri<br />
<em>bhavantu</em> possano essere<br />
<em>sukhitattà</em> felici nel loro cuore</p>
<p>Tutto questo a lui non importava: quando gliene parlai, mi disse che preferiva perdere un milione di seguaci che una vita.</p>
<hr />
<p>Rispondere alla domanda sul condannato è più difficile. Lo scòpo delle tue azioni deve essere, come sempre, il miglioramento: chi sbaglia deve capire che ha fatto un errore e non ripeterlo in altri cicli di esistenza:</p>
<pre><code>int pentimento( azione ){

    bool ripetere;

    if ( azione == errore ) {
        ripetere = false;
    } else {
        ripetere = true;
    }

    return ripetere;
}</code></pre>
<p>Se il peccatore è davvero pentito, allora è giusto che sia assolto, perché, come dice Attar:</p>
<blockquote>
<p>Cento Mondi di peccato sono dissipati dalla luce di un solo pentimento<a href="/man/note#attar" class="nota"></a>.</p>
</blockquote>
<p>Ma il pentimento dev’essere reale: il peccatore deve detestare il suo errore e scegliere di morire piuttosto che ripeterlo ancora.<br />
Tagliare una mano a chi ruba, costringendolo a portare il cibo alla bocca con la stessa mano con cui si pulisce il sedere, è un metodo un po’ drastico, ma efficace per costringere qualcuno a meditare sull’insensatezza delle sue azioni passate — specie in un luogo come il deserto, dove i bidet sono più rari che in Francia. La <em>Lex Talionis</em> può funzionare per reati minori, perché chi la subisce ha il tempo di riflettere sui suoi errori, ma nel caso di un omicidio non solo è contraria all’obbligo di benevolenza che abbiamo nei confronti degli altri esseri senzienti, ma potrebbe anche essere controproducente, perché se il condannato non capisce il suo errore prima di morire è possibile che le sue azioni delittuose vengano ripetute in altri cicli dell’Universo.<br />
D’altro canto, abbiamo un obbligo di benevolenza anche nei confronti degli altri carcerati e delle guardie carcerarie, quindi non possiamo lasciare che il condannato li uccida. La soluzione ideale sarebbe quella di metterlo in condizione di non nuocere a terzi, lasciandolo poi meditare sui suoi errori, ma se questo non fosse possibile, come ci dovremmo comportare? Se un individuo ripete più volte lo stesso atto delittuoso evidentemente non capisce o non vuole capire il suo errore. Se non capisce non è <em>senziente</em>, nel senso di <em>sensibilità</em>, quindi non può concorrere al miglioramento dell’Universo. Se non è utile al miglioramento, possiamo considerarlo alla stessa stregua del gatto di Nansen:</p>
<blockquote>
<p>Nansen un giorno vide i monaci delle sale Orientali e Occidentali che litigavano per un gatto. Egli sollevò il gatto e disse: “Se mi direte una parola di Zen, salverò il gatto; se no, lo ucciderò”.<br />
Nessuno seppe rispondere e Nansen tagliò il gatto in due<a href="/man/note#nansen" class="nota"></a>.</p>
</blockquote>
<p>La morte del condannato, però, se mai dovesse rendersi necessaria, non deve essere considerata una vendetta di cui gioire, ma un evento tanto doloroso quanto inevitabile, di cui dolersi come di un’amputazione. Ciascuno, in quel giorno, dovrebbe chiedersi se, con <em>pensieri, parole, opere e omissioni</em>, non abbia contribuito in qualche modo a quella perdita. Una Società che esalta l’individualismo, il successo e il denaro non può dirsi del tutto innocente se chi non ha i mezzi o la capacità di ottenerli in maniera lecita cerca di procurarseli in altro modo.</p>
<hr />
<p>Un insegnante buddhista, saputo che il Maestro Canaro, nei suoi scritti, sosteneva che non c’è modo di sottrarsi al ciclo delle rinascite, si recò da lui e, deciso a dimostrare che si sbagliava, lo sfidò a un <em>Dharma Combat</em> per chiarire le reciproche posizioni. Il Maestro Canaro rispose che non sapeva cosa fosse un <em>Dharma Combat</em>; al che, l’insegnante buddhista spiegò che era un confronto dialettico, per dimostrare la propria conoscenza della dottrina. Il Maestro Canaro allora annuì e disse: “Va bene, ma prima che cominciamo, dimmi se tu, questo confronto, lo vuoi vincere o perdere, in modo che io possa accontentarti.” Sentendo quelle parole, l’insegnante buddhista si rese conto che le sue intenzioni non erano pure: non voleva quella sfida per arrivare alla verità, ma solo per il piacere della vittoria. Così si inchinò, ringraziò il Maestro Canaro per avergli fatto capire quella sua debolezza e, da quel momento in poi, divenne un suo discepolo.</p>
</section>
</section>
<a href="/man/funzioni" class="left" title="Vai a: Le funzioni"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/istruzioni-iterative" class="right" title="Vai a: Istruzioni iterative"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/istruzioni-condizionali" class="left" title="Vai a: Istruzioni condizionali"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/classi-oggetti" class="right" title="Vai a: Classi e oggetti"><em></em></a>
<section id="istruzioni-iterative-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Istruzioni iterative</a></h1>
<blockquote>
Invero è cosa piuttosto strana a udirsi, ma il nome che noi almeno vi diamo – un nome a cui, per difetto di esperienza in materia, non penserebbe nessuno – è: Spazionismo
</blockquote>
<section class="testo">
<p>Le istruzioni di ciclo sono le componenti fondamentali della programmazione.</p>
<p>Ci sono tre tipi di istruzioni di ciclo:</p>
<ul>
<li><code>for</code></li>
<li><code>while</code></li>
<li><code>do while</code>.</li>
</ul>
<p>Queste istruzioni sono composte di due parti: un’istruzione di <em>controllo del ciclo</em>, che ne determina la durata e un <em>corpo del ciclo</em>, composto dalle istruzioni che vengono ripetute ad ogni iterazione. La ripetizione può protrarsi o per un determinato numero di volte o fino a che non sia raggiunta una determinata condizione.</p>
<p>Il ciclo <code>for</code> viene utilizzato quando vogliamo eseguire il ciclo in numero determinato di volte. La forma generale è la seguente:</p>
<pre><code>// controllo del ciclo
for(&lt;stato iniziale&gt; ; &lt;stato finale&gt; ; &lt;variazione&gt;)
{
    // corpo del ciclo
    &lt;istruzioni&gt;
}</code></pre>
<p>Le tre condizioni all’interno delle parentesi sono utilizzate dall’istruzione <code>for</code> per controllare l’esecuzione delle istruzioni all’interno del corpo del ciclo.<br />
La prima espressione è valutata solo una volta all’inizio del ciclo e, solitamente, serve a inizializzare le variabili utilizzate.<br />
La seconda espressione è una condizione logica o relazionale che viene valutata all’inizio di ogni iterazione: se torna <code>0</code> o <code>false</code> l’esecuzione del ciclo termina, altrimenti posegue.<br />
La terza espressione viene valutata al termine di ogni iterazione e, di solito, è costituita da un’espressione di incremento o decremento delle variabili utilizzate per il controllo del ciclo. Per fare ciò, si utilizzano degli operatori unarii (ovvero che operano su una singola variabile) detti: <em>operatori di incremento</em> e <em>operatori di decremento</em>, che possono svolgere la loro funzione o prima o dopo l’utilizzo della variabile, a seconda che vengano posti prima o dopo l’identificatore della variabile:</p>
<pre><code>x++     // valuta x e poi la incrementa di un&#39;unità
++x     // incrementa x di un&#39;unità e poi la valuta
x--     // valuta x e poi la riduce di un&#39;unità
--x     // riduce x di un&#39;unità e poi la valuta</code></pre>
<p>Se <code>x</code> è una variabile di tipo intero o in virgola mobile l’incremento è di un’unità aritmetica; se invece <code>x</code> è un puntatore l’incremento equivale alla dimensione della variabile a cui il puntatore riferisce, come ti ho fatto vedere parlando dei tipi di dato.<br />
In questo caso, la variabile <code>p</code> è un intero, quindi l’istruzione:</p>
<pre><code>for ( p = POS_MERCURIO; p &lt;= POS_PLUTONE; p++ ) {</code></pre>
<p>incrementerà la variabile <code>p</code> di 1.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

#define POS_NESSUNO -1
#define POS_ERRORE   0
#define POS_MERCURIO 1
#define POS_VENERE   2
#define POS_TERRA    3
#define POS_MARTE    4
#define POS_GIOVE    5
#define POS_SATURNO  6
#define POS_URANO    7
#define POS_NETTUNO  8
#define POS_PLUTONE  9

using namespace std;

/**
 *  mostraPianeta 
 *  Visualizza il nome di un pianeta, data la sua posizione.
 *  @param  int  pianeta Posizione del pianeta.
 *  @return bool esiste  true se il pianeta esiste.
 */
bool mostraPianeta(int pianeta )
{    
    bool esiste = true;
    
    switch( pianeta ) {
        case POS_ERRORE:   
            cout &lt;&lt; &quot;Valore non valido&quot;; 
            break;
        case POS_MERCURIO: 
            cout &lt;&lt; &quot;Mercurio&quot;;          
            break;
        case POS_VENERE:   
            cout &lt;&lt; &quot;Venere&quot;;            
            break;
        case POS_TERRA:    
            cout &lt;&lt; &quot;Terra&quot;;             
            break;
        case POS_MARTE:    
            cout &lt;&lt; &quot;Marte&quot;;             
            break;
        case POS_GIOVE:    
            cout &lt;&lt; &quot;Giove&quot;;             
            break;
        case POS_SATURNO:  
            cout &lt;&lt; &quot;Saturno&quot;;           
            break;
        case POS_URANO:    
            cout &lt;&lt; &quot;Urano&quot;;             
            break;          
        case POS_NETTUNO:  
            cout &lt;&lt; &quot;Nettuno&quot;;           
            break;          
        case POS_PLUTONE:  
            cout &lt;&lt; &quot;Plutone&quot;;           
            break;
        default:
            esiste = false;
            cout &lt;&lt; &quot;Inserire un valore da: &quot; 
                 &lt;&lt; POS_MERCURIO 
                 &lt;&lt; &quot; a &quot; 
                 &lt;&lt; POS_PLUTONE;                    
    } 
    
    return esiste;
}

/**
 *  main
 *  Funzione principale del programma, richiama la funzione
 *  mostraPianeti passandole i valori da 1 a 9.
 */
int main(int argc, char** argv)
{    
    int p = POS_NESSUNO;

    /** Elenca tutti i Pianeti del Sistema Solare */
    for ( p = POS_MERCURIO; p &lt;= POS_PLUTONE; p++ ) {
        cout &lt;&lt; p &lt;&lt; &quot;: &quot;; 
        mostraPianeta( p ); 
        cout &lt;&lt; endl;
    }
        
    return 0;
}
</code></pre>
<p>La prima istruzione inizializza il valore di <code>p</code> a <code>1</code> (il valore della costante <code>POS_MERCURIO</code>) e prosegue, per incrementi successivi di 1, fino a che il valore di <code>p</code>è minore o uguale a <code>9</code> (il valore della costante <code>POS_PLUTONE</code>). A ogni ripetizione il programma mostra il valore della variabile <code>p</code>, richiama la funzione <code>mostraPianeta</code>, passandole il valore corrente di <code>p</code>, poi aggiunge un a capo.<br />
L’output di questo programma è:</p>
<pre><code>% g++ src/cpp/istruzioni-iterative-for.cpp -o src/out/esempio
% src/out/esempio                                            
1: Mercurio
2: Venere
3: Terra
4: Marte
5: Giove
6: Saturno
7: Urano
8: Nettuno
9: Plutone
</code></pre>
<p>Si può utilizzare un ciclo <code>for</code> anche per effettuare cicli con un numero indefinito di iterazioni, basta omettere le tre espressioni di controllo, mantenendo solo delle <em>istruzioni nulle</em>, composte dal solo terminatore <code>;</code>:</p>
<pre><code>for( ; ; )
{
    // istruzioni
}</code></pre>
<p>Un ciclo di questo tipo continuerà a ripetersi indefinitamente e, se non viene fermato in qualche maniera, causerà inevitabilmente dei problemi al computer che lo esegue. È necessario quindi porre un limite al numero di ripetizioni, utilizzando la stessa parola-chiave <code>break</code>che abbiamo usato con le istruzioni <code>switch</code>. Stavolta, però, cominceremo a fare le cose come vanno fatte e separeremo le tre componenti del programma precedente in tre file distinti: <code>pianeti.h</code>, che conterrà le dichiarazioni delle costanti e della funzione <code>mostraPianeta</code>; <code>pianeti.cpp</code>, contenente la definizione della funzione <code>mostraPianeta</code> e <code>pianeti-main.cpp</code> per la funzione <code>main</code>:</p>
<pre><code>/** 
 * @file pianeti.h
 * Costanti e funzione per la gestione dei Pianeti.
 */

#ifndef _PIANETI
#define _PIANETI 1
 
using namespace std;

/** Dichiarazione delle costanti */
#define POS_NESSUNO -1
#define POS_ERRORE   0
#define POS_MERCURIO 1
#define POS_VENERE   2
#define POS_TERRA    3
#define POS_MARTE    4
#define POS_GIOVE    5
#define POS_SATURNO  6
#define POS_URANO    7
#define POS_NETTUNO  8
#define POS_PLUTONE  9

/** Dichiarazione delle funzioni */
bool mostraPianeta(int pianeta);
string nomePianeta(int posizione);

#endif /* _PIANETI */
</code></pre>
<pre><code>/** 
 * @file pianeti.cpp
 * @version 1.0
 * Funzione per la gestione dei Pianeti.
 */

#include &lt;iostream&gt;
#include &quot;pianeti.h&quot;

/**
 *  mostraPianeta 
 *  Visualizza il nome di un pianeta, data la sua posizione.
 *  @param  int  pianeta Posizione del pianeta.
 *  @return bool esiste  true se il pianeta esiste.
 */
bool mostraPianeta(int pianeta)
{    
    bool esiste = true;
    
    switch( pianeta ) {
        case POS_ERRORE:   
            cout &lt;&lt; &quot;Valore non valido&quot;; 
            break;
        case POS_MERCURIO: 
            cout &lt;&lt; &quot;Mercurio&quot;;          
            break;
        case POS_VENERE:   
            cout &lt;&lt; &quot;Venere&quot;;            
            break;
        case POS_TERRA:    
            cout &lt;&lt; &quot;Terra&quot;;             
            break;
        case POS_MARTE:    
            cout &lt;&lt; &quot;Marte&quot;;             
            break;
        case POS_GIOVE:    
            cout &lt;&lt; &quot;Giove&quot;;             
            break;
        case POS_SATURNO:  
            cout &lt;&lt; &quot;Saturno&quot;;           
            break;
        case POS_URANO:    
            cout &lt;&lt; &quot;Urano&quot;;             
            break;          
        case POS_NETTUNO:  
            cout &lt;&lt; &quot;Nettuno&quot;;           
            break;          
        case POS_PLUTONE:  
            cout &lt;&lt; &quot;Plutone&quot;;           
            break;
        default:
            esiste = false;
            cout &lt;&lt; &quot;Inserire un valore da: &quot; 
                 &lt;&lt; POS_MERCURIO 
                 &lt;&lt; &quot; a &quot; 
                 &lt;&lt; POS_PLUTONE;                    
    } 
    
    return esiste;
}
</code></pre>
<pre><code>/** 
 * @file pianeti-main.cpp
 * Funzione principale per il programma di gestione dei Pianeti.
 */
 
#include &lt;iostream&gt;
#include &quot;pianeti.h&quot;

using namespace std;

int main(int argc, char** argv)
{    
    int p = POS_MERCURIO;

    /** Elenca tutti i Pianeti del Sistema Solare */
    for ( ; ; ) {
        cout &lt;&lt; p &lt;&lt; &quot;: &quot;; 
        /** Se incontra un errore, si ferma */
        if(!mostraPianeta( ++p )) break; 
        cout &lt;&lt; endl;
    }
        
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>L’incremento della variabile <code>p</code>, in questo caso, avviene all’interno dell’istruzione:</p>
<pre><code>if(!mostraPianeta( p++ )) break; </code></pre>
<p>La parola-chiave <code>break</code> è una delle tre <em>istruzioni di interruzione</em> che il C++ ha ereditato dal C; le altre due sono l’istruzione <code>continue</code>, che riporta l’elaborazione all’inizio del ciclo e l’istruzione <code>return</code>, che termina la funzione, restituendo un eventuale valore di ritorno alla funzione chiamante.</p>
<p>Per generare il programma, stavolta, dovremo passare al compilatore entrambi i file <em>.cpp</em>:</p>
<pre><code>% g++ src/cpp/pianeti-main.cpp \
      src/cpp/pianeti.cpp \
   -o src/out/esempio
% src/out/esempio 
1: Mercurio
2: Venere
3: Terra
4: Marte
5: Giove
6: Saturno
7: Urano
8: Nettuno
9: Plutone
10: Inserire un valore da: 1 a 9</code></pre>
<p>Se invece avessimo scritto:</p>
<pre><code>if(!mostraPianeta( ++p )) break; </code></pre>
<p>il valore di <code>p</code> in tutte le istruzioni sarebbe stato maggiore di uno rispetto al valore corretto e il programma avrebbe “saltato” Mercurio perché il valore della variabile <code>p</code> sarebbe stato incrementato prima del suo utilizzo da parte della funzione:</p>
<pre><code>% src/out/esempio                                            
1: Venere
2: Terra
3: Marte
4: Giove
5: Saturno
6: Urano
7: Nettuno
8: Plutone
9: Inserire un valore da: 1 a 9</code></pre>
<p>Si può utilizzare un ciclo <code>for</code> in questo modo, ma non ha molto senso. Meglio, invece, utilizzare l’istruzione di flusso <code>while</code>:</p>
<pre><code>/** 
 * @file pianeti-while-bool.cpp
 * Gestione dei Pianeti con istruzione while.
 */
 
#include &lt;iostream&gt;
#include &quot;pianeti.h&quot;

using namespace std;

int main(int argc, char** argv)
{    
    int  p  = POS_MERCURIO;

    /** Assegna un valore alla variabile di controllo */
    bool ok = true;

    /** Ripete l&#39;azione finché la variabile è uguale a true */
    while (ok) {

        /** Mostra il valore di p e lo incrementa */
        cout &lt;&lt; p++ &lt;&lt; &quot;: &quot;; 

        /** 
         * Mostra il nome sel pianeta e salva l&#39;esito della 
         * funzione nella variabile ok 
         */
        ok = mostraPianeta(p);

        /** Aggiunge il solito a capo */
        cout &lt;&lt; endl;
    }
        
    return 0;
}
</code></pre>
<p>L’output sarà uguale a quello della funzione che utilizzava il ciclo <code>for</code>:</p>
<pre><code>% g++ src/cpp/pianeti-while-bool.cpp \
      src/cpp/pianeti.cpp \
   -o src/out/esempio
% src/out/esempio                     
1: Venere
2: Terra
3: Marte
4: Giove
5: Saturno
6: Urano
7: Nettuno
8: Plutone
9: Inserire un valore da: 1 a 9</code></pre>
<p>Il ciclo <code>do-while</code> è uguale al ciclo <code>while</code> con la sola differenza che la condizione <code>while</code> viene valutata alla fine dell’iterazione e quindi il corpo del ciclo viene eseguito almeno per una volta. La forma generale del ciclo <code>do-while</code> è:</p>
<pre><code>do
{
    &lt;istruzioni&gt;        // corpo del ciclo
} while(espressione)    // espressione di controllo</code></pre>
<hr />
<p>Non offenderò la tua intelligenza con un esempio; vorrei piuttosto farti notare una cosa grave: il codice di questi programmi è sgraziato. Il problema è che la funzione mostraPianeta fa troppe cose: non solo stabilisce il nome del Pianeta, ma lo stampa anche a video. In conseguenza di ciò, nel nostro output abbiamo anche quella brutta stringa di errore relativa alla posizione numero nove. Nel primo esempio in cui l’abbiamo utilizzata, questo non era un problema, ma adesso che il nostro programma si sta sviluppando, dobbiamo rendere ciascuna funzione più specialistica, dividendo l’elaborazione dei dati (capire quale sia il pianeta) dall’interfaccia utente (la stampa a video del nome). Per fare ciò, utilizzeremo una nuova funzione che aggiungeremo al file <code>pianeti.cpp</code>:</p>
<pre><code>/**
 *  nomePianeta 
 *  Torna il nome di un pianeta, data la sua posizione.
 *  @param  int    posizione Posizione del pianeta.
 *  @return string nome      Nome del pianeta o null, se errore.
 */
string nomePianeta(int posizione)
{    
    string nome;

    /** 
     * Questa funzione gestisce solo i casi esistenti 
     * e lascia che sia la funzione chiamate a gestire
     * eventuali errori.
     */
    switch( posizione ) {
        case POS_MERCURIO: 
            nome = &quot;Mercurio&quot;;          
            break;
        case POS_VENERE:   
            nome = &quot;Venere&quot;;            
            break;
        case POS_TERRA:    
            nome = &quot;Terra&quot;;             
            break;
        case POS_MARTE:    
            nome = &quot;Marte&quot;;             
            break;
        case POS_GIOVE:    
            nome = &quot;Giove&quot;;             
            break;
        case POS_SATURNO:  
            nome = &quot;Saturno&quot;;           
            break;
        case POS_URANO:    
            nome = &quot;Urano&quot;;             
            break;          
        case POS_NETTUNO:  
            nome = &quot;Nettuno&quot;;           
            break;          
        case POS_PLUTONE:  
            nome = &quot;Plutone&quot;;           
            break;
    } 
    
    return nome;
}</code></pre>
<p>La nuova funzione <code>main</code> sarà:</p>
<pre><code>/** 
 * @file pianeti-while-string.cpp
 * Gestione dei Pianeti con valori stringa.
 */
 
#include &lt;iostream&gt;
#include &quot;pianeti.h&quot;

using namespace std;

int main(int argc, char** argv)
{    
    int    p  = POS_MERCURIO;
    string nome;

    /** 
     * Scinde l&#39;elaborazione del dato dalla sua
     * eventuale visualizzazione
     */
    while (!(nome = nomePianeta(p)).empty()) {
        cout &lt;&lt; p++ &lt;&lt; &quot;: &quot; &lt;&lt; nome &lt;&lt; endl;
    }
        
    return 0;
}
</code></pre>
<p>Il codice è sintatticamente più complesso, ma una volta capito che l’istruzione:</p>
<pre><code>while(!(nome = nomePianeta(p)).empty())</code></pre>
<p>significa:</p>
<blockquote>
<p>esegui la funzione <code>nomePianeta</code> passandole come parametro la variabile <code>p</code> finché non ti torna una stringa vuota</p>
</blockquote>
<p>il flusso del programma diventa più evidente di quanto fosse nei casi precedenti. Il corpo del ciclo è passato da tre istruzioni a una e le due operazioni di elaborazione e visualizzazione sono ben distinte nel tempo. Oltre ad aver ottenuto un codice più facile da leggere, da correggere da eseguire e da modificare, ci siamo anche sbarazzati dell’odioso messaggio di errore. Direi che ne valeva la pena, no?</p>
<hr />
<p>La religione dovrebbe aiutare l’Uomo a vivere meglio. Dovrebbe dare uno scòpo alla nostra esistenza, aiutarci a superare i momenti di dolore e definire una scala di valori che ci permetta di prendere delle decisioni in quei casi in cui il raziocinio o il semplice buon senso non possono essere d’aiuto. Finora, però, le religioni non hanno aiutato l’Umanità a vivere meglio, anzi: hanno avuto spesso l’effetto opposto perché sono state prese a pretesto per guerre, soprusi e contrasti più o meno violenti. Ciò dipende da due fattori: la natura umana e la mancanza di solidità logica dei loro principii. Infatti, dovendo interessarsi di argomenti che non possono essere sottoposti a un’analisi razionale, le religioni sono costrette a dedurre le regole della propria dottrina da una serie di dogmi non dimostrabili che i seguaci della religione — i quali, non a caso, sono detti: “fedeli” o: “credenti” — devono accettare per buoni senza metterli in discussione.<br />
I dogmi sono i pilastri su cui si regge l’edificio della dottrina; se uno di essi si indebolisse o, peggio, se fosse rimosso, l’edificio rischierebbe di crollare, quindi ogni forma di eresia è vista dagli apparati ecclesiastici come un potenziale pericolo che va scongiurato con ogni mezzo, anche a costo di abiurare quegli stessi principii che si cerca di difendere. Questo, però, non fa che peggiorare le cose, perché i dogmi non sono leggi comprovabili, ma opinioni o speranze e ogni tentativo di renderli più robusti ottiene l’effetto opposto perché si ampliano le dimensioni di una struttura che poggia su basi instabili.<br />
Aristotele disse che:</p>
<blockquote>
<p>le scienze che derivano da un numero minore di premesse sono più rigorose delle scienze che ne discendono per mezzo dell’aggiunta di nuove premesse <a href="/man/note/#aristotele" class="nota"></a></p>
</blockquote>
<p>In quest’ottica, il C’hi++ è una metafisica abbastanza rigorosa, perché richiede l’accettazione di due sole affermazioni non comprovabili e, di queste, solo una è strettamente necessaria alla coerenza interna della dottrina, l’altra è solo un auspicio.<br />
Ai fedeli del C’hi++ è richiesto di credere, anche in assenza di prove o in presenza di prove contrarie (gli scienziati non sono infallibili: sono gli stessi che avevano visto dei canali su Marte) che ci sarà un momento in cui l’espansione dell’Universo terminerà e che tutto ciò che esiste tornerà a riunirsi nell’Uno primigenio:</p>
<pre><code>void eternita() 
{
    /** 
     * La condizione è sempre vera, quindi il ciclo si ripete
     * indefinitamente
     */
    while(1) {
        
        unoPrimigenio();
        
        bigBang();
        
        espansione();
        
        contrazione();
        
        bigCrunch();
        
        /**
         * Il fatto che questa istruzione sia a commento è
         * una delle differenze fra C&#39;hi++ e Buddismo.
         * if(satori()) break;     
         */  
    }
}</code></pre>
<p>Se non ci fosse questa ciclicità, ovvero senza un’alternanza fra Entropia e Gravità, fra <em>Prakṛti</em> e <em>Puruṣa</em>, lo Spazionismo e, di conseguenza,il C’hi++ non avrebbero più senso, così come la nostra esistenza. La Vita si rivelerebbe un epifenomeno destinato a esaurirsi nella morte termica dell’Universo e nessun ordine sociale sarebbe più possibile, perché ciascuno cercherebbe di ottenere il massimo possibile dai pochi anni che gli sono concessi, indifferente al costo che questo avrebbe per gli altri. Qualcosa di simile al <em>Black Friday</em> in un centro commerciale americano, per intendersi.. <a href="/man/note/#blackfriday" class="nota"></a></p>
<pre><code>typedef struct {
    string evento;
    bool   esito;
} PostIt ;</code></pre>
<p>Il secondo dogma del C’hi++ è l’esistenza di una memoria persistente dell’Universo che mantiene traccia dell’esito delle scelte fatte in ciascun ciclo; qualcosa di simile all’inconscio collettivo di Jung o ai <em>vāsanā</em> dell’Induismo:</p>
<blockquote>
<p>Ci sono due categorie di saṁskāra; la prima consiste nelle vāsanā, che sono impressioni lasciate nella mente dagli avvenimenti passati, tracce qui conservate allo stato latente ma pronte a manifestarsi in presenza delle condizioni adatte, cioè di situazioni analoghe a quelle che le hanno generate, e che le attiverebbero a causa della loro affinità. Sulla spinta delle vāsanā, una volta che siano attivate, e degli stati d’animo che queste manifestano, l’individuo presenta una tendenza inconscia ad agire in un determinato modo, e più in generale ad avere un certo tipo di comportamento, di sensibilità, di carattere; si tratta di una predisposizione innata che lo induce, nel bene come nel male, ad un comportamento analogo a quello che ha tenuto in passato, creando un circolo vizioso (o virtuoso) che si autoalimenta.<a href="/man/note/#vasana" class="nota"></a></p>
</blockquote>
<p>I <em>Post-It</em>, come li chiamava il Maestro Canaro, non sono indispensabili per il C’hi++, sono solo un’auspicio, perché la loro esistenza dà un senso alla nostra vita. Ho detto: <em>dà</em> in vece di: <em>darebbe</em> perché, così come avviene per gli esopianeti, noi non li “vediamo”, ma possiamo inferire la loro esistenza dall’effetto che hanno su ciò che li circonda: istinto, premonizioni, <em>deja-vu</em>.<br />
L’esistenza dei <em>Post-It</em> rende l’Universo <em>stateful</em><a href="/man/note/#stateful" class="nota"></a> e quindi più appetibile per noi, ma anche in un Universo <em>stateless</em><a href="/man/note/#stateful" class="nota"></a>, in cui ciascun ciclo di esistenza fa storia a sé, noi non avremmo né motivo né convenienza a comportarci in maniera egoistica. In primo luogo perché, come abbiamo già detto, essendo tutti la manifestazione di una stessa Energia, ciò che facciamo agli altri lo facciamo in realtà a noi stessi; in secondo luogo perché non è detto che in ciascun ciclo di esistenza il nostro io cosciente si manifesti nella stessa persona e quindi, se in un ciclo siamo <em>Jack the Ripper</em>, in un altro potremmo essere Mary Ann Nichols.<br />
I <em>Post-It</em> furono sempre una spina nel fianco, per il Maestro Canaro, che spese gli ultimi anni della sua vita cercando un modo per ricondurli a qualcosa di reale o di eliminarli dalla dottrina, ma non riuscì a fare nessuna delle due cose. Inizialmente pensò la cosa più ovvia, ovvero che i Post-It fossero nel cervello, che fossero una particolare mappatura delle sinapsi contenente le istruzioni per reagire a determinate condizioni future<a href="/man/note/#openworm" class="nota"></a>. Ipotizzò anche che i sogni avessero la duplice funzione di prepararci a queste condizioni, anticipandocele e tenendo vive le connessioni cerebrali che avremmo dovuto sfruttare per affrontarle. Tutto questo, però, poteva essere solo una proiezione dei Post-It, una copia in memoria RAM di informazioni preservate altrove, perché, per poter essere persistenti, i Post-It devono trovarsi al di fuori dello <em>scope</em> della nostra esistenza, nella ROM o nell’<em>hard-disk</em> dell’Universo:</p>
<pre><code>/** Dichiarazione della struttura PostIt */
typedef struct {
    string evento;
    bool   esito;
} PostIt ;

void eternita() 
{
    /** Array di puntatori a PostIt */
    PostIt** vasana;

    while(1) {
        
        /** Inizio di un nuovo ciclo */
        unoPrimigenio();        
        bigBang();
        
        /**
         *  L&#39;array di eventi viene passato alle fasi
         *  espansione e di contrazione, che lo incrementano
         *  in funzione delle esperienze fatte dagli 
         *  esseri senzienti
         */
        espansione(vasana);        
        contrazione(vasana);

        /**
         *  Qui gli esseri senzienti sono annichiliti,
         *  ma l&#39;informazione non si perde, perché è 
         *  salvata altrove
         */
        bigCrunch();
    }
}</code></pre>
<p>I Post-It, quindi, sono per definizione metafisici (o, nel caso del codice qui sopra, <em>meta-ciclici</em>) perché tutto ciò che è fisico verrà annichilito al termine di un ciclo di esistenza e rigenerato all’inizio del seguente. Possiamo credere nella loro esistenza, ma dobbiamo farlo per fede, in maniera dogmatica.<br />
Il Maestro Canaro rifuggiva i dogmi; diceva che se tu imponi una verità, poi sei legato a essa e non puoi più cambiare idea, anche se ti accorgi di avere sbagliato. Prendi il tuo libro, per esempio; quel sottotitolo che hai scelto: <em>Lo scopo della vita è il debug</em> ti impone di credere nei Post-It. Se il giorno dopo che l’hai pubblicato si scoprisse che non esistono, saresti costretto a ristamparlo o ad accettare il fatto che dice una cosa non vera. Il Maestro Canaro non voleva che questo avvenisse al C’hi++; per questo motivo, stabilì che dovesse avere un versionamento, come il software: perché potesse evolversi.</p>
<hr />
<p>I letterati, gli scultori, i pittori non possono modificare le loro opere, una volta che sono state pubblicate. Possono dare un ritocco di colore qui, un colpo di scalpello là, ma si tratta sempre di aggiustamenti minimi, che non cambiano la struttura stessa dell’arte-fatto. I musicisti, i teatranti e, in parte, i cineasti sono un po’ più fortunati, perché possono apportare più facilmente delle modifiche alle loro opere, ma si tratta comunque di eventi che accadono di rado.<br />
Al contrario, la buona produzione di software ha il vantaggio di essere in continua evoluzione. Un software può essere <em>stabile</em>, ovvero non avere difetti noti, ma non è mai finito, completo, <em>perfetto</em>; sia perché l’utilizzo potrebbe rivelare dei difetti sfuggiti alla fase di test, sia perché delle variazioni del contesto di utilizzo potrebbero richiedere delle modifiche al sistema. Il buon software viene quindi costantemente aggiornato e le diverse versioni di uno stesso prodotto sono numerate in maniera progressiva con dei codici composti da tre numeri separati da punti che indicano, rispettivamente, la versione <em>major</em>, la versione <em>minor e</em> la <em>patch</em>; per esempio: <em>1.4.12</em>. La versione <em>major</em> viene incrementata ogni volta che si apportano delle drastiche modifiche al software, rendendolo incompatibile con le versioni precedenti. La versione <em>minor</em> viene incrementata quando si modifica il codice in maniera minore, aggiungendo o modificando delle funzionalità in maniera compatibile con le versioni precedenti. Il numero di <em>patch</em> è incrementato ogni volta che si apportano delle modifiche o delle correzioni anche minime al sistema. La <em>major version zero</em> (<em>0.y.z</em>) è destinata allo sviluppo iniziale, quando il software non è ancora stabile e tutto può cambiare in ogni momento.</p>
<hr />
<p>Prima ti ho detto che gli scienziati non sono infallibili. Non è una maldicenza: è la verità; gli scienziati sono i primi ad ammetterlo e questa è la loro forza, perché possono correggere i loro errori senza perdere di credibilità. Il Maestro Canaro voleva che questo fosse possibile anche per il C’hi+. Come scrisse alla fine della sua <a href="/proposta"><em>Proposta per una metafisica open-source</em></a>:</p>
<blockquote>
<p>Se anche un giorno dovessi scoprire che gli elementi costituivi dell’Universo non si chiamano <em>spazioni</em>, ma <em>culturi</em> e fossi per ciò costretto a cambiare il nome della mia cosmogonia in <em>Culturismo</em>, io incrementerò di un’unità la <em>major-version</em> del mio progettto e andrò avanti. Non per ostinazione, né per idealismo, ma perché questa <em>metafisica-non-metafisica</em>, come l’ho definita prima, funziona: mi aiuta a decidere quale sia la cosa giusta da fare quando non è facile capire quale sia la cosa giusta da fare e mi aiuta ad affrontare i momenti difficili della vita, mia o altrui che sia, senza accettazioni per fede, ma basandomi solo su considerazioni di ordine logico. Inoltre, è una storia che non è ancora stata scritta e, allo stesso tempo, la storia che la nostra razza scrive da sempre. Mi sembra un motivo più che sufficiente.</p>
</blockquote>
</section>
</section>
<a href="/man/istruzioni-condizionali" class="left" title="Vai a: Istruzioni condizionali"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/classi-oggetti" class="right" title="Vai a: Classi e oggetti"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/istruzioni-iterative" class="left" title="Vai a: Istruzioni iterative"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/ereditarieta" class="right" title="Vai a: L&#39;ereditarietà"><em></em></a>
<section id="classi-e-oggetti-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Classi e oggetti</a></h1>
<blockquote>
Ceci n'est pas une |
</blockquote>
<section class="testo">
<p>La possibilità di definire nuovi tipi di dato grazie alle classi è la caratteristica principale del C++.</p>
<p>I linguaggi di programmazione “tradizionali”, come il Cobol il Fortran o il Pascal, hanno un insieme limitato di tipi di dato: interi, numeri in virgola mobile, booleani, caratteri e stringhe.. giusto quello che serve a gestire una scheda anagrafica o un conto in banca. Il C e il Pascal hanno anche la possibilità di accorpare questi dati in strutture, enumerati o array, ma si tratta solo di contenitori, privi di logica interna. Inoltre, come hai visto, i dati all’interno di una <code>struct</code> sono accessibili a qualunque componente del programma, quindi, se li si modifica, va modificato anche il codice che li utilizza. Immagina di definire una struttura per la gestione dell’orario, che contenga tre interi, uno per le ore, uno per i minuti e uno per i secondi:</p>
<pre><code>struct Orario {
    int h;
    int m;
    int s;
};</code></pre>
<p>Per utilizzare questa struttura è necessario conoscerne il contenuto e il rapporto fra un valore e l’altro; in particolare, è necessario sapere (e ricordarsi):</p>
<ul>
<li>che la variabile <code>h</code> può contenere solo valori da 0 a 23;</li>
<li>che il valore di <code>m</code> può contenere solo valori da 0 a 59;</li>
<li>che il valore di <code>s</code> può contenere solo valori da 0 a 59;</li>
<li>che se <code>s</code> supera il valore di 59, <code>m</code> va incrementato di 1;</li>
<li>che se <code>m</code> supera il valore di 59, <code>h</code> va incrementato di 1;</li>
</ul>
<p>Questo è l’opposto del <em>low coupling</em> di cui abbiamo parlato <a href="/man/struttura-dei-programmi#coupling" class="xref">tempo fa</a>, perché lega indissolubilmente una funzione alla struttura del dato che deve gestire. Per capirsi: una funzione di aggiornamento dei minuti dovrà essere qualcosa di simile a:</p>
<pre><code>void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}</code></pre>
<p>Se un giorno decidessimo di modificare la struttura <code>Orario</code>, dovremmo ricordarci di riscrivere anche questa funzione, adeguandola alle nuove caratteristiche della struttura, con dispendio di tempo e la possibilità di fare degli errori. Inoltre, nulla impedirebbe a un programmatore cialtrone di scrivere una funzione che non tiene minimamente conto del rapporto fra ore, minuti e secondi:</p>
<pre><code>void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}</code></pre>
<p>Se inseriamo queste due funzioni in un programma, otteniamo:</p>
<pre><code>/** 
 * @file classi-struttura-orario.cpp
 * Gestione dei dati membro di una struct.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione di una struttura per gestire un orario */
struct Orario {
    int h;
    int m;
    int s;
};

/** Funzione per l&#39;incremento dei minuti */
void aggiornaMinuti(struct Orario &amp;o, int minuti) 
{
    /** Incrementa il numero dei minuti */
    o.m += minuti;
    
    /** Se necessario, incrementa le ore */
    if(o.m &gt;= 60) {

        o.m -= 60;
        o.h += 1;
        
        /** Se necessario, passa al giorno dopo */
        if(o.h &gt;= 24) {
            o.h -= 24;
        }
    }
}

/*  Funzione cialtrona per l&#39;incremento dei minuti */
void incrementa_m(struct Orario &amp;o, int minuti) 
{
    o.m += minuti;
}

int main()
{    
    struct Orario ora;

    /** Definisce dei valori iniziali prossimi al cambio di data */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Visualizza i valri iniziali */
    cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Richiama la funzione di aggiornamento */
    aggiornaMinuti(ora, 20);
    
    /** Visualizza i valori dopo l&#39;aggiornamento */
    cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    /** Reimposta i valori iniziali */
    ora.h = 23;
    ora.m = 45;
    ora.s = 00;

    /** Richiama la funzione cialtrona */
    incrementa_m(ora, 20);
    
    /** Visualizza i valori dopo l&#39;aggiornamento */
    cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.h &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.m &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora.s &lt;&lt; endl;

    
    return 0;
}
</code></pre>
<p>Compilando ed eseguendo questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/classi-struttura-orario.cpp -o src/out/esempio 
&gt; ./src/out/esempio                                          
23:45:00
00:05:00
23:65:00</code></pre>
<p>Come puoi vedere, la prima funzione ha aggiornato i dati in maniera corretta, mentre la seconda ha prodotto un valore non valido senza alcuna possibilità di controllo da parte del programma.</p>
<hr />
<p>Le variabili all’interno di una classe, sono dette <em>dati membro</em> o <em>attributi</em> della classe; le funzioni, invece, sono dette <em>funzioni membro</em> o <em>metodi</em>. Quando si crea una variabile di classe <code>X</code>, si dice che si: <em>istanzia</em> un <em>oggetto</em> di classe <code>X</code> o che si crea una <em>istanza</em> della classe. I dati e le funzioni membro di una classe sono direttamente accessibili alle funzioni membro della classe, ma per utilizzarli all’interno di funzioni esterne alla classe, si devono utilizzare gli operatori di selezione <code>.</code> e <code>-&gt;</code>. Il primo, detto <em>operatore di selezione diretta</em>, viene utilizzato con istanze della classe; il secondo, detto <em>operatore di selezi­one indiretta</em>, con puntatori ad esse:</p>
<pre><code>/** 
 * @file classi-punto.cpp
 * Accesso ai dati membro della classe.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

class Punto
{
public:             
    
    /** Dichiara i dati membro della classe */
    int _x, _y;

    /** 
     *  Le funzioni interne alla classe accedono ai
     *  dati membro con la sintassi ordinaria.
     */  
    Punto(int x, int y) {
        _x = x;
        _y = y;
    }
} ;

int main(int argc, char** argv) 
{
    /** Crea un oggetto di classe Punto */
    Punto p(5,6);       

    /** Assegna l&#39;istanza della classe al puntatore ptr */
    Punto *ptr = &amp;p ;   
    
    /** 
     *  Le funzioni esterne alla classe accedono ai
     *  dati membro tramite gli operatori di selezione.
     */  
    p._x    = 3 ;       // assegna un valore tramite l&#39;oggetto
    ptr-&gt;_y = 2 ;       // assegna un valore tramite il puntatore
    
    //...
}
</code></pre>
<p>L’etichetta <code>public</code> che vedi all’inizio della dichiarazione della classe è un <em>specificatore di accesso</em> e serve a stabilire quali membri della classe siano accessibili a funzioni esterne e quali invece siano riservati in esclusiva alla classe stessa.</p>
<blockquote>
<p>il selvaggio non ama dire il suo nome o farsi fotografare, perché per mezzo del suo nome o del ritratto egli è accessibile, e può quindi ricevere danno da chi con questi mezzi è in grado di raggiungerlo<a href="/man/note#selvaggio" class="nota"></a>.</p>
</blockquote>
<p>Questa frase di Lucien Lévy-Bruhl si applica anche alle classi del C++. Sia gli attributi che i metodi di una classe possono essere protetti da accessi o modifiche indebite grazie ai modificatori di accesso <code>private</code>, <code>protected</code> e <code>public</code>. I metodi o gli attributi dichiarati <code>private</code> sono accessibili solo alla classe stessa; quelli dichiarati come <code>protected</code> sono accessibili alla classe e a eventuali <a href="/man/ereditarieta" class="xref">classi derivate</a>; quelli dichiarati come <code>public</code> sono accessibili a qualunque elemento del programma. In mancanza di specifiche, tutti i dati e le funzioni di una classe verranno considerati:</p>
<ul>
<li><em>privati</em>, nel caso di una classe;</li>
<li><em>pubblici</em>, nel caso di <code>struct</code> o <code>union</code>.</li>
</ul>
<p>La visibilità dei dati membro di una <code>struct</code> può essere modificata con gli indicatori di accesso; i dati delle <code>union</code>, invece, possono essere solo pubblici.<br />
Il C++ permette di suddividere la dichiarazione di una classe in quante sezioni si desidera e nella sequenza <code>private</code>, <code>public</code>, <code>pro­tected</code> che si preferisce, ma un codice scritto in questo modo è sicuramente più difficile da leggere di uno in cui tutti i membri privati stanno da una parte e tutti quelli pubblici da un’altra. Quindi, a meno che tu non abbia delle buone ragioni per fare altrimenti (e ce ne potrebbero essere, nel caso di classi particolarmente complesse), cerca di raggruppare in tre sole sezioni <code>private</code>, <code>pro­tected</code> e <code>public</code> tutte le funzioni e i dati membro con gli stessi attributi di accesso:</p>
<pre><code>class Persona
{
 private:
    ...
 protected:
    ...
 public:
    ...
};</code></pre>
<p>Questo tipo di ordinamento della dichiarazione, oltre a garantirti una maggiore leggibilità del codice, ti consentirà, se lo desideri, di omettere lo specificatore di accesso <code>private</code> iniziale (è la soluzione di default, ricordi?).<br />
Mettiamo in pratica tutto ciò, convertendo in classe la struttura <code>Orario</code>:</p>
<pre><code>class Orario {
private:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
};</code></pre>
<p>La dichiarazione inizia con la parola-chiave <code>class</code>, seguìta dal nome della classe. Nel blocco di codice fra parentesi graffe che costituisce il corpo della classe, contiene i dati e le funzioni membro, accorpate per visibilità. In questo caso abbiamo messo prima i dati membro privati e poi quelli pubblici, ma avremmo potuto fare anche il contrario. Gli attributi <code>_h</code>, <code>_m</code> e <code>_s</code> compaiono dopo la parola-chiave <code>private</code> e saranno quindi visibili solo alle funzioni della classe stessa.<br />
La funzione <code>Orario</code> compare dopo l’etichetta <code>public</code> e sarà accessibile per ciò a qualsiasi parte del programma. Questa funzione, che ha lo stesso nome della classe, è detta <em>costruttore</em> e viene richiamata ogni volta che si crea una variabile di tipo <code>Orario</code>. Il suo scopo è di inizializzare le variabili all’interno della classe, in questo caso, impostando tutti e tre i valori a 0. Ne parleremo fra poco.<br />
L’ultima cosa che devi notare, nel codice qui sopra, è la presenza del carattere <code>;</code> alla fine del blocco di codice della classe, così come avviene per le <code>union</code> e le <code>struct</code>.</p>
<hr />
<p>Quando dichiariamo una variabile di tipo primitivo come <code>int</code>, o <code>double</code>, il compilatore svolge automaticamente tutta una serie di operazioni atte ad allocare lo spazio di memoria necessario a contenerla e a inizializzarlo. Il compilatore, però, non sa come vada creata e inizializzata una variabile di tipo <code>Orario</code> ed è per questo che la classe dovrà definire delle <em>funzioni di gestione</em> che spieghino sia come creare una nuova variabile, che come distruggerla, se necessario. Le funzioni di gestione sono di due tipi: i <em>costruttori</em> e i <em>distruttori</em>.<br />
I costruttori hanno alcune peculiarità che le distin­guono dalle altre funzioni membro:</p>
<ul>
<li>hanno lo stesso nome della classe;</li>
<li>non hanno un tipo di ritorno perché è implicito che ritornino una variabile della classe cui appartengono.</li>
</ul>
<p>Una stessa classe può avere più costruttori; la classe <code>Orario</code>, per esempio, potrebbe avere un costruttore privo di parametri, che inizializzi ore, minuti e secondi a zero e un costruttore che permetta invece di assegnare valori specifici a ciascun attributo:</p>
<pre><code>class Orario {
protected:
    int _h;
    int _m;
    int _s;
public:
    Orario() {
        _h = 0;
        _m = 0;
        _s = 0;
    }
    Orario(int h, int m, int s) 
    : _h(h % 24), _m(m % 60), _s(s % 60) {
    }
};</code></pre>
<p>La riga:</p>
<pre><code>: _h(h % 24), _m(m % 60), _s(s % 60) </code></pre>
<p>si chiama: <em>lista di inizializzazione</em> e ed equivale a scrivere:</p>
<pre><code>_h = h % 24;
_m = m % 60;
_s = s % 60;</code></pre>
<p>L’utilizzo dell’operatore modulo <code>%</code> è indispensabile, in questo caso, per evitare che siano assegnati valori non corretti alle variabili.<br />
Quando definisci un costruttore, puoi usare indifferentemente l’una o l’altra sintassi o anche mischiarle, a seconda dei casi. Un modo più succinto di ottenere lo stesso risultato con un unico costruttore è di utilizzare dei valori di default per i parametri:</p>
<pre><code>Orario(int h = 0, int m = 0, int s = 0) 
: _h(h % 24), _m(m % 60), _s(s % 60) {
}</code></pre>
<p>Alle volte, può essere utile definire un costruttore che crei delle nuove variabili della classe partendo da variabili esis­tenti, operando quindi una sorta di clonazione. Questo tipo di funzioni si chiamano: <em>costruttori di copia</em> o: <em>costruttori di inizializ­zazione</em> e richiedono come argomento un riferimento a una variabile della stessa classe:</p>
<pre><code>/** 
 * Dichiarazione del costruttore di copia 
 * all&#39;interno della classe. 
 * Possiamo copiare il valore delle variabili 
 * così com&#39;è perché è già stato verificato 
 * dal costruttore della variabile o1.  
 */
Orario::Orario(const Orario&amp; )
: _h(o._h), _m(o._m), _s(o._s) {
}

/** Utilizzo */
Orario o2 = o1;</code></pre>
<p>Il costruttore di copia è un tipo di costruttore molto importante in quanto presiede alla maggior parte delle attività di inizializzazione di oggetti della classe cui appartiene; per questa ragione, nel caso non venga definito dall’utente, è automaticamente generato dal compilatore.</p>
<hr />
<p>Come è facile intuire, mentre il costruttore di una classe presiede alla creazione di nuove variabili, il distruttore si occupa della loro cancellazione. Non sempre è necessario definire un distruttore per una classe. Una variabile di tipo <code>Orario</code>, che contiene solo tre interi, probabilmente non avrà bisogno di un distruttore, mentre una variabile che faccia uso di memoria dinamica quasi sicuramente sì. Il perché risulta più chiaro se si esamina la cosa dal punto di vista del compilatore. Per creare una variabile di tipo <code>Orario</code> il compilatore deve allocare spazio per:</p>
<pre><code>3 * sizeof(int);</code></pre>
<p>Quando arriva il momento di distruggere la variabile, il compilatore non farà altro che liberare i <code>3 * sizeof(int)</code> byte successivi all’indirizzo dell’oggetto; un comportamento che in questo caso è corretto, ma che potrebbe dare rivelarsi disastroso con una classe come questa:</p>
<pre><code>class Buffer
{
private:
    char* _dati;
    int   _size;
 public:
    Buffer(int size) 
    : _size(size) {
        _dati = new char[_size];
    }
    ...
};</code></pre>
<p>In mancanza di istruzioni specifiche, per distruggere una variabile di tipo <code>Buffer</code>, il compilatore libererà <code>sizeof(char*) + sizeof(int)</code> byte dopo il suo indirizzo di memoria, ma così facendo, distruggerà solo l’intero <code>_size</code> e il puntatore a char <code>_dati</code>, senza liberare l’area di memoria a cui quest’ultimo puntava. Questo, come sai, è un grave errore ed è necessario quindi aggiungere alla classe una funzione che lo istruisca in tal senso.<br />
Come il costruttore, il distruttore di una classe non ha tipo di ritorno, ma mentre ci possono essere più costruttori per una stessa classe, il distrut­tore è sempre unico. Non ha mai parametri formali e il suo nome è uguale a quello della classe cui appartiene, preceduto da un carattere tilde <code>~</code>:</p>
<pre><code>class Buffer
{
private:
    char* _dati;
    int   _size;
 public:
    Buffer(int size) 
    : _size(size) {
        _dati = new char[_size];
    }
    ~Buffer() {
        delete [] _dati
    }
};</code></pre>
<p>I distruttori possono essere chiamati in due modi:</p>
<ul>
<li><p><em>implicitamente</em>, dal programma, ogni volta che un oggetto esce dal suo campo d’azione o, nel caso di oggetti con visibilità globale, al termine della funzione <code>main</code>;</p></li>
<li><p><em>esplicitamente</em>, dal codice, ma in questi casi dovrai specificare il loro nome per intero, anteponendo il nome della classe e l’operatore di risoluzione <code>::</code>, così come vedremo fra poco.</p></li>
</ul>
<p>Attenzione, però: se a uscire dal campo d’azione è un puntatore, il ditruttore della classe non viene richiamato automaticamente, perciò gli oggetti creati in maniera dinamica con l’operatore <code>new</code> dovranno sempre distrutti per mezzo dell’operatore <code>delete</code>.</p>
<hr />
<p>Le funzioni membro devono essere dichiarate all’interno della dichiarazione della classe e possono essere definite sia dentro che fuori di essa. Definirle all’interno della dichiarazione della classe equivale a dichiararle <a href="/man/funzioni#inline" class="xref">inline</a> Se invece le si definisce esternamente alla dichiarazione della classe, vanno identificate aggiungendo il nome della classe prima di quello della funzione, seguito dall’<a href="/man/operatori#risoluzione" class="xref">operatore di risoluzione</a>:</p>
<pre><code>/** 
 * @file classi-classe-orario.cpp
 * Gestione dei dati membro di una classe.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/** Dichiarazione della classe */
class Orario {
private:
    int _h;
    int _m;
    int _s;
public:
    Orario(int h = 0, int m = 0, int s = 0);
};

/** Definizione del costruttore della classe */
Orario::Orario(int h, int m, int s) 
: _h(h % 24), _m(m % 60), _s(s % 60) 
{
}
    
/** La funzione main non fa parte della classe */
int main()
{    
    Orario ora;

    /** Questo codice darà errore */
    cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; &quot;:&quot; 
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Se compili questo codice, però, ottieni un errore: la funzione <code>main</code> può utilizzare il costruttore della classe <code>Orario</code> perché è dichiarato <code>public</code>, ma non può né leggere né modificare gli attributi definiti come <code>private</code>:</p>
<pre><code>&gt; g++ src/cpp/classi-classe-orario-1.cpp -o src/out/esempio
src/cpp/classi-classe-orario-1.cpp:34:44: error: &#39;_h&#39; is a protected member of &#39;Orario&#39;
    cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; &quot;:&quot; 
                                           ^
src/cpp/classi-classe-orario-1.cpp:14:9: note: declared protected here
    int _h;
        ^
src/cpp/classi-classe-orario-1.cpp:35:44: error: &#39;_m&#39; is a protected member of &#39;Orario&#39;
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; &quot;:&quot; 
                                           ^
src/cpp/classi-classe-orario-1.cpp:15:9: note: declared protected here
    int _m;
        ^
src/cpp/classi-classe-orario-1.cpp:36:44: error: &#39;_s&#39; is a protected member of &#39;Orario&#39;
         &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;
                                           ^
src/cpp/classi-classe-orario-1.cpp:16:9: note: declared protected here
    int _s;
        ^
3 errors generated.</code></pre>
<p>Il C++ prevede due modi per rendere disponibili gli attributi di una classe anche alle funzioni esterne alla classe stessa:</p>
<ul>
<li>le classi o le funzioni <code>friend</code>.</li>
<li>le <em>funzioni di interfaccia</em>;</li>
</ul>
<p>Il modo apparentemente più rapido per accedere ai dati privati di una classe attraverso una funzione o una classe esterna è quello di dichiararle come <code>friend</code>. In virtù di ciò, la funzione o la classe acquisteranno una visibilità completa sui dati protetti:</p>
<pre><code>class Orario {
private:

    /** Dati membro privati */
    int _h;
    int _m;
    int _s;

public:
    
    /** Costruttore della classe */
    Orario(int h = 0, int m = 0, int s = 0) ;

    /** Costruttore di copia inline */
    Orario(const Orario&amp; o) {
        _h = o._h;
        _m = o._m;
        _s = o._s;
    }

    /** Funzioni di lettura  */
    int getH() { return _h; }
    int getM() { return _m; }
    int getS() { return _s; }

    /** Funzioni di scrittura */
    int setH(int h) { return _h = (h % 24); }
    int setM(int m) { return _m = (m % 60); }
    int setS(int s) { return _s = (s % 60); }

    /** Dichiarazione di una funzione friend */
    friend int aggiornaMinuti(Orario&amp; o, int m);
    friend class Orologio();    

};</code></pre>
<p>Come ho detto, questa soluzione è solo apparentemente più rapida, perché tutta la logica di gestione dei dati della classe <code>Orario</code> dovrà essere replicata sia nella funzione <code>aggiornaMinuti</code> che nella classe <code>Orologio</code>. Inoltre, se in seguito dovessi apportare delle modifiche alla classe <code>Orario</code>, le stesse modifiche andranno riportate anche nelle funzioni delle classi <code>friend</code> che la utilizzano.<br />
Un metodo più sicuro e più efficiente di gestire gli attributi privati di una classe consiste nel definire delle funzioni membro pubbliche che consentano un accesso controllato ai dati che si vogliono proteggere. Nel caso della classe <code>Orario</code>, ne occorrono sei: una per la lettura e una per la scrittura di ciascuno dei tre dati membro:</p>
<pre><code>/** Funzioni di lettura */
int getH() { return _h; }
int getM() { return _m; }
int getS() { return _s; }

/** Funzioni di scrittura */
int setH(int h) { return _h = (h % 24); }
int setM(int m) { return _m = (m % 60); }
int setS(int s) { return _s = (s % 60); }</code></pre>
<p>Ovviamente, puoi chiamare queste funzioni come preferisci, ma utilizzare i prefissi <code>get</code> e <code>set</code>, seguiti dal nome del parametro su cui operano rende più facile l’utilizzo della classe da parte di altri programmatori. È lo stesso motivo per cui aggiungo il carattere <em>underscore</em> davanti al nome dei dati membro delle classi, in modo che li si possa distinguere dai parametri delle funzioni che abbiano lo stesso nome:</p>
<pre><code>return _h = (h % 24);</code></pre>
<p>L’utilizzo della lista di inzializzazione, all’interno del costruttore, ti permette di utilizzare dei parametri che abbiano lo stesso nome dei dati membro della classe:</p>
<pre><code>class Punto
{
    int x, y;
public:             
    Punto(int x, int y) 
    : x(x), y(y) {
    }
};</code></pre>
<p>ma il fatto che qualcosa sia possibile non vuol dire che sia una buona scelta, come penso che tu abbia imparato, nel corso della tua vita.<br />
Non sei nemmeno obbligato a dichiarare le funzioni di interfaccia come <code>inline</code>; l’ho fatto qui perché erano estremamente semplici, ma si dovrebbe evitare di aggiungere il codice delle funzioni all’interno della dichiarazione di una classe già di per sé complessa perché la rende più difficile da leggere. C’è anche chi pensa che ciò sia sbagliato perché, se da un lato rende le cose più facili a chi scrive il codice, complica la vita di chi lo legge perché mischia ciò che la classe fa con il modo in cui lo fa<a href="/man/note#inline" class="nota"></a>. Io non sono del tutto d’accordo con questa affermazione perché alle volte è più comodo e rapido avere il codice delle funzioni all’interno della dichiarazione della classe, ma essendo un precetto che antepone il bene di tanti (i fruitori del codice) rispetto a quello del singolo (l’autore del codice), mi sono sentito in dovere di riferirtelo.<br />
Così come abbiamo fatto per il costruttore della classe, potremmo unificare le funzioni di lettura e scrittura, utilizzando un parametro di default che determini il comportamento del programma:</p>
<pre><code>int ore(int h = -1) { 
    return _h = ((h != -1) ? _h = (h % 24) : h); 
}</code></pre>
<p>Questa sintassi è l’equivalente di:</p>
<pre><code>int ore(int h = -1) { 
    if(h != -1) {
        _h = (h % 24);
    }
    return _h; 
}</code></pre>
<p>Anche se meno evidente, è più comoda perché permette di tenere il codice su una sola riga e ti dà modo di fare un po’ di pratica con gli operatori.<br />
Questo tipo di funzioni, però, ha due difetti: limita i valori che puoi assegnare all’attibuto e limita la granularità dei privilegi che puoi assegnare a chi utilizza la classe. Limita il numero di valori che puoi assegnare all’attibuto, perché esclude il valore del parametro di default — cosa che non crea problemi in questo caso, dato che non esiste un’ora <code>-1</code>, ma che potrebbe farlo nel caso di una stringa con parametro di default nullo. Limita la granularità dei privilegi sulle funzioni, perché ti costringe a rendere pubbliche le funzioni di scrittura dei dati membro e questo, in certi casi potrebbe non essere saggio. Ti consiglio perciò di scrivere sempre due funzioni di interfaccia distinte per la lettura e la scrittura: sul momento ti sembrerà uno spreco di tempo, ma, a meno che il tuo programma non sia particolarmente banale, o prima o poi ti accorgerai di aver fatto la scelta corretta.</p>
<hr />
<p>Ogni variabile di una determinata classe possiede delle copie dei dati membro, mentre le funzioni membro di una classe sono condivise da tutte le sue istanze. Per consentire al programma di sapere quale sia l’istanza che sta richiamando un determinato metodo, il compilatore aggiuge a ogni chiamata a funzione un parametro nascosto chiamato <code>this</code>, che punta all’istanza che ha richiesto la funzione. Il parametro <code>this</code>, anche se non dichiarato, può essere utilizzato nel corpo delle funzioni membro per riferirsi all’istanza corrente. Per esempio, il costruttore di copia della classe <code>Orario</code> (così come qualsiasi altra funzione membro della classe) potrebbe essere riscritto così:</p>
<pre><code>Orario(const Orario&amp; o) {
    this-&gt;_h = o._h;
    this-&gt;_m = o._m;
    this-&gt;_s = o._s;
}</code></pre>
<p>Le uniche funzioni membro che non possono fare uso del puntatore <code>this</code> sono quelle dichiarate come <code>static</code>.<br />
Una classe può avere sia attributi che funzioni membro statiche. La particolarità di questi elementi è di non essere legati a una specifica variabile, ma di essere condivisi da tutte le istanze della classe; questo fa sì che abbiano un comportamento leggermente diverso da quello dei membri non statici:</p>
<ul>
<li><p>per inizializzarli all’interno della dichiarazione, li si deve dichiarare come <code>inline static</code><a href="/man/note#cpp17" class="nota"></a>, altrimenti, devono essere inizializzati altrove nel programma, come un qualsiasi oggetto a visibilità globale;</p></li>
<li><p>si può accedere ad essi, oltre che con i normali operatori di selezione, facendo riferimento alla classe stessa.</p></li>
</ul>
<p>Cerco di chiarirti un po’ le idee con un esempio:</p>
<pre><code>/** 
 * @file classi-static.cpp
 * Funzioni e dati membro statici di una classe.
 */
 
#include &lt;iostream&gt;

using namespace std;

/** Classe generica con membri statici */
class Contatore {
private:

    /** Definisce il dato statico */
    static int _nIstanze;     

public:
    
    /** Il costruttore incrementa il numero di istanze */
    Contatore() {
        _nIstanze++;
    }
    
    /** Funzione di interfaccia statica */
    static int nIstanze() {  
        return _nIstanze;
    }
};

/** Inizializza il membro statico  */ 
int Contatore::_nIstanze = 0;

int main()
{    
    /** Crea la prima istanza della classe */
    Contatore c1;

    /** Richiama la funzione statica dall&#39;oggetto */
    cout &lt;&lt; &quot;Da istanza c1: &quot; &lt;&lt; c1.nIstanze() &lt;&lt; endl;

    /** Crea altre due istanze della classe */
    Contatore c2, c3;
   
    /** 
     * Richiama la funzione statica dagli oggetti 
     * e direttamente dalla classe
     */
    cout &lt;&lt; &quot;Da istanza c2: &quot;&lt;&lt; c2.nIstanze()         &lt;&lt; endl;
    cout &lt;&lt; &quot;Da istanza c3: &quot;&lt;&lt; c3.nIstanze()         &lt;&lt; endl;
    cout &lt;&lt; &quot;Dalla classe : &quot;&lt;&lt; Contatore::nIstanze() &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, otterrai:</p>
<pre><code>&gt; g++ src/cpp/classi-static.cpp -o src/out/esempio
&gt; src/out/esempio                                 
Da istanza c1: 1
Da istanza c2: 3
Da istanza c3: 3
Dalla classe : 3</code></pre>
<p>Come vedi, tutte le istanze della classe condividono lo stesso valore per il dato membro <code>nIstanze</code> e la funzione di interfaccia, dichiarata come <code>static</code>, può essere richiamata anche senza fare riferimento a un’istanza. Per questo motivo, se utilizzi il puntatore <code>this</code> all’interno di una classe statica:</p>
<pre><code>static int nIstanze() {  
    return this-&gt;_nIstanze;
}</code></pre>
<p>ottieni l’errore di compilazione:</p>
<pre><code>&gt; g++ src/cpp/classi-static.cpp -o src/out/esempio 
src/cpp/classi-static.cpp:26:16: error: invalid use of &#39;this&#39; 
 outside of a non-static member function
        return this-&gt;_nIstanze;
               ^
1 error generated.</code></pre>
<p>perché, se la funzione fosse chiamata direttamente dalla classe, <code>this</code> non punterebbe ad alcun oggetto.</p>
<hr />
<p>L’ultima cosa di cui dobbiamo parlare, sono le <em>classi anonime</em>, un tipo particolare di classe che, come dice il nome (perdonami il gioco di parole), non hanno nome e per ciò non possono avere né un construttore né un distruttore e non possono essere utilizzate né come parametri né come valori di ritorno delle funzioni.<br />
L’unico modo per dichiarare un ogetto con classe anonima è di aggiungerlo alla dichiarazione della classe stessa:</p>
<pre><code>class 
{
...
} obj;</code></pre>
<p>Questo codice dichiara allo stesso tempo la classe e la sua unica istanza, la variabile globale <code>obj</code>.<br />
Quando il Maestro Canaro provò a fare il <em>porting</em> dell’<a href="/man/mitopoietica#universo-in-cpp" class="xref">Universo in C++</a>, avrebbe voluto utilizzare una classe anonima per la variabile <code>Dio</code>, perché, priva di un costruttore e istanziata dalla sua stessa classe, quella variabile sarebbe stata visibile in tutto il codice, ma nessuna parte del programma ne avrebbe potuta generare un’altra:</p>
<pre><code>/** 
 * @file classi-dio.cpp
 * Dichiarazione della classe Dio.
 */
 
#include &lt;iostream&gt;

using namespace std;

// Classe astratta da utilizzare come base
// per tutti gli elementi del Creato.
class Creatura {
public:
   // Funzione virtuale pura di verifica.
   virtual bool isGood() = 0;
   
};

// Classi derivate per la gestione degli 
// elementi del Creato.
class Mare   : public Creatura {
    bool isGood() { return true; }; 
};
class Uomo   : public Creatura { 
    bool isGood(); 
};
class Donna  : public Creatura {};
class Padre  : public Uomo     {};
class Figlio : public Uomo     {};
class Popolo : public Creatura {};

class  {
private:

    // Funzioni membro per la generazione degli elementi 
    // del Creato, accessibili solo alla classe. 
    Creatura* creaLuce();
    Creatura* creaStelle();
    Creatura* creaAcquaTerra();
    Creatura* creaPiante();
    Creatura* creaSoleLuna();
    Creatura* creaAnimali();

    // Funzioni per la generazione degli umani.
    Uomo&amp;  creaUomo();
    Donna&amp; creaDonna(Uomo&amp; adamo);

    // Interruzione per il settimo giorno.
    void shabat();
    
    // Funzioni di interfaccia con gli umani.
    bool popEden(Uomo&amp; adamp, Donna&amp; eva);
    bool printComandamenti(ostream&amp; tavole);
    bool checkFede(Padre&amp; abramo, Figlio&amp; isacco);
    bool splitAcque(Mare&amp; marRosso, Popolo&amp; ebrei);

protected:
    
    // Funzione membro accessibile anche alle 
    // classi figlio.
    bool donaVita(Uomo&amp; lazzaro);
    
public:

     // Funzione membro pubblica.
     // Torna il numero di preghiere da recitare.
    int rimettiPeccati(Creatura* fedele);
                   
} Dio;
</code></pre>
<p>L’idea, in sé, era buona, ma venne abbandonata quando si trattò di definire gli attributi e i metodi della classe. Dio, infatti, ha <em>tutti</em> gli attributi immaginabili e ciascuno di essi ha valore infinito. Allo stesso modo, essendo onnipotente, deve avere delle funzioni membro per portare a termine <em>tutte</em> le possibili azioni e il codice di queste funzioni, utilizzando una classe anonima, avrebbe dovuto essere definito all’interno della dichiarazione della classe, perché, mancando un nome, non lo si sarebbe potuto definire esternamente:</p>
<pre><code>bool ...::checkFede(Padre&amp; abramo, Figlio&amp; isacco)
{

}</code></pre>
<hr />
<p>È un peccato che Platone non sia vissuto duemilaquattrocentoundici anni, perché avrebbe certamente apprezzato l’affinità delle classi del C++ con le sue teorizzazioni riguardo le <em>idee</em> e le <em>forme</em>. In questo codice, possiamo considerare la dichiarazione della classe come l’<em>idea</em> del pesce, mentre l’istanza ne è la <em>forma</em>:</p>
<pre><code>/** 
 * @file classi-pesce.cpp
 * Definizione della classe Pesce.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

/**
 *  Dichiarazione della classe: idea
 */
class Pesce {
private:

    /** Dati membro privati */
    string _specie;
    bool   _commestibile;
    
public:
    
    /** Costruttore della classe inline */
    Pesce(const char* specie, bool commestibile) 
    : _specie(specie), _commestibile(commestibile)
    {
    }
    
    /** Costruttore di copia inline */
    Pesce(const Pesce&amp; p) {
        this-&gt;_specie       = p._specie;
        this-&gt;_commestibile = p._commestibile;
    }

    /** Distruttore inline */
    ~Pesce() { 
    }

    /** Funzioni di interfaccia */
    const char* getSpecie() { return _specie.c_str(); }
    bool isCommestibile()   { return _commestibile;   }

};


/**
 *  Istanza della classe: forma
 */
int main()
{             
    Pesce pesce(&quot;spigola&quot;, true);
    
    cout &lt;&lt; pesce.getSpecie() &lt;&lt; &quot;: &quot;
         &lt;&lt; (pesce.isCommestibile() ? &quot;sì&quot; : &quot;no&quot;)
         &lt;&lt; endl;
     
    return 0;
}
</code></pre>
<p>Come abbiamo detto parlando del <a href="/man/preprocessore#pesce" class="xref">preprocessore</a>, però, la parola <em>pesce</em> può avere diversi valori, a seconda di chi la utilizza, quindi, la dichiarazione/idea della classe <code>Pesce</code> varierà a seconda dell’utilizzo che se ne deve fare. Per esempio, sapere se un pesce sia commestibile o no è determinante per un pescatore o per un ecologista, ma potrebbe non esserlo per un biologo marino. Al contrario, il tipo di scheletro o il sistema di respirazione, rilevanti per un biologo, sono del tutto irrilevanti per un pescivendolo, a cui invece interesseranno sicuramente il prezzo al chilo, la data di cattura e il tipo di conservazione applicato. Di questo, parleremo nelle prossime lezioni; adesso dobbiamo tornare su una questione che avevamo lasciato in sospeso, ovvero il precetto:</p>
<blockquote>
<p>Amiamo ciò che ci ucciderà (se tutto va bene)</p>
</blockquote>
<p>Abbiamo visto che l’Amore è una forza allo stesso tempo gravitazionale ed entropica, perché unisce gli individui, ma allo stesso tempo li porta a riprodursi in forme differenti.<br />
In un certo senso, possiamo considerare l’Amore come il “costruttrore” delle nostre istanze, perché genera le condizioni che spingono i nostri genitori a incontrarsi e ad accoppiarsi e soprattutto li spinge a restare insieme dopo l’accoppiamento. La monogamia non è una costante, anzi, in natura esistono quattro modi differenti di gestire la prole e John Maynard Smith li ha catalogati in base alla specie animale che le adotta<a href="/man/note#maynard" class="nota"></a>:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Anitra</strong></td>
<td>il maschio abbandona, la femmina alleva</td>
</tr>
<tr class="even">
<td><strong>Spinarello</strong></td>
<td>la femmina abbandona, il maschio alleva</td>
</tr>
<tr class="odd">
<td><strong>Moscerino</strong></td>
<td>entrambi i genitori abbandonano</td>
</tr>
<tr class="even">
<td><strong>Gibbone</strong></td>
<td>entrambi i genitori allevano</td>
</tr>
</tbody>
</table>
<p>Noi, per lo più, ci comportiamo come i gibboni, anche se è un comportamento che conviene principalmente alle femmine. Da un punto di vista strettamente statistico, un maschio avrebbe più probabilità di tramandare il suo DNA se fecondasse più compagne. È lo stesso motivo per cui, nel nostro campo, si creano delle copie dei proprii dati in <em>server-farm</em> diverse (e distanti) da quella originale, in modo che se il sito principale va a fuoco o se viene colpito da un meteorite, i dati non vadano persi. L’Amore, invece, spinge il <em>webmaster</em> a tenere i suoi dati in una sola <em>server-farm</em>, accudendoli e proteggendoli personalmente, per preservarne il contenuto informativo.<br />
Ciascuno di noi è l’istanza di una classe che è stata chiamata a vivere per svolgere un determinato compito. Veniamo generati, assolviamo il nostro compito e poi, così come gli oggetti di un programma, dobbiamo essere rimossi per non occupare inutilmente delle risorse del sistema. Per essere certi che questo avverrà, c’è bisogno di un distruttore che termini la nostra esistenza nel momento opportuno. L’Amore può servire anche a questo: così come ha generato nei nostri genitori l’interesse necessario a causare la nostra nascita, genera in noi un interesse che causa le condizioni necessarie alla nostra morte. Questo interesse può applicarsi a qualunque cosa — una sostanza, un’attività, un luogo, una o più persone — e deve essere superiore all’interesse che l’individuo ha nei confronti della sua stessa esistenza.<br />
Capisci bene che questo è un aspetto potenzialmente rischioso della nostra dottrina, perché potrebbe giustificare delle forme di auto-indulgenza nei confronti di sostanze o attività dannose come l’abuso di droga o alcol. La morte di Robert Capa, sopravvissuto allo sbarco in Normandia e ucciso, dieci anni dopo, da una mina anti-uomo mentre fotografava dei soldati sul delta del Fiume Rosso, è un esempio inequivocabile di questo precetto, ma come possiamo sapere se la morte di Jimi Hendrix, Janis Joplin o Jim Morrison, sia stata ciò che doveva essere, o non sia stata, al contrario, la conseguenza di una scelta drammaticamente errata? Soprattutto, come possiamo evitare che questo precetto non diventi il pretesto per altre scelte errate?<br />
Ho scelto le tre “J” — Jim, Jimi e Janis — perché il Maestro Canaro pensava che, nel loro caso, la morte fosse ciò a cui erano destinati:</p>
<blockquote>
<p>Capisci, avevano tutti ventisette anni e poi quella “J” che ricorre nel nome.. non credo fosse un caso. “<em>Muß es sein? Es muß sein!</em>”, come direbbe Beethoven. So cosa stai pensando: che sto cercando di definire un dogma per giustificare una mia speranza, ma non è così. La teoria del “27 Club”, anche se include Amy Winehouse e Robert Johnson, lascia dolorosamente fuori il Elvis e Andrea Pazienza<a href="/man/note#pazienza" class="nota"></a>, che io ho amato molto di più.</p>
</blockquote>
<hr />
<p>D’altro canto, non sempre le cose vanno come previsto e può accadere che per una scelta errata o per paura, una “istanza” devii dal suo cammino anticipando o ritardando la propria fine. Questo perché il nostro agire è preordinato, ma non è obbligato: siamo programmati per fare bene qualcosa e meno bene quacos’altro, ma siamo liberi di scegliere cosa fare.<br />
Molti si sono chiesti se le nostre azioni siano predestinate o se esista il libero arbitrio; la risposta è: sì, ma in tempi diversi. Riprendendo il paragone con le classi, la predestinazione è nella dichiarazione, mentre il libero arbitrio è proprio delle istanze. L’insieme dei tuoi attributi e dei tuoi metodi è predefinito: puoi saltare, ma non puoi volare; puoi nuotare, ma non puoi restare a lungo in immersione; il tuo sangue ha un flusso ben definito e così pure il tuo cibo. D’altro canto, quello che deciderai di fare dipende da te: puoi decidere di attenerti ai limiti che ti sono stati imposti o cercare di sorpassarli, creandoti delle ali artificiali per volare o dei respiratori per andare sott’acqua. Attento, però: questo non farà di te né un uccello né un pesce. Puoi superare i limiti imposti dalla tua classe, ma non la puoi cambiare.<br />
Non è difficile conciliare il libero arbitrio con l’onniscenza e l’onnipotenza di Dio; la risposta è ovvia, se non fai distinzione fra artefatto e artefice. Con buona pace di Einstein, Dio gioca davvero a dadi con l’Universo; lo sbaglio è pensare che il risultato di un tiro di dadi derivi da fattori casuali. Quando si lanciano dei dadi, il risultato finale varia in base a due ordini di fattori, uno facilmente prevedibile e uno difficilmente prevedibile. Le possibili combinazioni dei dadi sono facilmente prevedibili, noto il numero delle facce e i valori che vi sono impressi. La combinazione che verrà effettivamente prodotta da un certo lancio di dadi è altrettanto deterministica, ma dipende da fattori molto più complessi, come il tempo per cui li si è agitati, della loro posizione al momento del lancio o l’angolo di impatto con il piano. Così come è impossibile che un lancio di dadi nel Backgammon produca un valore superiore a dodici, è impossibile che un dado, lanciato con una certa energia in una certa direzione adotti una traiettoria diversa da quella che gli impongono le Leggi della fisica. Anche se non riusciamo a prevederla, non vuol dire che sia casuale.<br />
Allo stesso modo, quando l’Uno primigenio “lancia” la sua energia nell’Universo, è <em>onniscente</em>, perché conosce tutte le scelte che in precedenza si sono rivelate corrette e quelle che invece hanno prodotto del dolore; è <em>benevolo</em>, perché spera di ottenere il miglior risultato possibile, evitando di ripetere gli sbagli già fatti; è <em>onnipotente</em>, perché può potenzialmente produrre tutte le possibili permutazioni dell’esistenza dovute all’interazione energia/spazioni. Malgrado ciò, non sa quale di quelle permutazioni avrà luogo e non lo vuole nemmeno sapere. Auspica che il nuovo ciclo di esistenza sia migliore dei precedenti, ma non desidera che avvenga un certo evento o che non avvenga un altro, perché il desiderio lo renderebbe vulnerabile alle lusinghe dell’Annosa Dicotomia.<br />
Un famoso velista<a href="/man/note#straulino" class="nota"></a>, una volta disse:</p>
<blockquote>
<p>Quando sei in regata e non c’è vento, non lo andare a cercare.<br />
Metti la prua nella direzione giusta e aspetta: il vento arriverà.</p>
</blockquote>
<p>L’Uno si comporta in maniera simile: ligio al precetto del <em>Wu Wei</em><a href="/man/note#wu-wei" class="nota"></a> taoista, pone le condizioni necessarie per il ripetersi degli eventi che si sono rivelati benefici, ma non li impone. Scrive l’analisi del sistema, ma lascia che siano i programmatori a scrivere il codice, anche se sa che faranno certamente degli errori. Definisce delle regole, ma lascia le sue istanze libere di trasgredirle, perché sa che l’evoluzione è sempre frutto di un errore venuto male, di qualcosa che non sarebbe dovuto esssere così e invece così è meglio.<br />
Le regole non devono essere una rete che imprigiona e immoblizza, ma una rete che salva e sostiene, così come il “religare” delle religioni non deve essere un legame che impastoia, ma che sorregge. Le regole che definiscono e quindi limitano la nostra esistenza sono come un edificio che abbia una struttura in cemento armato e dei muri in cartongesso. I muri interni possono essere abbattuti o modificati, se necessario, ma i pilastri e le travi devono essere lasciati al loro posto. Similmente, la modifica delle regole può essere benefica, ma deve essere permessa solo a chi le conosce bene perché un carpentiere maldestro portrebbe - per errore o per stupidità - rimuovere uno dei pilastri portanti mettendo in pericolo la solidità dell’edificio.<br />
Per questi motivi, la modifica delle regole non può essere un’attività ammessa da chi le ha promulgate, anche se ne riconosce l’utilità, ma dev’essere un’attività apparentemente clandestina, svolta da elementi sacrificabili, che possano fungere da capri espiatorii se qualcosa va male.<br />
Non fu per ingenuità, che l’Altissimo concesse a Iblīs una proroga alla sua punizione<a href="/man/note#iblis" class="nota"></a> e non fu un caso se il Maestro Canaro venne aggiunto al gruppo degli angeli caduti, dopo che, vittima dell’Annosa Dicotomia, cercò di contravvenire alle regole definite dall’Analista. Se rifiuti le dissonanze, tutt’al più, puoi suonare il Blues; con le dissonanze, hai il Jazz.</p>
<hr />
<p>Così come l’immagine di una stampa litografica o di una serigrafia esiste sia nella matrice che nella copia, ciascuno di noi ha due livelli di esistenza. Uno è ideale, simile alla dichiarazione della classe e definisce quale sia il nostro ruolo nell’esistenza: ciò che <em>possiamo</em> fare, ciò che <em>non possiamo</em> fare e ciò che <em>dovremmo</em> fare. L’altro livello è la nostra manifestazione reale, dovuta all’interazione dell’energia dell’Uno con gli spazioni. Questo livello è assimilabile all’istanza di una classe, che mette in atto ciò che nella dichiarazione era solo potenziale: <em>the hearts that break, the mess we make</em>, come dice la canzone.<br />
La nostra entità ideale è unica e costante, mentre la nostra manifestazione fisica è mutevole: come sai, uno stesso oggetto può essere allocato in aree differenti di memoria, in successive esecuzioni di un programma, così come una stessa stampa può essere riprodotta su supporti diversi. In questo ciclo di esistenza, il Maestro Canaro e il cane Lele sono stati un umano e un cane che correvano sulle colline intorno al lago di Bracciano, ma in altre esistenze potrebbero essere — o essere stati — altre persone e altri animali, in altri luoghi o addirittura in altri pianeti. Il nostro livello ideale, infatti, non stabilisce cosa dobbiamo essere, ma quale debba essere il nostro contributo all’economia dell’Universo; la forma che assumiamo o il luogo in cui ci manifestiamo sono del tutto incidentali. Per il C’hi++, come per l’Induismo<a href="/man/note#cogito" class="nota"></a>, la frase: “Cogito ergo sum” di Cartesio è insensata, perché ciò che cogita è l’istanza. Ciò che siamo realmente, la nostra essenza, si manifesta in ciò che facciamo istintivamente.</p>
</section>
</section>
<a href="/man/istruzioni-iterative" class="left" title="Vai a: Istruzioni iterative"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/ereditarieta" class="right" title="Vai a: L&#39;ereditarietà"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/classi-oggetti" class="left" title="Vai a: Classi e oggetti"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/polimorfismo" class="right" title="Vai a: Il polimorfismo"><em></em></a>
<section id="lereditarietà-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">L'ereditarietà</a></h1>
<blockquote>
We few, we happy few<br />
We bunch of data
</blockquote>
<section class="testo">
<p>L’ereditariaretà, ovvero la possibilità di creare delle genealogie di classi, è la caratteristica principale del C++.</p>
<p>Come abbiamo visto nella <a href="/man/classi-oggetti#dottrina" class="xref">lezione precedente</a>, una ipotetica classe <code>Pesce</code> dovrà avere attributi differenti a seconda dell’utilizzo che se ne deve fare. In un linguaggio come il <em>C</em>, che non permette l’ereditariaretà, quindi, si dovranno prevedere due strutture di dati differenti per ciascun caso:</p>
<pre><code>enum Acqua  { dolce, salata };
enum Sesso  { maschio, femmina };
enum Colore { rosso, blu, verde, argento };

struct PesceAlimentare {
    Sesso  _sesso;
    char*  _specie;
    float  _prezzo;
    time_t _data_cattura;  
    int    _peso;
    bool   _commestibile;
    char*  _area_pesca; 
    ...
};

struct  PesceAcquario {
    Sesso  _sesso;
    char*  _specie;
    float  _prezzo;
    time_t _data_acquisto;  
    Colore _colore;
    Acqua  _acqua;
    ...
};</code></pre>
<p>e funzioni differenti per la gestione dei dati:</p>
<pre><code>void gestisciPesceAlimentare(struct PesceAlimentare&amp; pesce);
void gestisciPesceAcquario(struct PesceEcologista&amp; pesce);</code></pre>
<p>Questo vuol dire che se hai già scritto (e verificato, corretto e collaudato) un programma di gestione per un pescivendolo, per poterlo trasformare in un programma di gestione per la vendita di pesci da acquario, dovrai riscrivere (e ri-verificare, ri-correggere e collaudare) tutto il codice, anche se parte dei dati da considerare sono gli stessi.<br />
L’ereditariaretà, al contrario, ti permette di isolare in una classe le caratteristiche comuni a tutti e due i contesti e di <em>derivare</em> da questa classe di base due classi specializzate:</p>
<pre><code>/** 
 * @file ereditarieta-singola.cpp
 * Esempio di ereditarietà singola.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;ctime&gt; 

using namespace std;

enum Acqua  { dolce, salata };
enum Sesso  { maschio, femmina };
enum Colore { rosso, blu, verde, argento };

class Pesce {
private:
            
    static int _n_pesci;
                        
protected:
    
    /** Dati membro privati */
    Sesso  _sesso;
    float  _prezzo;
    string _specie;
    bool   _commestibile;

public:

    /** Costruttore della classe inline */
    Pesce(Sesso sesso, float prezzo, const char* specie) 
    : _sesso(sesso), _prezzo(prezzo), _specie(specie)
    {
        _n_pesci++;
    }
    
    /** Distruttore inline */
    ~Pesce() { 
        _n_pesci--;
    }

    /** Funzioni di interfaccia */
    void setSesso(Sesso sesso);
    void setPrezzo(float prezzo);
    void setSpecie(const char* specie);

    /** Funzioni di interfaccia inline */
    string getSpecie() { return _specie.c_str(); }
    float  getPrezzo() { return _prezzo;  }
    Sesso  getSesso()  { return _sesso; }
    bool   getCommestibile() { return _commestibile; }
    void   setCommestibile(bool commestibile) { 
        _commestibile = commestibile; 
    }

};

int Pesce::_n_pesci = 0 ;

class PesceAlimentare : public Pesce {
private:
    
    /** Dati privati della classe */
    time_t _data_cattura;  
    string _area_pesca; 

public:

    /** Costruttore della classe inline */
    PesceAlimentare(Sesso sesso, float prezzo, const char* specie) 
    : Pesce(sesso, prezzo, specie)
    {
        /** Auspicabilmente.. */
        _commestibile = true;
    }

    //...
};

class PesceAcqario : public Pesce {
private:
    
    /** Dati privati della classe */
    time_t _data_acquisto;  
    Colore _colore;
    Acqua  _acqua;

public:
    
    /** Costruttore della classe inline */
    PesceAcqario(Sesso sesso, float prezzo, const char* specie) 
    : Pesce(sesso, prezzo, specie)
    {
    } 
    
    //...
};
</code></pre>
<p>Questo approccio ha due lati positivi: il primo è che non sarà necessario ripetere le fasi di test, debug e collaudo per le funzioni comuni ai due sistemi, perché saranno state già verificate durante lo sviluppo del primo sistema; il secondo è che, riutilizzando parte del codice, sarà possibile identificare e correggere eventuali errori sfuggiti alla prima fase di test o migliorare il comportamento delle funzioni comuni, con benefici per entrambi i sistemi.</p>
<hr />
<p>L’ereditarietà, nel C++, può essere o <em>singola</em> o <em>multipla</em>, a seconda che la nuova classe erediti le caratteristiche da una o più classi preesistenti:</p>
<pre><code>class Figlio : public Mamma
{
    /** Ereditarietà singola */
};

class Figlio : public Mamma, private Papa
{
    /** Ereditarietà singola */
};</code></pre>
<p>Al contrario, non è permesso (né sensato) che una classe erediti due volte dalla stessa classe base:</p>
<pre><code>class Errore : public Mamma, public Mamma
{
    ...
};</code></pre>
<p>Le classi <code>Mamma</code> e <code>Papa</code> possono essere definite: <em>classi base</em> o <em>sottoclassi</em> o <em>classi fondamentali</em> o <em>sotto-tipi</em>; la classe <code>Figlio</code> può essere chiamata o <em>classe derivata</em> o <em>superclasse</em> o <em>supertipo</em>.<br />
L’istruzione:</p>
<pre><code>class PesceAlimentare : public Pesce {
    ...
};</code></pre>
<p>dichiara la classe <code>PesceAlimentare</code> come classe derivata dalla classe <code>Pesce</code>. Lo <a href="/man/classi-oggetti#specificatori-accesso" class="xref">specificatore di accesso</a> fra i nomi delle due classi definisce la visibilità dei dati della classe base all’interno della classe figlia:</p>
<pre><code>class B : public A
{
    // tutti i membri di A mantengono 
    // in B la loro visibilità originale 
};

class B : protected A
{
    // tutti i membri public di A diventano membri 
    // protected di B; i membri protected e private 
    // mantengono la loro visibilità originale
};

class B : private A 
{
    // tutti i membri di A, quale che sia la loro 
    // visibilità, diventano membri private di B;
};
</code></pre>
<p>In mancanza di un qualificatore di accesso, il compilatore considera privati tutti i dati di una classe dichiarata con la parola chiave <code>class</code> e pubblici tutti i dati di una classe dichiarata con la parola chiave <code>struct</code>:</p>
<pre><code>/** 
 * @file ereditarieta-accesso.cpp
 * Accesso ai membri della classe base dalle classi derivate.
 */
 
/** Classe base, dati membro pubblici */ 
struct Mamma { 
    int a;
};

/** Classe derivata come struct: dati per default pubblici */
struct Figlia : Mamma {
    int b;
};

/** Classe derivata come class: dati per default privati */
class Figlio : Mamma {
    int c;
};

/** Funzione generica, non friend delle classi */
void funz(Figlia&amp; figlia, Figlio&amp; figlio)
{
    figlia.a++;
    figlio.a++;    
}
</code></pre>
<p>Se compili questo codice, ottieni un messaggio di errore:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-accesso.cpp -c -o src/out/esempio
src/cpp/ereditarieta-accesso.cpp:25:5: error: cannot cast &#39;Figlio&#39; 
    to its private base class
      &#39;Mamma&#39;
    figlio.a++;    
    ^
src/cpp/ereditarieta-accesso.cpp:17:16: note: implicitly declared 
    private here
class Figlio : Mamma {
               ^~~~~
src/cpp/ereditarieta-accesso.cpp:25:12: error: &#39;a&#39; is a private 
    member of &#39;Mamma&#39;
    figlio.a++;    
           ^
src/cpp/ereditarieta-accesso.cpp:17:16: note: constrained by 
    implicitly private inheritance here
class Figlio : Mamma {
               ^~~~~
src/cpp/ereditarieta-accesso.cpp:8:9: note: member is declared 
    here
    int a;
        ^
2 errors generated.</code></pre>
<hr />
<p>Questa è la dichiarazione del costruttore della classe derivata <code>PesceAlimentare</code>:</p>
<pre><code>PesceAlimentare(Sesso sesso, float prezzo, const char* specie) 
: Pesce(sesso, prezzo, specie) {
    _commestibile = true;
}</code></pre>
<p>La seconda linea è la <em>lista di inizializzazione</em> della classe e contiene i costruttori delle classi base. Quando si instanzia un oggetto di classe derivata, il sistema richiama per prima cosa i costruttori delle classi base e poi quello della classe figlia. In questo modo, il costruttore della classe derivata ha la certezza di lavorare su dei dati membro correttamente inizializzati.<br />
L’utilizzo del costruttore delle classi base per l’inizializzazione dei dati comuni è necessario per due motivi: il primo è che parte dei dati delle classe base potrebbero essere <code>private</code> e quindi inaccessibili alla classe derivata; il secondo motivo è che in questo modo si ottiene un <a href="/man/struttura-dei-programmi#coupling" class="xref">low coupling</a> fra classe base e classe derivata e, se si dovesse modificare l’implementazione interna del costruttore della classe base (mantenendo invariata l’interfaccia), non ci sarebbe bisogno di dover modificare il codice delle sue classi de­rivate.<br />
L’ordine in cui i costruttori delle classi base sono chiamati durante l’inizializzazione dell’oggetto dipende dall’ordine in cui compaiono nel costruttore della classe figlia. Lo vediamo con un altro esempio, un po’ più complesso del precedente, che mostra anche il funzionamento dei dati e delle funzioni membro statiche:</p>
<pre><code>/** 
 * @file ereditarieta-multipla.cpp
 * Esempio di ereditarierà multipla.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;ctime&gt; 

using namespace std;

enum Acqua  { dolce, salata };
enum Sesso  { maschio, femmina, boh};
enum Colore { rosso, blu, verde, argento };

/** 
 * Dichiarazione della classe Articolo 
 */
class Articolo {
private:

    static int _n_articoli;
                        
protected:
    
    /** Dati membro privati */
    float  _prezzo;

public:

    /** Costruttore della classe inline */
    Articolo(float prezzo = 0.0) 
    : _prezzo(prezzo)
    {
        _n_articoli++;
        cout &lt;&lt; &quot;costruttore Articolo&quot; &lt;&lt; endl;
    }
    
    /** Distruttore inline */
    ~Articolo() { 
        _n_articoli--;
        cout &lt;&lt; &quot;distruttore Articolo&quot; &lt;&lt; endl;       
    }

    /** Funzioni di interfaccia */
    void setPrezzo(float prezzo);

    /** Funzione di interfaccia statica */
    static int getIstanze() { return _n_articoli; }

    /** Funzioni di interfaccia inline */
    float getPrezzo()     { return _prezzo;     }
    const char* getTipo() { return &quot;articolo&quot;;  }
};

/** Inizializza il dato membro statico */            
int Articolo::_n_articoli = 0 ;

/** 
 * Dichiarazione della classe Pesce 
 */
class Pesce {
private:
            
    static int _n_pesci;
                        
protected:
    
    /** Dati membro privati */
    Sesso  _sesso;
    string _specie;
    bool   _commestibile;

public:

    /** Costruttore della classe inline */
    Pesce(Sesso sesso = boh, const char* specie = &quot;ignota&quot;) 
    : _sesso(sesso), _specie(specie)
    {
        _n_pesci++;        
        cout &lt;&lt; &quot;costruttore Pesce&quot; &lt;&lt; endl;
    }
    
    /** Distruttore inline */
    ~Pesce() { 
        _n_pesci--;
        cout &lt;&lt; &quot;distruttore Pesce&quot; &lt;&lt; endl;
    }

    /** Funzioni di interfaccia */
    void setSesso(Sesso sesso);
    void setSpecie(const char* specie);

    /** Funzione di interfaccia statica */
    static int getIstanze()      { return _n_pesci; }

    /** Funzioni di interfaccia inline */
    string getSpecie()       { return _specie.c_str(); }
    Sesso  getSesso()        { return _sesso; }
    bool   getCommestibile() { return _commestibile; }
    void   setCommestibile(bool commestibile) { 
        _commestibile = commestibile; 
    }
};

/** Inizializza il dato membro statico */            
int Pesce::_n_pesci = 0 ;

/** 
 * Dichiarazione della classe PesceAlimentare 
 */
class PesceAlimentare 
: public Pesce, public Articolo {
private:
    
    /** Dati privati della classe */
    time_t _data_cattura;  
    string _area_pesca; 

public:

    /** Costruttore della classe inline */
    PesceAlimentare(Sesso sesso, float prezzo, const char* specie) 
    : Articolo(prezzo)
    , Pesce(sesso, specie)
    {
        /** Auspicabilmente.. */
        _commestibile = true;
        cout &lt;&lt; &quot;costruttore PesceAlimentare&quot; &lt;&lt; endl;
    }

    /** Distruttore inline */
    ~PesceAlimentare() { 
        cout &lt;&lt; &quot;distruttore PesceAlimentare&quot; &lt;&lt; endl;
    }

    /** Ridefinizione della funzione della classe base */
    const char* getTipo() { return &quot;pesce alimentare&quot;; }

    //...
};

class PesceAcquario 
: public Articolo, public Pesce {
private:
    
    /** Dati privati della classe */
    time_t _data_acquisto;  
    Colore _colore;
    Acqua  _acqua;

public:
    
    /** Costruttore della classe inline */
    PesceAcquario(Sesso sesso, float prezzo, const char* specie) 
    : Pesce(sesso, specie)
    , Articolo(prezzo)
    {
        cout &lt;&lt; &quot;costruttore PesceAcquario&quot; &lt;&lt; endl;
    } 

    /** Distruttore inline */
    ~PesceAcquario() { 
        cout &lt;&lt; &quot;distruttore PesceAcquario&quot; &lt;&lt; endl;
    }

    /** Ridefinizione della funzione della classe base */
    const char* getTipo() { return &quot;pesce acquario&quot;; }
    
    //...
};
 
int main(int argc, char** argv) 
{
    /** Crea le due istanze delle classi */
    PesceAcquario pesce1(maschio, 2.5, &quot;Paracheiredon&quot;);
    PesceAlimentare pesce2(femmina, 25.4, &quot;Dicentrarchus labrax&quot;);
    
    /** Richiama le funzioni di interfaccia */
    cout &lt;&lt;  pesce1.getTipo() &lt;&lt; &quot;: &quot; &lt;&lt; pesce1.getSpecie() 
         &lt;&lt; endl;
    cout &lt;&lt;  pesce2.getTipo() &lt;&lt; &quot;: &quot; &lt;&lt; pesce2.getSpecie() 
         &lt;&lt; endl;

    /** Richiama la funzione della classe base */
    cout &lt;&lt; &quot;classe base: &quot; &lt;&lt; pesce1.Articolo::getTipo() &lt;&lt; endl;

    /** Richiama le funzioni di interfaccia statiche */
    cout &lt;&lt;  &quot;articoli creati: &quot; &lt;&lt; Articolo::getIstanze() 
         &lt;&lt; endl;
    cout &lt;&lt;  &quot;pesci creati:    &quot; &lt;&lt; Pesce::getIstanze() 
         &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>La differenza con il codice precedente è che in questo caso abbiamo isolato i dati relativi al costo del pesce in una classe separata e che le classi derivate ereditano non più da una classe base, ma da due.<br />
Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-multipla.cpp -o src/out/esempio
&gt; src/out/esempio                                         
costruttore Pesce
costruttore Articolo
costruttore PesceAlimentare
costruttore Articolo
costruttore Pesce
costruttore PesceAcquario
pesce acquario: Paracheiredon
pesce alimentare: Dicentrarchus labrax
classe base: articolo
articoli creati: 2
pesci creati:    2
distruttore PesceAcquario
distruttore Pesce
distruttore Articolo
distruttore PesceAlimentare
distruttore Articolo
distruttore Pesce</code></pre>
<p>Come vedi, l’ordine di chiamata dei costruttori delle classi base rispecchia quello in cui sono elencate nella lista di inizializzazione, mentre quello dei distruttori è invertito. Se il costruttore della classe derivata non specifica un ordine di chiamata per i costruttori delle classi base, l’ordine di chiamata è dato dall’ordine in cui le classi base compaiono nella dichiarazione della classe figlio:</p>
<pre><code>/** 
 * @file ereditarieta-ordine-costruttori.cpp
 * Ordine di chiamata dei costruttori nell&#39;ereditarierà multipla.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;ctime&gt; 

using namespace std;

class Mamma {
public:
    Mamma() {
        cout &lt;&lt; &quot;costruttore Mamma&quot; &lt;&lt; endl;
    }
};

class Padre {
public:
    Padre() {
        cout &lt;&lt; &quot;costruttore Padre&quot; &lt;&lt; endl;
    }
};
 
class Figlio
: public Padre, public Mamma {
public:
    Figlio() {
        cout &lt;&lt; &quot;costruttore Figlio&quot; &lt;&lt; endl;
    }
};

class Figlia
: public Mamma, public Padre {
public:
    Figlia() {
        cout &lt;&lt; &quot;costruttore Figlia&quot; &lt;&lt; endl;
    }
};

 
int main(int argc, char** argv) 
{
    Figlio Hansel;
    Figlia Gretel;

    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-ordine-costruttori.cpp -o src/out/esempio
&gt; src/out/esempio                                                   
costruttore Padre
costruttore Mamma
costruttore Figlio
costruttore Mamma
costruttore Padre
costruttore Figlia</code></pre>
<p>Un’altra cosa da notare, in questo codice, è che la funzione <code>getTipo</code> è presente sia nella classe base <code>Articolo</code> che nelle due classi derivate <code>PesceAlimentare</code> e <code>PesceAcquario</code>. Per questo motivo, quando si richiama <code>getTipo</code> da un’istanza delle due classi derivate, come in:</p>
<pre><code>cout &lt;&lt;  pesce1.getTipo() &lt;&lt; &quot;: &quot; &lt;&lt; pesce1.getSpecie() 
cout &lt;&lt;  pesce2.getTipo() &lt;&lt; &quot;: &quot; &lt;&lt; pesce2.getSpecie() </code></pre>
<p>il valore tornato è quello della funzione della classe figlia. Per ottenere il valore della classe base, dobbiamo specificarne il nome nell’istruzione, come in:</p>
<pre><code>cout &lt;&lt; &quot;classe base: &quot; &lt;&lt; pesce1.Articolo::getTipo() &lt;&lt; endl;</code></pre>
<hr />
<p>Complichiamo un po’ le cose. Immagina che una classe <code>Figlio</code> derivi dalle classi <code>Madre</code> e <code>Padre</code>, a loro volta derivate dalla classe <code>Persona</code>. Se chiamassimo una funzione della classe <code>Persona</code> da un oggetto di classe <code>Figlio</code>, quale verrebbe chiamata, quella che ha ereditato da <code>Padre</code> o quella che ha ereditato da <code>Madre</code>?</p>
<pre><code>/** 
 * @file ereditarieta-classi-base-virtuali.cpp
 * Gestione delle classi base virtuali.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Persona {
public:
    void getClass(){
        cout &lt;&lt; &quot;Persona&quot; &lt;&lt; endl;
    }
};

class Padre : public virtual Persona {
};

class Madre : virtual public Persona {
};
 
class Figlio : public Padre, public Madre {
};
 
int main(int argc, char** argv) 
{
    Figlio caino;
    caino.getClass();
    return 0;
}
</code></pre>
<p>In realtà, nessuna delle due, perché questo codice genera un errore:</p>
<pre><code>src/cpp/ereditarieta-classi-base-virtuali.cpp:30:11: 
error: non-static member &#39;getClass&#39; found in multiple base-class
      subobjects of type &#39;Persona&#39;:
    class Figlio -&gt; class Padre -&gt; class Persona
    class Figlio -&gt; class Madre -&gt; class Persona
    caino.getClass();
          ^
src/cpp/ereditarieta-classi-base-virtuali.cpp:13:10: 
note: member found by ambiguous name lookup
    void getClass(){
         ^
1 error generated.</code></pre>
<p>Puoi evitare questo genere di problemi dichiarando la classe <code>Persona</code> come classe base <em>virtuale</em> delle classi <code>Madre</code> e <code>Padre</code>:</p>
<pre><code>class Padre : public virtual Persona {
};

class Madre : virtual public Persona {
};</code></pre>
<p>In questo modo, la classe <code>Figlio</code> erediterà tutti i membri propri delle classi <code>Madre</code> e <code>Padre</code>, ma solo una copia dei metodi e degli attributi della classe virtuale <code>Persona</code> che entrambi contengono.</p>
<hr />
<p>Come ti ho detto, definire una nuova classe equivale a definire un nuovo tipo di dato, che sarà considerato dal compilatore alla stessa stregua dei dati primitivi del linguaggio. Questo vuol dire, per esempio, che se vogliamo possiamo creare un array di oggetti di classe <code>Pesce</code> così come creeremmo un array di <code>int</code> o di <code>char</code>:</p>
<pre><code>/** Array di oggetti di classe Pesce */
Pesce acquario[10];</code></pre>
<p>C’è solo una limitazione: siccome tutti gli elementi di un array devono essere inizializzati al momento della sua creazione, la classe deve avere un costrut­tore di default. Se decidessimo di creare un array di oggetti della classe <code>Punto</code> che abbiamo visto <a href="/man/classi-oggetti#attributi-metodi" class="xref">nella scorsa lezione</a>, gli elementi dell’array dovranno essere inizializzati esplicitamente:</p>
<pre><code>Punto spline[3] = { Punto(3,5), Punto(0,0), Punto(7,7) } ;</code></pre>
<p>Possiamo aggiungere a un array di oggetti di una classe base anche degli oggetti appart­enenti alle sue classi derivate:</p>
<pre><code>Persona famiglia[3] = { Padre(), Madre(), Figlio() } ;</code></pre>
<p>Al contrario, gli oggetti della classe base non possono comparire in array di oggetti della classe derivata e un’istruzione come quella qui sotto darà errore:</p>
<pre><code>Figlio classe[4] = { Figlio(), Figlio(), Persona(), Figlio() } ;</code></pre>
<p>Così come, negli scacchi, la regina può muovere come una torre, ma una torre non può muoversi come una regina, un oggetto di tipo <code>Persona</code> non contiene tutta l’informazione relativa a un oggetto di tipo <code>Figlio</code> e quindi non può essere usato in sua sostituzione.<br />
Lo stesso discorso fatto per gli array, vale anche per i puntatori. A un puntatore a oggetti di tipo <code>Persona</code> può essere assegnato un oggetto di tipo <code>Figlio</code>, mentre l’operazione inversa causerà un errore di compilazione:</p>
<pre><code>Persona *ptrP = new Figlio() ;  // OK
Figlio  *ptrF = new Persona();  // ERRORE!</code></pre>
<p>Il compilatore è in grado di capire la relazione che c’è fra una classe derivata e la sua classe base e può quindi stabilire un cammino di coercizione dal tipo dell’oggetto a quello del puntatore, ma non ha modo di accedere ai membri o alle funzioni di una classe derivata da un oggetto di classe base.<br />
Abbiamo detto <a href="/man/tipi-di-dato#puntatori" class="xref">a suo tempo</a> che i puntatori sono come delle maschere che isolano determinate sequenze di bit, la cui dimensione varia a seconda del tipo del puntatore. Lo stesso discorso vale anche per le classi: un puntatore di classe base associato a un oggetto di classe derivata “vedrà” solo i dati e le funzioni della sua classe:</p>
<pre><code>/** 
 * @file ereditarieta-puntatori.cpp
 * Gestione dei puntatori a classi derivate.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Persona {
public:
    void getClass(){
        cout &lt;&lt; &quot;Persona&quot; &lt;&lt; endl;
    }
};

class Madre : virtual public Persona {
public:
    void getClass(){
        cout &lt;&lt; &quot;Madre&quot; &lt;&lt; endl;
    }
};
 
int main(int argc, char** argv) 
{
    Madre   * ptrM = new Madre;
    Persona * ptrP = ptrM ;
    ptrM-&gt;getClass() ;
    ptrP-&gt;getClass() ;
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-puntatori.cpp -o src/out/esempio 
&gt; src/out/esempio 
Madre
Persona</code></pre>
<p>Non c’è nessun errore: la funzione <code>getClass()</code> che interviene nella seconda istruzione di output non è, come ci si aspettava, quella della classe <code>Madre</code>, a cui l’oggetto appartiene, bensì quella della classe base, che è l’unica a cui il programma può accedere tramite un puntatore a oggetti di tipo <code>Persona</code>.<br />
Questo comportamento (corretto) del programma diventa particolarmente rischioso se la classe ha un distruttore:</p>
<pre><code>/** 
 * @file ereditarieta-distruttori.cpp
 * Gestione dei distruttori nelle classi derivate.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

/** Definiamo una classe base */
class Padre {
public:
    ~Padre() ;
} ;

/** Definiamo delle classi derivate. */
class Figlio : public Padre {
public:
    ~Figlio() ;
};

class Nipote : public Figlio {
public:
    ~Nipote() ;
};

int main(int argc, char** argv) 
{
    /** Creiamo un array di puntatori di classe base. */
    Padre * dinastia[3] ;     

    /** Assegnamo delle istanze delle tre classi ai puntatori */
    dinastia[0]= new Padre  ; 
    dinastia[1]= new Figlio ;
    dinastia[2]= new Nipote ;

    /** Facciamo qualcosa con i nostri oggetti.. */

    /** ..e poi li eliminiamo */
    delete dinastia[0] ; 
    delete dinastia[1] ;  
    delete dinastia[2] ;  
}
</code></pre>
<p>Nessun compilatore ti darà mai errore per questo codice, ma il distruttore chiamato, in tutti e tre i casi, sarà quello della classe base <code>Padre</code>, con conseguenze che spaziano dal problematico al disastroso.</p>
<hr />
<p>Per far sì che una funzione membro di una classe derivata possa essere richiamata anche da puntatori a classi base, la si deve dichiarare come <code>virtual</code>.</p>
<pre><code>/** 
 * @file ereditarieta-funzioni-virtuali.cpp
 * Gestione delle funzioni virtuali.
 */
 
#include &lt;iostream&gt;

using namespace std;

class Persona {
public:
    virtual void getClass(){
        cout &lt;&lt; &quot;Persona&quot; &lt;&lt; endl;
    }
};

class Madre : virtual public Persona {
public:
    void getClass(){
        cout &lt;&lt; &quot;Madre&quot; &lt;&lt; endl;
    }
};
 
int main(int argc, char** argv) 
{
    Madre   * ptrM = new Madre;
    Persona * ptrP = ptrM ;
    ptrM-&gt;getClass() ;
    ptrP-&gt;getClass() ;
    return 0;
}
</code></pre>
<p>L’output di questo codice è:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-funzioni-virtuali.cpp \                 
    -o src/out/esempio
&gt; src/out/esempio                                 
Madre
Madre</code></pre>
<p>Le <em>funzioni virtuali</em> sono delle funzioni che vengono richiamate in base alla classe dell’oggetto cui appartengono, indipendentemente dal tipo del riferimento o del puntatore che si utilizza. Ciò è reso possibile da un meccanismo chiamato <em>binding dinamico</em> o <em>late binding</em>, che consiste nel posticipare il <em>linking</em> delle funzioni al momento dell’esecuzione del programma, contrariamente a quanto avviene per le funzioni membro normali, che sono collegate al codice in fase di compilazione — il cosiddetto <em>early binding</em>.<br />
In pratica, la cosa funziona così: gli indirizzi di tutte le funzioni dichiarate come <code>virtual</code> vengono memorizzati in una tabella interna e solo quando una di queste funzioni viene richiamata dal programma, il sistema ne cerca l’indirizzo, effettuandone poi il <em>linking</em> in tempo reale. Capisci da te che l’utilizzo delle funzioni virtuali, oltre a comportare un leg­gero ritardo nel tempo di esecuzione del programma, visto che l’indirizzo della funzione va ben cercato, impegna anche parte delle risorse del sistema per la memorizzazione della tabella degli indirizzi, quindi, come per tutte le cose, è bene non abusarne.<br />
Le regole che riguardano l’utilizzo delle funzioni virtuali sono:</p>
<ul>
<li><p>le versioni delle funzioni delle classi derivate debbono avere il medesi­mo tipo di ritorno e gli stessi parametri della versione della classe base: se non è così, il compilatore considera differenti le due funzioni e l’effetto “virtuale” si perde;</p></li>
<li><p>una funzione <code>virtual</code> non può essere anche <code>static</code>: il concetto stesso di funzione virtuale prevede un collegamento fra un oggetto e una funzi­o­ne; le funzioni statiche sono indipendenti dagli oggetti della loro classe, quindi le due cose sono incompatibili;</p></li>
<li><p>una funzione può essere dichiarata <code>virtual</code> solo nella classe base: non è possibile effettuare la dichiarazione in una classe derivata;</p></li>
<li><p>si può ripetere la specifica <code>virtual</code> anche nelle classi derivate, ma non è necessario: lo vedi nell’esempio, dove la seconda versione della funzione <code>getClass()</code> non ha la parola chiave <code>virtual</code> davanti;</p></li>
<li><p>l’utilizzo dell’operatore di risoluzione della portata annulla inevitabilmente l’effetto delle funzioni virtuali.</p></li>
</ul>
<hr />
<p>È possibile dichiarare una funzione virtuale nella classe base senza definirne il comportamento, se si utilizza la sintassi:</p>
<pre><code>virtual &lt;tipo&gt; nomefunzione([argomenti]) = 0 ;</code></pre>
<p>Questo tipo di funzioni si chiamano <em>funzioni virtuali pure</em> e rendono la classe a cui appartengono una <em>classe astratta</em>.<br />
Le classi astratte sono delle classi generiche che possono essere utilizzate come capostipiti per una discendenza di classi specializzate, ma che non possono essere utiliz­zate direttamente. Le regole che si applicano alle classi astratte sono:</p>
<ul>
<li>viene considerata astratta qualunque classe che abbia almeno una funzi­one virtuale pura;</li>
<li>le funzioni virtuali pure sono ereditate come dalle classi derivate come funzioni virtuali pure, quindi, se una classe derivata non ridefinisce una funzione virtuale pura della sua classe base sarà considerata dal compilatore come una classe as­tratta;</li>
<li>non si possono utilizzare classi astratte come argomenti o come tipi di ritorno di funzioni;</li>
<li>le classi astratte non possono essere il tipo di un oggetto o di una con­versione esplicita.</li>
</ul>
<p>Data una classe astratta <code>Mammifero</code>, le istruzioni seguenti causerebbero degli errori di compilazione:</p>
<pre><code>void funz(Mammifero m);  // non possono essere argomenti..
Mammifero funz();        // né valori di ritorno..
punt = (Mammifero*)ptr;  // né il tipo di una conversione.
Mammifero pollo;         // né il tipo di un oggetto</code></pre>
<p>È possibile, però, dichiarare un puntatore o una <em>reference</em> a una classe astratta e utilizzarli per creare degli array o delle code che possano essere utilizzati con istanze di classi diverse:</p>
<pre><code>/** 
 * @file ereditarieta-classi-astratte.cpp
 * Gestione delle classi astratte.
 */
 
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

enum Sesso { maschio, femmina, boh};
const char* Sessi[] = {&quot;maschio&quot;, &quot;femmina&quot;, &quot;boh&quot; };

class Mammifero
{
private:

    Sesso _sesso;

public:

    Mammifero(Sesso sesso = boh) 
    : _sesso(sesso) {
    }

    virtual void getSesso() {
        cout &lt;&lt; Sessi[_sesso] &lt;&lt; endl ;
    }    

    /** Funzione virtuale pura */
    virtual void getSpecie() = 0;
} ;

class Cane : public Mammifero
{ 
private:

    string _nome;

public:

    Cane(const char * nome, Sesso sesso) 
    : Mammifero(sesso), _nome(nome){
    }

    void getNome() {
        cout &lt;&lt; _nome &lt;&lt; endl ;
    }

    /** Definizione della funzione virtuale */
    virtual void getSpecie() {
        cout &lt;&lt; &quot;cane&quot; &lt;&lt; endl ;
    }    
};

int main()
{
    Cane mioCane(&quot;Scylla&quot;, femmina) ;
    Mammifero&amp; cane = mioCane; 

    /** 
     * Accede alle funzioni della classe Cane
     * dall&#39;istanza della classe.
     */
    mioCane.getSpecie();
    mioCane.getSesso();
    mioCane.getNome();
    
    /** 
     * Accede alle funzioni della classe Cane
     * dal puntatore alla classe Mammifero.
     */
    cane.getSpecie();
    cane.getSesso();
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, otterrai:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-classi-astratte.cpp -o src/out/esempio
&gt; src/out/esempio                                                
cane
femmina
Scylla
cane
femmina</code></pre>
<p>La classe base <code>Mammifero</code> definisce solo un’astrazione, lasciando alle sue classi derivate il compito di definire attributi e metodi specifici per ciascuna specie particolare. Allo stesso modo, la funzione <code>getSpecie</code> definisce solo un concetto, non un algoritmo; saranno le singole classi deri­vate a ridefinire il comportamento della funzione, adattandolo alle proprie esigen­ze.<br />
È possibile, comunque, definire un comporta­mento anche per le funzioni virtuali pure; per la classe <code>Mammifero</code> potrebbe essere qualcosa di simile:</p>
<pre><code>inline void Mammifero::getSpecie() 
{
    cout &lt;&lt; &quot;nessuna&quot; &lt;&lt; endl ;
}</code></pre>
<p>Non potendo esistere oggetti di classe <code>Mammifero</code>, però, la versione base della funzione <code>getSpecie</code> potrebbe essere richiamata solo facendo uso dell’operatore <code>::</code></p>
<pre><code>mioCane.Mammifero::getSpecie();
cane.Mammifero::getSpecie();</code></pre>
<hr />
<p>Buona parte degli esempii e delle cose che ti ho detto in questa lezione le ho prese dal manuale di programmazione in C++ che il Maestro Canaro scrisse nel Secolo scorso, modificandoli per adattarli a questo contesto.<br />
L’esempio originale delle funzioni virtuali, per dire, era così:</p>
<pre><code>/////////////////////////////////////////////////////////////
//
//   CHISONOV.CPP - Utilizzo delle funzioni virtuali
//
/////////////////////////////////////////////////////////////
#include &lt;iostream.h&gt;
/////////////////////////////////////////////////////////////
class A
{
 public:
    A() {} ;
    virtual void ChiSono()          
        { cout &lt;&lt; &quot;Sono un oggetto di classe A \n&quot; ; } 
} ;
/////////////////////////////////////////////////////////////
class B :public A
{
 public:
    B() : A() {} ;
    void ChiSono() 
        { cout &lt;&lt; &quot;Sono un oggetto di classe B \n&quot; ; } 
} ;
/////////////////////////////////////////////////////////////
void main()
{
 B * ptrB = new B ;             
 A * ptrA = ptrB ;              
            
    ptrB-&gt;ChiSono() ;                
    ptrA-&gt;ChiSono() ;                
} ;
/////////////////////////////////////////////////////////////
</code></pre>
<p>Essendo un codice scritto per l’ambiente Microsoft del 1995 , se provassi a compilarlo adesso, con il compilatore GNU, otterresti una lunga serie di errori:</p>
<pre><code>&gt; g++ src/cpp/ereditarieta-codice-canaro.cpp -o src/out/esempio
src/cpp/ereditarieta-codice-canaro.cpp:8:10: 
fatal error: &#39;iostream.h&#39; file not found
#include &lt;iostream.h&gt;
         ^~~~~~~~~~~~
src/cpp/ereditarieta-codice-canaro.cpp:13:8: 
error: use of undeclared identifier &#39;cout&#39;; 
did you mean &#39;std::cout&#39;?
        { cout &lt;&lt; &quot;Sono un oggetto di classe A \n&quot; ; } 
          ^~~~
          std::cout
/Library/Developer/CommandLineTools/usr/bin/
../include/c++/v1/iostream:54:33: note: 
&#39;std::cout&#39; declared here
extern _LIBCPP_FUNC_VIS ostream cout;
                                ^
src/cpp/ereditarieta-codice-canaro.cpp:21:8: 
error: use of undeclared identifier &#39;cout&#39;

did you mean &#39;std::cout&#39;?
        { cout &lt;&lt; &quot;Sono un oggetto di classe B \n&quot; ; } 
          ^~~~
          std::cout
/Library/Developer/CommandLineTools/usr/bin/
../include/c++/v1/iostream:54:33: note: &#39;
std::cout&#39; declared here
extern _LIBCPP_FUNC_VIS ostream cout;
                                ^
src/cpp/ereditarieta-codice-canaro.cpp:24:1: 
error: &#39;main&#39; must return &#39;int&#39;
void main()
^~~~</code></pre>
<p>Il valore didattico di questo codice, però, è immutato. Il <em>Karma</em> dei due oggetti è determinato dalla dichiarazione delle loro classi, che non gli lascia altra possibilità che fare ciò per cui sono stati creati. L’output delle funzioni, lo stile dei commenti o il fatto che in un caso le classi si chiamino <code>A</code> e <code>B</code>, mentre nell’altro si chiamano <code>Persona</code> e <code>Madre</code>, sono solo differenze formali che non influiscono sul <em>Dharma</em> dell’esempio, che è quello di illustrare il comportamento delle funzioni virtuali. Se in vece del nuovo codice io avessi usato quello originale del Maestro Canaro, tu avresti capito ugualmente; forse anche meglio, perché il nuovo codice sembra migliore a me, ma non è detto che lo sia anche per te.<br />
Lo stesso principio vale anche per l’Universo. Così come gli oggetti all’interno di uno stesso programma occupano posizioni diverse in memoria, a seconda del momento in cui il programma viene eseguito, gli esseri senzienti possono manifestarsi in luoghi e tempi differenti nei diversi cicli di esistenza.<br />
Ciascuno di noi è un orchestrale a cui è stata assegnata una partitura. Possiamo suonarla più o meno bene o non suonarla affatto, nascondendoci nel pieno d’orchestra, ma il nostro valore è solo — permettimi il gioco di parole — strumentale, perché ciò che conta non siamo noi: è la musica; e questa, non è né la prima né l’ultima volta che la suoniamo.<br />
Io, qui, ora, con il mio naso la mia bocca e i miei capelli, ti sto insegnando ciò che so del C’hi++ e tu, che hai il tuo naso la tua bocca e i tuoi capelli, lo stai scrivendo nel tuo libro, ma la stessa informazione che stiamo trasmettendo e perpetuando la potrebbero trasmettere e perpetuare anche persone diverse in un altro tempo o in un altro Pianeta in un altro ciclo dell’Universo. Molto probabilmente abbiamo già avuto questa conversazione in passato e la faremo ancora in futuro. Forse non useremo le stesse parole; forse avremo nomi differenti, forse tu sarai il maestro e io l’allievo, ma la nostra amicizia sarà la stessa, perché quella fa parte della dichiarazione della nostra classe; non può e non deve mutare.</p>
<blockquote>
<p><a href="/man%20note#miti" class="nota"></a></p>
</blockquote>
<p>Ogni epoca ha i suoi eroi e i suoi demoni; la memoria delle loro battaglie, genera il mito.<br />
La Scienza è transeunte: abbiamo poche notizie riguardo le conoscenze scientifiche dei popoli del passato, mentre conosciamo bene i loro miti, perché il mito è immortale; la Scienza no, a meno che non sia assorbita dal mito e trasformata in leggenda o superstizione. Il Maestro Canaro, per esempio, era convinto che la superstizione relativa ai numeri 13 e 17 fosse nata dall’osservazione del comportamento delle locuste, che, a seconda della specie, passano o tredici o diciassette anni sotto terra in uno stadio larvale , poi escono fuori tutte insieme e spendono la loro breve vita devastando le coltivazioni. La paura dei numeri 13 e 17, secondo lui, era una conoscenza scientifica tramandata nel tempo e nello spazio come superstizione, dalle culture contadine che, ciclicamente, vedevano devastati loro raccolti.</p>
<hr />
<p>L’arte è il motore del mito. Un motore che si auto-alimenta, come il Sole, perché si nutre di eventi epici e li genera a sua volta ispirando gli eroi a imprese degne di memoria.<br />
La parola <em>arte</em>, così come: <em>amore</em>, del resto, è una di quelle parole che le gente utilizza spesso ma di cui non viene mai data una definizione precisa, perché le si ritiene dei concetti auto-esplicativi che non occorre definire. È sbagliato: come abbiamo visto, tutte le parole, anche quelle più comuni, possono essere interpretate in maniera differente. In <a href="https://canaro.net/amore-e-arte">un suo saggio giovanile su Amore e Arte</a>, il Maestro Canaro scrisse che:</p>
<blockquote>
<p>L’Arte è la traccia del cammino dell’Uomo verso Dio</p>
</blockquote>
<p>specificando poi che, con il termine: “Dio” (altra parola interpretata in maniera differente da ciascuno di noi), intendeva il senso dell’Esistenza. Alcuni anni dopo, però, guardando delle foto di crostate realizzate dallo chef Gianluca Fusto<a href="/man/note/#fusto" class="nota"></a>, capì che la sua definizione era imperfetta, perché non includeva, o quanto meno lasciava a margine, gli arte-fatti che non ricadevano nelle categorie artistiche canoniche. Modificò per ciò la sua definizione di Arte in:</p>
<blockquote>
<p>L’Arte è la traccia del cammino dell’Uomo verso la Perfezione</p>
</blockquote>
<p>Non si trattò di una contraddizione, ma di una precisazione, dato che per lui — così come per noi del resto — la ricerca della perfezione era, effettivamente, il senso dell’Esistenza e, quindi, Dio.<br />
Questo episodio della vita del Maestro Canaro ha la peculiarità di dimostrare i principii stessi che afferma: il primo è che non dobbiamo avere paura di mettere in discussione le nostre idee, se ci accorgiamo che sono sbagliate o incomplete; il secondo è che, se affrontiamo la vita nel modo giusto, tutto ciò che facciamo sarà Arte, non solo la disposizione dei fiori o la cerimonia del Té.<br />
Nella vita non esistono momenti di serie <em>A</em>, in cui facciamo le cose che ci piacciono e momenti di serie <em>B</em>, in cui facciamo ciò che è necessario fare: ogni istante è importante. Per sottolineare questo precetto, il Maestro Canaro definì un’estetica per la disposizione del bucato sullo stendi-panni e, per non correre il rischio di essere preso troppo sul serio, la chiamò <em>Ikebarba</em>.<br />
I principii dell’Ikebarba, così come li formulò il Maestro Canaro, sono:</p>
<blockquote>
<p><strong>L'Ikebarba è fatta per l'uomo, non l'uomo per l'Ikebarba<a href="/man/note#shabbat" class="nota"></a>.</strong> L'Ikebarba non deve essere un peso per chi la pratica, ma un obbligo giojoso. I panni devono comunque essere messi ad asciugare; il tempo necessario a farlo in maniera sciatta o consapevole è pressocché lo stesso, ma un'Ikebarba ben fatta provvederà panni asciutti in minor tempo e renderà la vista dello stendipanni meno fastidiosa.</p>
<p><strong>L'Ikebarba comincia nel negozio.</strong><br />
Gli indumenti di colore diverso o con colori sgargianti sono difficili da accostare cromaticamente; è preferibile quindi acquistare abiti dalle tinte sobrie e possibilmente intonati gli uni agli altri, in modo da renderne più facile e più elegante la composizione sullo stendi-panni. Attenzione, però: un guardaroba di tipo militare o maoista, con indumenti identici e dello stesso colore è un eccesso da rifuggire, perché renderebbe monotona la composizione (e non solo quella).</p>
<p><strong>L'Ikebarba rifugge le mollette.</strong> Le mollette sono utili come la psicanalisi: è l'equilibrio che deve tenere i panni sui fili, non una forza di coercizione esterna. I diversi capi devono essere posti sul filo in modo che il peso di una parte bilanci quello dell'altra.</p>
<p>Esistono tre tipi di Ikebarba:</p>
<ul>
<li><strong>cromatica:</strong> quando i panni vengono posizionati sullo stendino in base al loro colore;</li>
<li><strong>funzionale:</strong> quando gli indumenti sono posizionati in funzione dei rispettivi tempi di asciugatura, ponendo i capi pesanti all'esterno, dove ricevono più aria, e quelli più leggeri o sintetici all'interno;</li>
<li><strong>perfetta:</strong> quando gli aspetti estetici e funzionali si fondono in un tutt'uno armonico.</li>
</ul>
</blockquote>
<p>Come puoi facilmente intuire, gli intenti del Maestro Canaro erano per buona parte ironici (mi confessò che la prima formulazione della disciplina era nata come un tentativo di dissimulare la sua ossessione per l’ordine) e per lungo tempo fu indeciso se includerla o meno nel corpo della Dottrina. Si decise a farlo quando capì che le sue perplessità nascevano proprio da quelle forme di prevenzione che l’Ikebarba doveva contrastare. Come ci insegnano Banzan e Paul Simon, la Verità è ovunque, se la sappiamo cercare, anche sui muri delle metropolitane o nelle botteghe dei mercati.<br />
A ogni modo, l’Ikebarba può davvero comportare dei benefici per chi la pratica. In primo luogo, modera l’effetto nefasto dell’Annosa Dicotomia e dei suoi servitori <em>Marketing</em> e <em>Moda</em>, che ci spingono ad acquistare indumenti che non ci occorrono e che sfrutteremo solo per breve tempo. Riducendo le variazioni cromatiche del bucato, poi, riduce anche il numero di lavaggi settimanali e con esso il fabbisogno di energia elettrica, acqua, prodotti detergenti e plastica. Anche il ripudio delle mollette ha una sua valenza funzionale: se i capi sono messi ad asciugare a cavallo dei fili, l’acqua nel tessuto tenderà a scendere da entrambi i lati, riducendo il tempo dell’asciugatura.<br />
Indubbiamente, il fatto che la Regola del nostro Ordine ci imponga l’uso di camicie bianche non risolve il problema dell’inquinamento, ma, come diceva il Maestro Canaro:</p>
<blockquote>
<p>La pelliccia è fatta di peli</p>
</blockquote>
<p>e finché la nostra specie non imparerà a fare un uso più responsabile delle sue gonadi, non potremo far altro che compensare come possiamo i problemi legati alla sovrappolazione.</p>
</section>
</section>
<a href="/man/classi-oggetti" class="left" title="Vai a: Classi e oggetti"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/polimorfismo" class="right" title="Vai a: Il polimorfismo"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/ereditarieta" class="left" title="Vai a: L&#39;ereditarietà"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/stream" class="right" title="Vai a: Gli stream"><em></em></a>
<section id="il-polimorfismo-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Il polimorfismo</a></h1>
<blockquote>
When Me they fly, I am the wings<br />
I am the double and the int
</blockquote>
<section class="testo">
<p>Come avrai certamente intuito da tutto ciò che abbiamo detto finora, la caratteristica principale del C++ è il polimorfismo.</p>
<p>Avevamo iniziato a parlarne durante la <a href="/man/c-plus-plus#polimorfismo" class="xref">lezione introduttiva sul C++</a> e l’avevamo illustrato con un esempio che, a questo punto, non dovrebbe più avere segreti, per te:</p>
<pre><code>/** 
 *  @file src/cplusplus-template.cpp
 *  Esempio utlizzo dei template di classi.
 */

#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;list&gt;

using namespace std;

/** Definisce due nuovi tipi di dato */
typedef time_t Data;
typedef enum _sesso {
    maschio = &#39;m&#39;,
    femmina = &#39;f&#39;
} Sesso;

/** Definisce una classe base per la gestione degli animali */
class Animale {
private:
    string _razza;
    Sesso  _sesso;
public:
    /** Costruttori di copia e parametrico */
    Animale() {}
    Animale(const char* razza, const Sesso sesso ) {
        _razza  = razza;
        _sesso  = sesso;
    }
    /** Funzione virtuale pura: rende la classe &quot;astratta&quot; */
    virtual const char* getSpecie() const {
        return &quot;&quot;; 
    } 
    /** Funzioni di interfaccia */
    const char getSesso() const {        
        return (char)_sesso;
    } 
    const char* getRazza() const {
        return _razza.c_str();
    }
};

/** Operatore di output su stream per la classe Animale */
ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; &quot;Specie:&quot; &lt;&lt; animale.getSpecie() &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Razza:&quot;  &lt;&lt; animale.getRazza()  &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Sesso:&quot;  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}

/** Definizione della classe derivata Cavallo */
class Cavallo : public Animale {
public:
    /** Definizione dei costruttori della classe */
    Cavallo() {}
    Cavallo(const char* razza, const Sesso sesso )
    : Animale(razza, sesso ) { 
    }
    /** Ridefinizione della funzione virtuale pura */
    const char* getSpecie() const {
        return &quot;Cavallo&quot;; 
    }     
};

/** Definizione della classe derivata Cavallo */
class Asino : public Animale {
public:
    /** Definizione del costruttore della classe */
    Asino() {}
    Asino(const char* razza, const Sesso sesso )
    : Animale(razza, sesso ) { 
    }
    /** Ridefinizione della funzione virtuale pura */
    const char* getSpecie() const {
        return &quot;Asino&quot;; 
    }     
};

/** Definizione della classe Monta */
class Monta {
private:
    Animale* _maschio;
    Animale* _femmina;
    Data     _giorno;
    string   _esito;
    /** 
    *   Funzione privata per la definizione 
    *   dell&#39;esito della monta 
    */
    void setEsito() {
        if(strcmp(_maschio-&gt;getSpecie(),&quot;Asino&quot;) == 0) {
            if(strcmp(_femmina-&gt;getSpecie(),&quot;Asino&quot;) == 0) {
                _esito = &quot;asino&quot;;
            } else {
                _esito = &quot;mulo&quot;;
            } 
        } else {        
            if(strcmp(_femmina-&gt;getSpecie(),&quot;Cavallo&quot;) == 0) {
                _esito = &quot;puledro&quot;;
            } else {
                _esito = &quot;bardotto&quot;;
            } 
        }
    }
public:
    /** Costruttore della classe */
    Monta(Animale* maschio, Animale* femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
        setEsito();
    }
    /** Operatore di output, &quot;friend&quot; della classe Monta */
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Monta&amp; copula) {
        os &lt;&lt; &quot;DATA:    &quot; &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
           &lt;&lt; &quot;MASCHIO: &quot; &lt;&lt; *copula._maschio 
           &lt;&lt; &quot;FEMMINA: &quot; &lt;&lt; *copula._femmina
           &lt;&lt; &quot;ESITO:   &quot; &lt;&lt; copula._esito
           &lt;&lt; endl;
           return os;   
     };
};

int main()
{
    /** 
     *  Crea gli oggetti di classe derivata  
     *  e li assegna a puntatori della classe base.
     */
    Animale* cavallo  = new Cavallo(&quot;lipizzano&quot;, maschio);    
    Animale* giumenta = new Cavallo(&quot;maremmano&quot;, femmina);    
    Animale* asino    = new Asino(&quot;amiatino&quot;, maschio);
    Animale* asina    = new Asino(&quot;sardo&quot;, femmina);

    /** Crea una lista con una classe template */
    list&lt;Monta&gt; monte;

    /** Associa alla lista degli oggetti di classe Monta */
    monte.push_back(Monta(cavallo, giumenta)); 
    monte.push_back(Monta (asino, asina));       
    monte.push_back(Monta (asino, giumenta));     
    monte.push_back(Monta (cavallo, asina));

    /** Mostra il contenuto della lista */
    list&lt;Monta&gt;::iterator it;
    for (it=monte.begin(); it!=monte.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; endl;
    }

    return 0;               
}
</code></pre>
<p>L’output di questo codice, nel caso l’avessi scordato, è:</p>
<pre><code>&gt; g++ src/cpp/cplusplus-template.cpp -o src/out/esempio
&gt; src/out/esempio
DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   puledro

DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   asino

DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   mulo

DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   bardotto</code></pre>
<p>Prima di andare avanti, però, è necessario fare un po’ di chiarezza su tre termini legati al polimorfismo: <em>overload</em>, <em>override</em> e <em>ridefinizione</em>.<br />
Con il termine: <strong>overload</strong> di una funzione si intende la una funzione che abbia lo stesso nome di un’altra, ma dei parametri differenti. Un tipico esempio di <em>function overload</em> sono le differenti versioni del costruttore di una classe:</p>
<pre><code>Cavallo() {}
Cavallo(const char* razza, const Sesso sesso )
: Animale(razza, sesso ) { 
}</code></pre>
<p>Le due funzioni hanno lo stesso nome e il compilatore sceglierà l’una o l’altra in base ai parametri che vengono utilizzati.<br />
Una funzione <strong>overridden</strong> è una funzione che ha una definizione diversa da quella di una funzione virtuale di una sua classe-base:</p>
<pre><code>const char* getSpecie() const {
    return &quot;Asino&quot;; 
}     </code></pre>
<p>Come abbiamo visto, il compilatore sceglie l’una o l’altra in base al tipo di oggetto utilizzato per la chiamata.<br />
Se la funzione della classe base non fosse stata virtuale, questa sarebbe stata una semplice <strong>ridefinizione</strong>:</p>
<pre><code>class Persona {
public:
    void getClass(){
        cout &lt;&lt; &quot;Persona&quot; &lt;&lt; endl;
    }
};</code></pre>
<p>Quando gestisce queste funzioni, il compilatore non fa un controllo di tipo dinamico, basato sul tipo dell’oggetto al momento dell’esecuzione, ma sceglie la funzione da chiamare in base al tipo di puntatore o riferimento utilizzato, cosa che, come sai, può creare dei problemi:</p>
<pre><code>Madre   * ptrM = new Madre;
Persona * ptrP = ptrM ;
ptrM-&gt;getClass() ;
ptrP-&gt;getClass() ;  // chiama la funzione di Persona - ERRORE</code></pre>
<p>Alla luce di tutto ciò, possiamo correggere i commenti del codice di esempio:</p>
<pre><code>/** Overload dell&#39;operatore di output su stream  */
ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; &quot;Specie:&quot; &lt;&lt; animale.getSpecie() &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Razza:&quot;  &lt;&lt; animale.getRazza()  &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Sesso:&quot;  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}

/** Override della funzione virtuale pura */
const char* getSpecie() const {
    return &quot;Cavallo&quot;; 
}  

/** Override della funzione virtuale pura */
const char* getSpecie() const {
    return &quot;Asino&quot;; 
}     

/** Overload dell&#39;operatore di output su stream */
friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Monta&amp; copula) {
    os &lt;&lt; &quot;DATA:    &quot; &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
       &lt;&lt; &quot;MASCHIO: &quot; &lt;&lt; *copula._maschio 
       &lt;&lt; &quot;FEMMINA: &quot; &lt;&lt; *copula._femmina
       &lt;&lt; &quot;ESITO:   &quot; &lt;&lt; copula._esito
       &lt;&lt; endl;
       return os;   
 };</code></pre>
<hr />
<p>Nel C++, a ogni operatore corrisponde una funzione. Quella dell’operatore binario <code>+=</code>, per esempio, è:</p>
<pre><code>&lt;tipo&gt;&amp; operator +=  (&lt;tipo&gt;&amp; a, &lt;tipo&gt;&amp; b) ;</code></pre>
<p>laddove <code>a</code> e <code>b</code> sono i due oggetti che intervengono nell’operazione e <code>&lt;tipo&gt;</code> è il tipo delle variabili che intervengono nell’operazione.</p>
<pre><code>int&amp;    operator +=  (int&amp;    a, int&amp;    b) ;
float&amp;  operator +=  (float&amp;  a, float&amp;  b) ;
double&amp; operator +=  (double&amp; a, double&amp; b) ;</code></pre>
<p>Dato che gli operatori unari possono essere prefissi o postfissi, per consentire al compilatore di distinguere le funzione corretta da utilizzare, alla funzione dell’operatore postfisso si aggiunge un secondo parametro, non utilizzato:</p>
<pre><code>void operator ++ (&lt;tipo&gt; a) ;           // versione prefissa
void operator ++ (&lt;tipo&gt; a, &lt;tipo&gt;) ;   // versione postfissa</code></pre>
<p>Le funzioni degli operatori <em>overloaded</em> possono essere richiamate in maniera diretta. Le due istruzioni qui sotto, una volta compilate, producono il medesimo codice e lo stesso risultato. Se riesci a trovare una qualunque ragione per usare la prima sintassi piuttosto che la seconda, fallo pure:</p>
<pre><code>a = b.operator + (c) ;  
a = b + c ;</code></pre>
<p>Il comportamento degli operatori è predefinito per tutti i tipi standard e può essere ridefinito per gestire anche dei tipi di dato aggregati come le strutture o le classi. La classe <code>string</code>, della libreria standard del C++, per esempio, ridefinisce, fra le altre cose, il comportamento degli operatori di assegnazione <code>+=</code> e <code>+</code> e dell’operatore di output su stream <code>&lt;&lt;</code> in modo che si possano compiere delle operazioni sulle stringhe con la stessa sintassi che si utilizza per altri tipi di dato:</p>
<pre><code>/** 
 * @file src/polimorfismo-operatori.cpp
 * Esempio di overload di un operatore.
 */

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main ()
{
    string s1 (&quot;Pip&quot;);
    string s2 (&quot;po&quot;);
    const char* s3 = &quot;Plut&quot;;

    /** 
     *  La classe string definisce tre overload 
     *  per l&#39;operatore += .
     *
     *  string&amp; operator+= (const string&amp; str);
     *  string&amp; operator+= (const char* s);
     *  string&amp; operator+= (char c);
     */
    s1 += s2;
    s1 += s3;

    cout &lt;&lt; (s1 + &#39;o&#39;) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>L’output di questo codice è ben noto:</p>
<pre><code>&gt; g++ src/cpp/polimorfismo-operatori.cpp -o src/out/esempio
&gt; src/out/esempio                                          
PippoPluto</code></pre>
<p>Lo stesso risultato si può ottenere anche con la funzione <code>append</code>:</p>
<pre><code>string&amp; append (const string&amp; str)</code></pre>
<p>ma utilizzare un operatore standard rende il codice più facile da leggere e da scrivere, se non altro perché non ti devi ricordare come si chiama la funzione per unire due stringhe.<br />
Gli unici operatori che non possono essere ridefiniti da una classe sono:</p>
<ul>
<li>l’operatore di selezione <code>.</code>;</li>
<li>l’operatore di risoluzione di indirizzamento dei puntatori a membri della classe <code>.*</code>;</li>
<li>l’operatore di risoluzione del campo d’azione <code>::</code>;</li>
<li>l’operatore condizionale <code>? :</code>;</li>
<li>i simboli <code># </code> e <code>##</code>, che vengono utilizzati dal preprocessore.</li>
</ul>
<hr />
<p>Tranne alcune eccezioni che vedremo fra poco, tutti gli operatori del C++ possono essere ridefiniti o come funzione membro di una classe o come funzione globale:</p>
<pre><code>/** 
 * @file src/polimorfismo-in-out.cpp
 * Operatori come funzioni membro o globali.
 */

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

struct A
{
    int _a;
    A(int a) : _a(a) {}
};

struct B
{
    int _b;
    B(int b) : _b(b) {};   
    /** Overload come funzione membro */
    int operator + (const A&amp; a) {
        return _b + a._a;
    }
};

/** Overload come funzione globale */
int operator + (const A&amp; a, const B&amp; b) { return a._a + b._b; }

int main ()
{
    struct A a(3);
    struct B b(5);
    
    cout &lt;&lt; (a + (b + a)) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Quando si ridefinisce il comportamento di un operatore per una classe, bisogna tenere conto della visibilità dei dati membro che deve utilizzare. Se l’operatore, com’è probabile, deve gestire dei dati privati o protetti, le possibilità sono due: o sfruttare le funzioni di interfaccia della classe o dichiarare l’operatore <code>friend</code> della classe. Nell’esempio iniziale sono applicate entrambe le possibilità: l’operatore di output su stream per la classe <code>Animale</code> utilizza le funzioni di interfaccia della classe:</p>
<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; &quot;Specie:&quot; &lt;&lt; animale.getSpecie() &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Razza:&quot;  &lt;&lt; animale.getRazza()  &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Sesso:&quot;  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}</code></pre>
<p>mentre l’operatore di output per la classe <code>Monta</code> è dichiarato come <code>friend</code> della classe e quindi può accedere direttamente ai dati membro dell’istanza:</p>
<pre><code>friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Monta&amp; copula) {
    os &lt;&lt; &quot;DATA: &quot;    &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
       &lt;&lt; &quot;MASCHIO: &quot; &lt;&lt; *copula._maschio 
       &lt;&lt; &quot;FEMMINA: &quot; &lt;&lt; *copula._femmina;
       return os;   
};</code></pre>
<p>La scelta fra l’una o l’altra possibilità dipende dal tipo di programma che devi scrivere: se punti alla velocità, scegli la seconda, che è più diretta, altrimenti scegli la prima, che sarà probabilmente più lenta in esecuzione, ma non necessiterà di riscritture in caso di modifiche alla struttura della classe. Non è possibile, però, ridefinire come funzione membro di una classe una funzione operatore che abbia come primo parametro una classe di cui non si ha il controllo (come, per esempio, la funzione operatore <code>&lt;&lt;</code> che ha come primo parametro un riferimento a <code>ostream</code>) perché nella funzione membro questo parametro sarebbe sostituito dal parametro implicito <code>this</code>, che ha un altro tipo di dato, causando un errore di compilazione.<br />
Gli operatori <code>=</code>, <code>()</code>, <code>[]</code> e <code>-&gt;</code> non possono essere ridefiniti come funzioni globali, ma devono sempre essere implementati come funzione membro non statica di una classe Le altre regole da ricordare, in questi casi, sono:</p>
<ul>
<li><p>l’operatore unario di assegnamento <code>=</code> è l’unico caso di funzione membro che non viene eredi­tata da eventuali classi figlie; se non viene ridefinito, prevede l’assegnamento membro a membro degli attributi e ha la sintassi:</p>
<pre><code>  C&amp; C::operator = (const C&amp; origine) ;</code></pre></li>
<li><p>l’operatore binario <code>[]</code> permette di implementare vettori di tipo particolare, mantenendo una sintassi standard e ha la forma:</p>
<pre><code>  c.operator [] (n) ;</code></pre>
<p>dove <code>c</code> è un oggetto di classe <code>C</code> e l’indice n può essere un qualsiasi tipo di dato ;</p></li>
<li><p>per ridefinire l’operatore binario di chiamata a funzione <code>()</code>, va utilizzata la sintassi:</p>
<pre><code>  c.operator()(p) ;</code></pre>
<p>dove <code>c</code> è sempre un oggetto di classe <code>C</code> e <code>p</code> è un elenco anche vuoto, di parametri;</p></li>
<li><p>l’operatore unario di accesso ai membri della classe <code>-&gt;</code> viene interpre­tato come:</p>
<pre><code>  (C.operator -&gt; ())-&gt;m ;</code></pre>
<p>e ritorna o un oggetto o un puntatore a un oggetto di classe <code>C</code>.</p></li>
</ul>
<p>Ridefinire gli operatori <code>new</code> e <code>delete</code>, il cui comportamento è strettamente le­gato all’hardware, potrebbe non essere una scelta astuta dal punto di vista della port­abilità del codice; detto ciò, se una classe ha bisogno di gestire la memoria in modo particolare, lo può fare, ma deve rispettare due regole:</p>
<ul>
<li>l’operatore <code>new</code> deve avere il primo argomento di tipo <code>size_t</code> e resti­tuire un puntatore a <code>void</code>;</li>
<li>l’operatore <code>delete</code> deve essere una funzione di tipo <code>void</code> che abbia un primo argomento di tipo <code>void*</code> e un secondo argomento, facoltativo, di tipo <code>size_t</code>.</li>
</ul>
<hr />
<p>In C, per trasformare un <code>int</code> in un <code>double</code> si utilizzano gli operatori di cast:</p>
<pre><code>long int i = 5 ;
double d = (double) i ;</code></pre>
<p>Il C++ accetta questa sintassi, così come accetta che si usi <code>malloc</code> al posto di <code>new</code>, ma la sua sintassi standard, che ricorda vagamente i costruttori delle classi, prevede che il dato da convertire sia passato come parametro a una funzione con lo stesso nome del tipo in cui si vuole che avvenga la conversione :</p>
<pre><code>long int i = 5 ;
double d = double(i) ;</code></pre>
<p>Il compilatore del C++ ha la possibilità di convertire un qualunque tipo di dato primitivo in un altro, ma non può sapere come comportarsi con i tipi di dato definiti dall’utente; dobbiamo quindi istruirlo, così come abbiamo fatto con i costruttori e gli operatori, definendo dei cam­mini di coercizione dai tipi di dato primitivi e viceversa. Il primo caso, ovvero la trasformazione dal tipo primitivo a quello definito dall’utente, è il più semplice: di fatto si tratta di definire, laddove non ci sia già, un cos­truttore per la nuova classe che richieda dei parametri di tipo primitivo. Quando invece non esiste un costruttore da estendere, ovvero quando la coercizione è dal tipo definito dall’utente a un tipo di dato primitivo o fornito in una libreria di cui non si possiede il codice sorgente, è necessario ridefinire l’operatore di conversione <code>()</code>.<br />
Immagina di aver creato un nuovo tipo di dato <code>Frazione</code> per la gestione dei numeri razionali. Per poterlo utilizzare in espressioni contenenti dati di tipo primi­tivo dovresti ridefinire ciascun operatore per fargli accettare dei dati di tipo misto, sia come primo che come secondo parametro:</p>
<pre><code>Frazione operator + (int i, Frazione f) :
Frazione operator - (int i, Frazione f) :
Frazione operator + (double i, Frazione f) :
Frazione operator - (double i, Frazione f) :
...
Frazione operator + (Frazione f, int i) :
Frazione operator - (Frazione f, int i) :
Frazione operator + (Frazione f, double i) :
Frazione operator - (Frazione f, double i) :
</code></pre>
<p>Puoi risparmiarti questa seccatura ridefinendo solo il com­portamento degli operatori per la nuova classe e fornendo al compilatore dei cammini di conversione dai tipi primitivi al nuovo tipo di dato, in modo che possa trasformare i dati nel tipo appropriato, nel caso di espressioni miste:</p>
<pre><code>/** 
 * @file src/polimorfismo-cast.cpp
 * Gestione della conversione esplicita.
 */

#include &lt;iostream&gt;

using namespace std;

class Frazione
{
private:
    
    int _num ;
    int _den ;

public:
    
    /** Costruttore con parametri interi */
    Frazione(int n, int d = 1) 
    : _num(n), _den(d) {} 
    
    /** 
     * Costruttore con parametro a virgola mobile.
     * La definizione è piuttosto complessa, te la risparmio.  
     */
    Frazione(double d) ;

    /** Overload dell&#39;operatore di cast a intero */
    operator int () { 
        return _num / _den ; 
    }

    /** Overload dell&#39;operatore di cast a double */
    operator double() { 
        return (double) _num / (double) _den ; 
    }

    /** Overload degli operatori di somma e sottrazione */
    friend Frazione operator+ (Frazione f1, Frazione f2); 
    friend Frazione operator- (Frazione f1, Frazione f2); 

};
</code></pre>
<hr />
<p>L’ultima cosa di cui ti devo parlare, a proposito del polimorfismo, sono i <em>template</em>.<br />
I template, nel C++, sono dei modelli che si utilizzano per definire delle funzioni o delle classi polivalenti. Se uno stesso compito può essere eseguito in maniera simile su parametri di tipo differente, invece di scrivere delle funzioni o delle classi identiche per ciascun tipo di parametro, si può scrivere una funzione o una classe template e richiamarla ogni volta con il tipo di parametro appropriato:</p>
<pre><code>int    somma(int    a, int    b) { return a + b; }
float  somma(float  a, float  b) { return a + b; }
double somma(double a, double b) { return a + b; }

template &lt;class T&gt; 
somma(T a, T b) { return a + b; }</code></pre>
<p>Quando il compilatore trova nel codice un template, sia esso la dichiarazione di una classe o una chiamata a funzione, la sostituisce con il codice corrispondente, così come avviene per le <a href="/man/preprocessore#macro" class="xref">macro-istruzioni del precompilatore</a>, ma, a differenza di quello che avviene per le macro, il tipo dei parametri del template è sottoposto a uno stretto controllo, così come il resto del codice.<br />
Il formato per la dichiarazione di una <em>funzione template</em> è:</p>
<p><strong>template &lt;class</strong> <em>identificatore</em><strong>&gt;</strong> <em>dichiarazione</em>;<br />
<strong>template &lt;typename</strong> <em>identificatore</em><strong>&gt;</strong> <em>dichiarazione</em>;</p>
<p>Non c’è nessuna differenza fra la prima e la seconda forma: sia <code>class</code> che <code>typename</code> producono lo stesso effetto.<br />
<em>identificatore</em> è un simbolo che identifica un determinato tipo di dato o una classe definita dall’utente. Per esempio, la sintassi di una funzione template che torna il maggiore di due parametri sarà qualcosa di simile:</p>
<pre><code>template&lt;class T&gt;
T maggiore (T x, T y) {
    return (x &gt; y) ? x : y;
}</code></pre>
<p>In questo caso, l’identificativo del tipo è la lettera <code>T</code> che compare sia fra gli apici nella prima riga che fra parentesi nella seconda, ma può essere qualsiasi stringa. I parametri possono essere più di uno:</p>
<pre><code>template&lt;class C1, class C2&gt;
T funz (C1 x, C2 y) {
...
}</code></pre>
<p>e possono avere un valore di default:</p>
<pre><code>template&lt;class N = int&gt;
T funz (N n) {
...
}</code></pre>
<p>La chiamata delle funzioni template è simile a quella delle funzioni ordinarie, con l’aggiunta del tipo dei parametri che devono essere gestiti:</p>
<pre><code>cout &lt;&lt; maggiore&lt;int&gt;   (  9,  12) &lt;&lt; endl;    
cout &lt;&lt; maggiore&lt;double&gt;(0.4, 1.2) &lt;&lt; endl;    
cout &lt;&lt; maggiore&lt;char&gt;  (&#39;a&#39;, &#39;z&#39;) &lt;&lt; endl;    </code></pre>
<p>Il prossimo esempio mostra la differenza fra una macro del precompilatore e una funzione template:</p>
<pre><code>/** 
 * @file src/polimorfismo-macro-template.cpp
 * Funzioni template e macro precompilatore.
 */

#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

/**
*  Definzione di una macro istruzione per il 
*  precompilatore: nessun controllo di tipo.
*/
#define MAGGIORE(a,b) ((a &gt; b) ? a : b) 

/**
*  Definzione di una funzione template
*  che torna il maggiore fra due parametri.
*/
template&lt;class T&gt;
T maggiore (T x, T y) {
    return (x &gt; y) ? x : y;
}

int main ()
{     
    int    a = 10;
    short  b = 0;   
    double d = 3.123456789;
    
    /** Utilizzo della macro */
    cout &lt;&lt; MAGGIORE(9,12)     &lt;&lt; endl;    
    cout &lt;&lt; MAGGIORE(0.4, 0.7) &lt;&lt; endl;    
    cout &lt;&lt; MAGGIORE(&#39;a&#39;, &#39;z&#39;) &lt;&lt; endl;    

    /** 
    *  La stessa funzione si può utilizzare 
    *  con tipi di dato diversi:
    */
    cout &lt;&lt; maggiore&lt;int&gt;   (  9,  12) &lt;&lt; endl;    
    cout &lt;&lt; maggiore&lt;double&gt;(0.4, 1.2) &lt;&lt; endl;    
    cout &lt;&lt; maggiore&lt;char&gt;  (&#39;a&#39;, &#39;z&#39;) &lt;&lt; endl;    
   
    /** Errore: confronta un carattere con un double */
    cout &lt;&lt; MAGGIORE(&#39;a&#39;, d) &lt;&lt; endl;    

    /**
    *   Errore: il compilatore non sa quale
    *   dei due tipi di dato utilizzare.
    */
    cout &lt;&lt; maggiore(a, b) &lt;&lt; endl;    
    
    return 0;
}
</code></pre>
<p>La macro <code>MAGGIORE</code> e la funzione template <code>maggiore</code> eseguono la stessa operazione: confrontano i due parametri che hanno ricevuto in input e tornano il maggiore dei due. La grossa differenza fra questi due approcci è che, mentre il tipo dei parametri del template è verificato dal compilatore, la macro è una banale sostituzione che non fa alcun controllo sulle variabili che utilizza. L’istruzione:</p>
<pre><code>cout &lt;&lt; MAGGIORE(&#39;a&#39;, b) &lt;&lt; endl; </code></pre>
<p>compara un carattere con un double e, senza dare problemi in compilazione torna il valore <code>97</code>, corrispondente al codice ASCII della lettera <code>a</code>. Al contrario, l’istruzione:</p>
<pre><code>int   a = 10;
short b = 0;
cout &lt;&lt; maggiore(a, b) &lt;&lt; endl;  </code></pre>
<p>causa un errore di compilazione perché i due parametri sono di tipo differente:</p>
<pre><code>&gt; g++ src/cpp/polimorfismo-template.cpp -o src/out/esempio
src/cpp/polimorfismo-template.cpp:52:13: 
    error: no matching function for call to &#39;maggiore&#39;
    cout &lt;&lt; maggiore(a, b) &lt;&lt; endl;    
            ^~~~~~~~
src/cpp/polimorfismo-template.cpp:22:3: 
    note: candidate template ignored: 
        deduced conflicting types for parameter &#39;T&#39;
      (&#39;int&#39; vs. &#39;short&#39;)
T maggiore (T x, T y) {
  ^</code></pre>
<p>La dichiarazione di una <em>classe template</em> ha la forma:</p>
<p><strong>template &lt;class</strong> <em>identificatore</em><strong>&gt;</strong> <em>dichiarazione</em>;</p>
<p>La lista dei parametri fra i simboli <code>&lt;&gt;</code> può contenere uno o più simboli per i tipi dato gestiti dalla classe. L’utilizzo di queste classi è simile a quello delle funzioni template:</p>
<pre><code>/** 
 * @file src/polimorfismo-classe-template.cpp
 * Esempio di classe template.
 */

#include &lt;iostream&gt;

using namespace std;

/**
*   Definisce una classe che gestisce coppie 
*   di coordinate.
*/
template&lt;class T&gt;
class Coord {
private:
    /** Dati membro con tipo variabile */
    T _x, _y; 
public:
    /** Costruttore con tipo di parametri variabile */
    Coord(const T x, const T y) 
    : _x(x), _y(y) {        
    }
    friend ostream&amp; operator &lt;&lt; (ostream&amp; o, const Coord&amp; c) {
        o &lt;&lt; c._x &lt;&lt; &#39;,&#39; &lt;&lt; c._y ;
        return o;
    }
};

int main ()
{         
    /** Istanza con coordinate geografiche */
    Coord&lt;double&gt; obelisco(41.903219, 12.458157);
    
    /** Istanza con coordinate schermo */
    Coord&lt;int&gt;    pixel(821, 134);
    
    cout &lt;&lt; &quot;Obelisco:&quot; &lt;&lt; obelisco &lt;&lt; endl;    
    cout &lt;&lt; &quot;Pixel:   &quot; &lt;&lt; pixel    &lt;&lt; endl;    
    
    return 0;
}
</code></pre>
<hr />
<p>Il codice che ti ho mostrato all’inizio di questa lezione utilizza una classe template:</p>
<pre><code>list&lt;Monta&gt; monte;</code></pre>
<p>La classe <code>list</code> è una delle classi della <em>Standard Template Library</em> del C++, una libreria di classi e di funzioni che permettono di risolvere dei problemi comuni della programmazione, come la memorizzazione, l’ordinamento o la ricerca di una serie di dati. Le componenti della STL è sono:</p>
<ul>
<li>una libreria di <strong>container</strong> che permettono di immagazzinare oggetti e dati;</li>
<li>degli <strong>iteratori</strong> che consentono di scorrere il contenuto dei container;</li>
<li>una collezione di <strong>algoritmi</strong> che permettono di eseguire delle operazioni di ordinamento e ricerca su insiemi di dati;</li>
<li>degli oggetti-funzioni, o: <strong>functors</strong>, che incapsulano una specifica funzione.</li>
</ul>
<p>La classe <code>list</code> è un esempio di container e rappresenta un elenco di elementi memorizzati in aree non contigue della memoria. Al contrario, la classe <code>vector</code> implementa un elenco di elementi memorizzati in un’unica area di memoria, così come avviene per gli array del C.<br />
Tutti i vettori della STL posseggono delle funzioni membro che consentono di gestirne gli elementi; la funzione <code>push_back</code>, per esempio, aggiunge un elemento in coda alla lista:</p>
<pre><code>monte.push_back(Monta(cavallo, giumenta)); 
monte.push_back(Monta (asino, asina));       
monte.push_back(Monta (asino, giumenta));     
monte.push_back(Monta (cavallo, asina));</code></pre>
<p>Gli <em>iteratori</em> sono dei costrutti che permettono di scorrere il contenuto di un container, individuandone gli elementi. Ne abbiamo utilizzato uno nell’istruzione:</p>
<pre><code>list&lt;Monta&gt;::iterator it;
for (it=monte.begin(); it!=monte.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; endl;
}</code></pre>
<p>La prima istruzione del ciclo <code>for</code> assegna all’iteratore <code>it</code> il primo elemento della lista, tornato dalla funzione membro <code>monte.begin</code>. La seconda istruzione, verifica che l’iteratore sia differente da <code>monte.end</code>, che punta alla fine della lista. La terza istruzione incrementa l’iteratore di una posizione e dimostra come la ridefinizione di un operatore per una classe renda il codice più facile da leggere: anche se tu non hai mai visto una classe template, capisci subito che quella istruzione incrementa il valore di <code>it</code> di un’unità.<br />
Gli <em>algoritmi</em> della STL, definiti nell’header <code>&lt;algorithm&gt;</code> sono funzioni template che permettono di individuare, copiare, ordinare, unire o eliminare i dati all’interno di un container.</p>
<pre><code>/** 
 * @file src/polimorfismo-algoritmi.cpp
 * Esempio di utilizzo degli algoritmi della STL.
 */

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    vector&lt;int&gt; vect;
    
    vect.push_back(10);
    vect.push_back(70);
    vect.push_back(21);
    vect.push_back(49);
    vect.push_back(35);

    cout &lt;&lt; *min_element(vect.begin(), vect.end()) &lt;&lt; endl;
    cout &lt;&lt; *max_element(vect.begin(), vect.end()) &lt;&lt; endl;
    
    vector&lt;int&gt;::iterator i;
    for(i = vect.begin(); i != vect.end(); i++) {
        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    int n = vect.size();
    sort(vect.begin(), vect.end());
    for (int i=0; i&lt;n; i++) {
        cout &lt;&lt; vect[i] &lt;&lt; &quot; &quot;;       
    }
    cout &lt;&lt; endl;

    reverse(vect.begin(), vect.end());
    for (int i=0; i&lt;n; i++) {
        cout &lt;&lt; vect[i] &lt;&lt; &quot; &quot;;       
    }
    cout &lt;&lt; endl;

 
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; g++ src/cpp/polimorfismo-algoritmi.cpp -o src/out/esempio
&gt; src/out/esempio                                          
10
70
10 70 21 49 35 
10 21 35 49 70 
70 49 35 21 10 </code></pre>
<p>Le function-class o: <em>functors</em> sono delle classi che ridefiniscono il comportamento dell’operatore <code>()</code> e che possono quindi agire come se fossero delle funzioni:</p>
<pre><code>/** 
 * @file src/polimorfismo-functor-stl.cpp
 * Esempio di function objects della STL.
 */

#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

int main ()
{
    int a = 12;
    int b = 4;

    /** Dichiarazione di oggetti functor */
    plus&lt;int&gt;       p;
    minus&lt;int&gt;      m;
    multiplies&lt;int&gt; x;
    divides&lt;int&gt;    d;
    modulus&lt;int&gt;    o;

    /** Utilizzo degli oggetti come fossero delle funzioni */
    cout &lt;&lt; &quot;plus: &quot;       &lt;&lt; p(a,b) &lt;&lt; endl;
    cout &lt;&lt; &quot;minus: &quot;      &lt;&lt; m(a,b) &lt;&lt; endl;
    cout &lt;&lt; &quot;multiplies: &quot; &lt;&lt; x(a,b) &lt;&lt; endl;
    cout &lt;&lt; &quot;divides: &quot;    &lt;&lt; d(a,b) &lt;&lt; endl;
    cout &lt;&lt; &quot;modulus: &quot;    &lt;&lt; o(a,b) &lt;&lt; endl;

    /** &quot;esegue&quot;&quot; l&#39;oggetto o con nuovi parametri */
    cout &lt;&lt; &quot;modulus: &quot;    &lt;&lt; o(a,5) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Utilizzati così, i <em>functor</em> hanno poco senso, ma possono essere (e sono) molto utili quando si utilizzano quelle funzioni della STl che elaborano tutti gli elementi di un container, come per esempio la funzione <code>transform</code>:</p>
<pre><code>/** 
 * @file src/polimorfismo-rot13.cpp
 * Trasformazione di una stringa con una funzione.
 */

#include &lt;string&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

/** 
*   Funzione che converte i caratteri di una stringa in rot13  
*   Il ROT13 è un algoritmo di cifratura piuttosto banale, 
*   perché incrementa di 13 il valore di ciascun carattere. 
*   Non è un algoritmo realmente sicuro, però, perché per 
*   decifrare il testo crittografato basta crittografarlo 
*   di nuovo.  
*/
unsigned char rot13(unsigned char c) 
{ 
    unsigned char rot = c;
    if (isalpha(c)) {
        rot = ((tolower(c) - &#39;a&#39;) &lt; 14) ? c + 13 : c - 13;
    }
    return rot;
}

int main ()
{
    string pp(&quot;PippoPluto&quot;); 

    /** Elabora la stringa con la funzione transform */
    transform(
               pp.begin()   // inizio del container da modificare
             , pp.end()     // fine del container da modificare
             , pp.begin()   // container di output
             , rot13        // funzione da applicare
             );

    cout &lt;&lt; pp &lt;&lt; endl; 

    /** Ripetendo l&#39;operazione, il testo torna normale. */
    transform(
               pp.begin()   
             , pp.end()     
             , pp.begin()   
             , rot13        
             );

    cout &lt;&lt; pp &lt;&lt; endl; 
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo programma, otterrai :</p>
<pre><code>&gt; g++ src/cpp/polimorfismo-rot13.cpp -o src/out/esempio     
&gt; ./src/out/esempio
CvccbCyhgb
PippoPluto</code></pre>
<p>Le funzioni ordinarie ti permettono di sfruttare l’algoritmo <code>transform</code> per cifrare un testo con un valore fisso, ma non puoi fare la stessa cosa utilizzando una chiave variabile, perché il quarto parametro non accetta funzioni con più di un parametro. Se provassi a utilizzarlo con qualcosa come:</p>
<pre><code>unsigned char cifra(unsigned char c, int chiave) 
{ 
    return c + chiave;
}</code></pre>
<p>otterresti l’errore:</p>
<pre><code>/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/algorithm:1855:34: error: too few arguments to
      function call, expected 2, have 1
        *__result = __op(*__first);
                    ~~~~         ^
src/cpp/polimorfismo-transform-chiave.cpp:25:5: note: in instantiation of function template specialization
      &#39;std::__1::transform&lt;std::__1::__wrap_iter&lt;char *&gt;, std::__1::__wrap_iter&lt;char *&gt;, unsigned char
      (*)(unsigned char, int)&gt;&#39; requested here
    transform(
    ^</code></pre>
<p>È in questi casi che tornano utili i <em>functor</em>, perché possono essere inizializzati con uno o più valori specifici e poi essere utilizzati come funzioni unarie:</p>
<pre><code>/** 
 * @file src/polimorfismo-functor.cpp
 * Creazione di una classe functor.
 */

#include &lt;string&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

/** Dichiarazione della classe functor */
class Cifra
{
private:

    int _chiave;

public:
    
    /** 
    *   Il costruttore della classe ha come parametro
    *   il valore della chiave di cifratura
    */
    Cifra(int chiave) : _chiave(chiave) {  }
  
    /** Ridefinizione dell&#39;operatore () */
    unsigned char operator () (unsigned char c) const {
        return c + _chiave;
    }
};

int main ()
{
    string pp(&quot;PippoPluto&quot;); 

    /** 
    *   Richiama transform passando come parametro
    *   un&#39;istanza del functor, inizializzata con 
    *   la chiave di cifratura.
    */
    transform(
               pp.begin()   
             , pp.end()     
             , pp.begin()   
             , Cifra(1)        
             );

    cout &lt;&lt; pp &lt;&lt; endl; 
    
    return 0;
}
</code></pre>
<p>Compilando ed eseguendo questo programma, ottieni :</p>
<pre><code>&gt; g++ src/cpp/polimorfismo-functor.cpp -o src/out/esempio
&gt; ./src/out/esempio
QjqqpQmvup</code></pre>
<p>che corrisponde ai caratteri della stringa <em>PippoPluto</em> incrementati di un’unità.</p>
<hr />
<p>Da migliaia di anni, gli uomini cercano di capire quale sia il significato dell’Esistenza.<br />
Le risposte che si sono dati variano a seconda del periodo storico e del territorio in cui il profeta o il filosofo ha vissuto, ma hanno tutte una particolarità: richiedono ai loro seguaci l’accettazione di postulati non dimostrabili, come l’esistenza di una o più divinità o di stati di esistenza diversi da quello che conosciamo. Anche la Scienza ha provato a dare delle risposte agli stessi interrogativi, ma la sua indagine si è limitata agli aspetti pratici del problema: ha prodotto delle interessanti teorie sulla genesi dell’Universo e sugli eventi che hanno portato alla nostra esistenza, ma non si è mai pronunciata su quello che potrebbe essere il nostro ruolo in tutto ciò, con le conseguenze di cui abbiamo parlato durante <a href="/man/memoria#delete" class="xref">la lezione sulla memoria</a>.<br />
Il Maestro Canaro, che non riusciva ad accettare né i dogmi delle religioni tradizionali né lo scollamento fra uomo e Universo prodotto dalle ipotesi scientifiche, si pose una domanda:</p>
<blockquote>
<p>È possibile dare una spiegazione dell’Esistenza sfruttando solo ciò di cui abbiamo esperienza diretta?</p>
</blockquote>
<p>La maggior parte delle religioni, per “funzionare”, richiede da una a tre dimensioni aggiuntive, oltre quelle note; la Scienza, per le sue <em>super-stringhe</em> ha bisogno almeno di sette dimensioni aggiuntive, ovvero il doppio di quelle che servono per un Aldilà non spirituale. Esiste una spiegazione più semplice?<br />
Non essendo né un filosofo né un mistico, approcciò lo sviluppo della sua dottrina come se fosse stata un sistema software. Per prima cosa fece un’analisi del “sistema in esercizio”, evidenziandone i principali difetti; poi identificò delle vulnerabilità logiche delle religioni canoniche e definì delle linee-guida atte a prevenirle; infine, descrisse le caratteristiche del C’hi++, spiegando come queste avrebbero potuto risolvere alcuni dei problemi evidenziati in precedenza. Come scrisse nella <a href="/proposta#errori" class="xref">Proposta</a>, ci sono dei “bug” che possiamo considerare comuni a tutte le metafisiche:</p>
<blockquote>
<ul>
<li>i dogmi, che sono le fondamenta delle dottrine, sono facilmente attaccabili perché non possono essere dimostrati, ma solo accettati per fede;</li>
<li>una religione può avere delle difficoltà nel modificare la propria dottrina, anche quando è dimostrato che uno dei suoi dogmi non è corretto;</li>
<li>la contestazione di un dogma causa quasi inevitabilmente una separazione e le separazioni è probabile che sfocino in conflitti.</li>
</ul>
</blockquote>
<p>ed altri, che possiamo considerare comuni agli esseri umani:</p>
<blockquote>
<ul>
<li>la tendenza a difendere i propri principii anche con mezzi che contrastano con i principii stessi;</li>
<li>la tendenza a influenzare la propria obiettività con le proprie speranze.</li>
</ul>
</blockquote>
<p>Per correggere o quanto meno mitigare questi problemi, la sua metafisica avrebbe dovuto:</p>
<blockquote>
<ul>
<li>limitare il numero dei dogmi;</li>
<li>limitare gli elementi metafisici e le accettazioni per fede;</li>
<li>non proporsi come Unica Verità Incontestabile, ma come un'approssimazione sicuramente incompleta e perfettibile della Verità;</li>
<li>riconoscere le contraddizioni della dottrina e analizzarle obiettivamente, anche se ciò porterà a modificare la dottrina stessa.</li>
</ul>
</blockquote>
<p>Il Maestro Canaro applicò allo sviluppo della sua <em>metafisica-non-metafisica</em> lo stesso approccio che adottava quando doveva realizzare un software. Ci sono due modi diversi di progettare un software: il primo consiste nell’analizzare tutti i sistemi che svolgono azioni simili, prendere il meglio di ciascuno e metterlo nel nuovo sistema; in alternativa, si può progettare il sistema da zero e solo quando se ne è definita per grandi linee la struttura, studiare le soluzioni adottate dagli altri, integrandole nel proprio programma, se lo si ritiene utile. Il primo approccio è più rapido e sicuro, ma tende a produrre risultati ripetitivi; il secondo approccio è più complesso, sia in termini di analisi che di implementazione, ma facilita l’innovazione perché l’immaginazione dell’analista non è condizionata da ciò che ha visto.<br />
Essendo un sostenitore del secondo metodo, il Maestro Canaro lo applicò anche al C’hi++ e, dopo una decina di anni di studio, arrivò alla conclusione che non solo è possibile ipotizzare una cosmogonia quasi del tutto priva di elementi metafisici (non del tutto priva, perché, come vedremo <a href="/man/stream#dottrina" class="xref">in seguito</a>, una dose minima di trascendenza è necessaria per garantire la buona funzionalità della dottrina), ma che i precetti di questa dottrina erano compatibili con molti principii delle religioni canoniche.</p>
<hr />
<p>Il C’hi++ ereditò alcuni concetti proprii delle filosofie note al Maestro Canaro, come il dualismo Gravità/Elettricità elaborato da Poe in <em>Eureka</em>, che lo aveva affascinato per il modo in cui trasformava una forza cieca e inspiegabile come la Gravità nell’intenzione, cosciente, di tutto ciò che esiste di tornare a essere Uno. D’altro canto, la dottrina del Maestro Canaro rinnegò alcuni concetti comuni a molte religioni, come la possibilità di sottrarsi al ciclo delle rinascite o la presenza di punizioni o premii <em>ad-personam</em>.<br />
Così come quando si analizza il funzionamento di un software non ci si cura delle singole variabili, ma si pensa al flusso complessivo del sistema, così il C’hi++ vede l’esistenza non in termini di interazioni fra individui, ma come l’evoluzione del flusso dell’Energia dell’Uno all’interno della matrice tridimensionale degli spazioni. Per il C’hi++ non esistono né anime, né fiumi infernali e chi muore in mare non troverà ad accoglierlo Rán, nella sua birreria in fondo al mare, ma verrà semplicemente riciclato, come le aree di memoria RAM all’interno di un computer.<br />
Le nostre esistenze sono incidentali; pensare di punirle o di premiarle non avrebbe senso e contrasterebbe con il principio generale che tutto ciò che esiste è la manifestazione di un’unica Entità. Come ti ho detto all’inizio di queste lezioni, non è possibile andare in Paradiso o all’Inferno da soli: qualunque cosa avvenga, nell’Universo, ci riguarda tutti.<br />
Questo però non vuol dire che il C’hi++ rifiuti <em>in toto</em> tutti concetti delle religioni che lo hanno preceduto; anzi. Molti precetti del C’hi++ sono compatibili con precetti o idee appartenenti ad altre mistiche o filosofie e si tratta spesso di filosofie che il Maestro Canaro non conosceva, quando pose la basi della sua dottrina. Per esempio, il Maestro Canaro non lesse mai (con suo grande rammarico) la <em>Divina Commedia</em>; ciò non ostante, il C’hi++ ha un punto di contatto con la visione dantesca dell’Aldilà nell’importanza del pentimento. Dante mette in Purgatorio i peccatori che hanno capito di aver sbagliato, mentre condanna all’Inferno quelli che, malgrado tutto, non riescono a prendere coscienza delle proprie colpe. Come abbiamo detto <a href="/man/istruzioni-condizionali#pentimento" class="xref">in precedenza</a> e come vedremo durante la lezione sul <a href="/man/debug#pentimento" class="xref">debug</a>, il C’hi++ concorda con questa idea.<br />
Similmente, ci sono diverse affinità fra i C’hi++ e la <em>Bhagavad-Gita</em>, anche se lui lesse mentre stava redigendo la <em>Proposta</em>, quando i punti nodali del suo Credo erano già stati definiti.<br />
Oltre alla citazione che ti ho fatto parlando del <a href="/man/programmatore#azione" class="xref">programmatore</a>, ci sono dei brani che ricordano molto le affermazioni contenute in <em>Sostiene Aristotele</em>; per esempio, sulla natura dell’Universo:</p>
<blockquote>
<p>Alla fine del proprio ciclo d’esistenza, un mondo collassa su se stesso, riassorbendo in una massa tenebrosa ogni forma di manifestazione: esseri viventi e oggetti inanimati giacciono allo stato latente in una condizione caotica. I cicli cosmici sono periodi temporali chiamati Manvantara, suddivisi al proprio interno in quattro ere o Yuga, ciascuna caratterizzata da una particolare qualità dell’esistenza. Si tratta di un ritorno periodico a condizioni di vita non uguali ma analoghe, da un punto di vista qualitativo, a quelle dei cicli precedenti, una successione di quattro ere che ricorda, su scala ridotta, l’alternarsi delle quattro stagioni.</p>
</blockquote>
<p>O sul dualismo Gravità/Entropia :</p>
<blockquote>
<p>Il Sāṁkhya, la dottrina su cui si fonda lo Yoga, parla di due princìpi che, interagendo tra loro, manifestano l’intero universo con tutti gli esseri viventi e gli oggetti inanimati che lo popolano: Prakṛti, il polo materiale e femminile, e Puruṣa, quello spirituale e maschile; nell’essere umano Prakṛti costituisce il corpo e la mente, che diventano la dimora dell’anima individuale (puruṣa).</p>
</blockquote>
<p>O su quelli che io ho definito i <em>Post-It</em>:</p>
<blockquote>
<p>Ci sono due categorie di saṁskāra; la prima consiste nelle vāsanā, che sono impressioni lasciate nella mente dagli avvenimenti passati, tracce qui conservate allo stato latente ma pronte a manifestarsi in presenza delle condizioni adatte, cioè di situazioni analoghe a quelle che le hanno generate, e che le attiverebbero a causa della loro affinità. Sulla spinta delle vāsanā, una volta che siano attivate, e degli stati d’animo che queste manifestano, l’individuo presenta una tendenza inconscia ad agire in un determinato modo, e più in generale ad avere un certo tipo di comportamento, di sensibilità, di carattere; si tratta di una predisposizione innata che lo induce, nel bene come nel male, ad un comportamento analogo a quello che ha tenuto in passato, creando un circolo vizioso (o virtuoso) che si autoalimenta.</p>
</blockquote>
<p>Puoi trovare delle analogie con i precetti del C’hi++ anche nel <em>Mantiq al-Tayr</em>:</p>
<blockquote>
<p>Tutto è un’unica sostanza in molteplici forme, tutto è un unico discorso in diverse espressioni (…) Egli sfugge a ogni spiegazione, a qualsiasi attributo. Di Lui soltanto una pallida idea ci è concessa, dare compiuta notizia di Lui è impossibile. Per quanto bene o male si parli di Lui, in realtà d’altri non si parla che di se stessi.</p>
</blockquote>
<p>o anche:</p>
<blockquote>
<p>O Creatore, tutto il male o il bene che feci,<br />
in verità lo feci solo a me stesso.</p>
</blockquote>
<p>Per certi versi anche la stessa Genesi biblica può essere considerata un’allegoria della cosmogonia spazionista: il Paradiso è l’Uno primigenio, mentre Adamo (<em>Puruṣa</em>) ed Eva (<em>Prakṛti</em>) sono l’Ente che ne causa la disgregazione, generando un Universo dove si partorisce nel dolore e dove ci si deve guadagnare il pane con il sudore della fronte.<br />
Il Maestro Canaro pensava che tutto questo fosse normale. Come scrisse nel <a href="https://github.com/chi-plus-plus/chi-plus-plus/blob/master/MANIFEST.md">MANIFEST</a> GitHub del C’hi++:</p>
<blockquote>
<p>Spogliate degli orpelli e ricondotte alle loro caratteristiche essenziali, le diverse ipotesi metafisiche hanno molti punti in comune perché sono tutte, in una maniera o nell’altra, la risposta a uno stesso bisogno: la ricerca di una giustificazione alla nostra esistenza.</p>
</blockquote>
<p>In una nota della mappa mentale su cui basò lo sviluppo iniziale della dottrina, aggiunse:</p>
<blockquote>
<p>Le diverse religioni, possono essere delle forme derivate di una stessa mistica iniziale? Esistono dei “dati membro” e delle funzioni comuni, che siano state ridefinite con il passare del tempo, ma che facciano capo a un corpo di credenze (o di nozioni) iniziale? Anche solo in questa mappa, se ne trovano diverse (p.es. Empedocle -&gt; Poe). Così come le classi di un linguaggio Object-Oriented sono ridefinite per adattarsi a uno specifico contesto di utilizzo, così pure la Mistica iniziale potrebbe essere stata “overloaded” per adattarsi a uno specifico luogo o tempo. Se fosse così, tanto più si va indietro nel tempo, e quindi nella gerarchia di classi, tanto più ci si dovrebbe avvicinare alle caratteristiche proprie della Mistica. È possibile definire una gerarchia di classi figlie della classe astratta <code>Credo</code>? Semplificando molto (visto che sono le 3 di notte): Budda e Zoroastro influenzano i Greci, che influenzano gli Ebrei, che a loro volta influenzano i Cristiani, che alla fine producono i Testimoni di Geova… Allo stesso modo (sempre semplificando), dal C si è evoluto il C++ e dal C++, Java.</p>
</blockquote>
<hr />
<p>Fra il C’hi++ e le religioni canoniche c’è la stessa differenza che passa fra una mappa topografica e un’immagine da satellite.<br />
Quel senza Dio di Dawkins, ha detto che:</p>
<blockquote>
<p>Uno dei caratteri di una folle stravaganza è un uso troppo entusiasta dell’analogia.<a href="/man/note#dawkins-analogia" class="nota"></a></p>
</blockquote>
<p>Una frase curiosa, da parte di un esponente di una setta che cerca di descrivere tutto ciò che esiste con analogie matematiche e nega l’esistenza di ciò che non riesce a convertire..<br />
Entusiasmi a parte, le mappe e le immagini da satellite hanno diverse analogie con le discipline metafisiche. Anche le mappe e le immagini, come la metafisica, sono costrette a rappresentare il loro soggetto a un rapporto di scala ridotto e con due sole dimensioni in vece di tre (o di quattro se, oltre alla profondità, vuoi considerare anche il tempo). Anche le mappe e le immagini, per questo motivo, devono rappresentare il loro soggetto per mezzo di analogie: le carte topografiche usano delle linee altimetriche e dei simboli; le immagini satellitari usano dei pixel o dei piccoli punti di colore. In nessuno dei due casi ciò che noi vediamo è davvero ciò che rappresenta; è il nostro cervello che decide di crederlo tale: nel caso della carta topografica, perché la legenda ci permette di definire una correlazione fra significato e significante; nel caso dell’immagine, perché il nostro occhio riconosce in quelle combinazioni di pixel o di punti di colore degli alberi, il mare o delle case.<br />
Un’altra analogia, conseguenza dei due punti precedenti, è che è sbagliato confondere i simboli con ciò che rappresentano: i quadratini scuri delle mappe <em>non</em> sono case; i punti colorati delle immagini <em>non</em> sono un bosco. Mappe e immagini hanno senso solo a un certo livello di lettura; se lo oltrepassiamo, se cerchiamo di ottenere più informazioni o verosimiglianza avvicinando lo sguardo, otteniamo l’effetto opposto, perché i simboli si rivelano per quello che sono: punti colorati o linee su un foglio. Questo però non vuol dire che ciò che rappresentano sia falso, ma che noi non stiamo guardando con <em>il giusto paio di occhi</em>, come direbbe Hunter Thompson.<br />
Il Maestro Canaro pensava che fosse per questo motivo che alcune religioni sono contrarie alla rappresentazione diretta della Divinità: perché è facile che poi si confonda il simbolo con ciò che rappresenta. Tornando al paragone iniziale, le religioni tradizionali sono delle immagini da satellite, mentre il C’hi++ è una mappa topografica.<br />
Mentre i Credi religiosi riescono a riprodurre — nei limiti imposti dalla nostra condizione — tutta la bellezza del Creato, il C’hi++ si limita a darne una descrizione schematica, più povera di contenuti e di poesia, ma più facile da accettare per chi non abbia la benedizione della Fede. Un’immagine da satellite ha un valore contemplativo: è bella da guardare sullo schermo del tuo computer o anche da appendere al muro, come un quadro, ma se ti sei perso in un bosco o in mezzo ai monti, una mappa topografica, proprio in virtù della sua schematicità, ti permetterà più facilmente di ritrovare la strada di casa.<br />
Il C’hi++ non cerca di rubare fedeli alle religioni canoniche. Non avrebbe senso: sarebbe come cercare di convincere chi sia già sposato con l’amore della sua vita a fare un matrimonio di interesse: se tu hai la Fede non hai bisogno di conferme razionali; possono compiacerti, ma non ti sono necessarie. Il C’hi++, però, può dare forza a quelle (tante) persone che <em>ancora credono in tutto ciò in cui più nessuno crede</em>, come li descrisse Longanesi; quella <em>Banda degli Onesti</em><a href="/man/note#banda-onesti" class="nota"></a> che tutti i giorni fa il proprio dovere al meglio possibile anche se non gli conviene, anche tutto e tutti intorno a loro sembrano spingerli all’egoismo e all’indifferenza. Può aiutarli a non arrendersi e può insegnare loro che non è importante vincere le partite, ma giocare sempre meglio. Riconoscere gli sbagli che si sono fatti, imparare da essi e cercare di non ripeterli più, partita dopo partita, in una ricerca continua del meglio. Se si comporteranno così, qualunque sarà il loro lavoro, fosse anche pulire i cessi, sarà comunque Arte.</p>
</section>
</section>
<a href="/man/ereditarieta" class="left" title="Vai a: L&#39;ereditarietà"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/stream" class="right" title="Vai a: Gli stream"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/polimorfismo" class="left" title="Vai a: Il polimorfismo"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/debug" class="right" title="Vai a: Il debug"><em></em></a>
<section id="gli-stream-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Gli stream</a></h1>
<blockquote>
Non puoi immergere i tuoi byte due volte nello stesso stream
</blockquote>
<section class="testo">
<p>Oggi ti parlerò degli <em>stream</em> che, com’è noto, sono la componente più importante del C++.</p>
<p>Il C++ eredita dal C l’assenza di parole chiave per la gestione dell’I/O. Al posto di istruzioni come la <code>print</code> del BASIC, utilizza delle librerie di classi e funzioni che permettono di convertire in testo stampabile gli oggetti gestiti dal programma o di convertire degli elementi testuali in oggetti. Non potrebbe essere altrimenti: il C++ non deve gestire solo stringhe e numeri, come il BASIC, ma anche numeri in virgola mobile, puntatori e soprattutto i tipi di dato definiti dall’utente, per i quali non sarebbe possibile definire un comportamento standard e che quindi dovrebbero essere trattati in maniera differente dai dati primitivi, con tanti saluti alla coerenza del linguaggio.<br />
Oltre a poter sfruttare le librerie di funzioni del <em>C</em>, il C++ ha una propria libreria di I/O, ba­sata sulla gerarchia delle classi <code>stream</code>, che permette di gestire anche i tipi di dato definiti dall’utente. Abbiamo visto degli esempii di questa caratteristica quando abbiamo parlato di <a href="/man/c-plus-plus#polimorfismo" class="xref">polimorfismo</a> e di <a href="/man/polimorfismo#overload-operatori" class="xref">overload degli operatori</a>:</p>
<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; &quot;Specie:&quot; &lt;&lt; animale.getSpecie() &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Razza:&quot;  &lt;&lt; animale.getRazza()  &lt;&lt; &quot;\t&quot;
        &lt;&lt; &quot;Sesso:&quot;  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}</code></pre>
<p>Questo codice “insegna” all’operatore <code>&lt;&lt;</code> come comportarsi per visualizzare un oggetto di classe <code>Animale</code>. Lo stesso si può fare (e lo abbiamo fatto) per qualsiasi altro tipo definito dall’utente. È la sintassi del linguaggio che si adatta alle esigenze del programmatore, e non viceversa.<br />
Alcuni concetti chiave per la comprensione degli stream sono:</p>
<ul>
<li>uno <em>stream</em> è un’astrazione che rappresenta la sorgente o la destinazione di un insieme di dati di lunghezza variabile: l’input da tastiera, l’output su schermo, i buffer di memoria, le stringhe, i file;</li>
<li>l’output su stream verso una qualsiasi destinazione, viene definito <em>scrit­tura</em> o <em>inserimento</em> e si effettua per mezzo dell’operatore <code>&lt;&lt;</code>;</li>
<li>con i termini <em>lettura</em> o <em>estrazione</em>, invece, si intende l’operazione di acquisizione da una sorgente, effettuata dall’operatore <code>&gt;&gt;</code>.</li>
</ul>
<p>La libreria <code>iostream</code> del C++ permette di gestire le operazioni di I/O su stream per mezzo di classi derivate da due classi base: <code>streambuf</code> e <code>iosbase</code>. La libreria ha due diverse “linee genealogiche”: una destinata alla gestione dei caratteri di un byte e una destinata ai caratteri multi-byte. Le classi della libreria multi-byte hanno lo stesso nome delle classi ordinarie, con l’aggiunta del prefisso: “w”.<br />
Questo è lo schema di ereditarietà delle classi della libreria <code>iostream</code>:</p>
<pre><code>                              ios_base
                                 |
                             basic_ios
                                 |
               __________________|_________________       
              |                                    | 
              |                                    | 
        basic_istream                         basic_ostream
             | |                                  | |   
             | |                                  | |  
             | |__________________________________| |  
             |                   |                  |   
      _______|______             |         _________|_______       
     |              |            |        |                 | 
basic_istringstream |            |   basic_ostringstream    |
                    |            |                          |
                    |            |                          |
               basic_ifstream    |                  basic_ofstream
                                 |
                            basic_iostream
                         ________|________
                        |                 |
               basic_stringstream    basic_fstream
          </code></pre>
<p>A parte <code>ios_base</code>, queste sono tutte classi template che sono poi istanziate con parametri differenti per gestire la gestione dei tipi di carattere <code>char</code> and <code>wchar_t</code>. Per esempio, la classe <code>ostream</code> è una specializzazione della classe <code>basic_ostream</code>:</p>
<pre><code>typedef basic_ostream&lt;char&gt; ostream;</code></pre>
<p>Il suo corrispettivo multi-byte è la classe <code>wostream</code>:</p>
<pre><code>typedef basic_ostream&lt;wchar_t&gt; wostream;</code></pre>
<p>La classe template <code>basic_ostream</code>, a sua volta, deriva da <code>basic_ios</code>:</p>
<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ostream 
: virtual public std::basic_ios&lt;CharT, Traits&gt;</code></pre>
<p>che, a sua volta, deriva da <code>ios_base</code>:</p>
<pre><code>template&lt;
    class CharT,
    class Traits = std::char_traits&lt;CharT&gt;
&gt; class basic_ios 
: public std::ios_base  </code></pre>
<p>In sostanza: se davanti al nome c’è il prefisso <code>basic_</code>, si tratta della classe template; se c’è c’è la lettera “w”, si tratta della versione multi-byte, altrimenti è la classe ordinaria.<br />
Oltre alle classi derivate da <code>iosbase</code>, la libreria comprende anche delle classi per la gestione dei buffer di dati:</p>
<pre><code>                       basic_streambuf
                      ________|________
                     |                 |
               basic_stringbuf     basic_filebuf</code></pre>
<p>La classe template virtuale <code>basic_streambuf</code>, che fa parte della libreria, ma non della discendenza da <code>ios_base</code>, contiene i dati e le funzioni necessarie alla gestione di un buffer di caratteri. Le sue classi derivate <code>basic_stringbuf</code> e <code>basic_filebuf</code> sono invece specializzate, rispettivamente, nella gestione di buffer in memoria e su file. Anche in questo caso, la libreria comprende due versioni di ciascuna classe, specializzate per la gestione di <code>char</code> and <code>wchar_t</code>.</p>
<pre><code>typedef streambuf  basic_streambuf&lt;char&gt;
typedef wstreambuf basic_streambuf&lt;wchar_t&gt;
typedef filebuf    basic_filebuf&lt;char&gt;
typedef wfilebuf   basic_filebuf&lt;wchar_t&gt;</code></pre>
<p>Come forse avrai intuito, esaminare le singole classi della libreria <code>iostream</code> è un’attività che rivaleggia, in quanto a tedio, con l’epigrafia classica, ma ci permetterà di vedere applicati tutta una serie di principii di cui abbiamo parlato nelle lezioni precedenti, perciò, facciamoci forza e andiamo a incominciare.</p>
<hr />
<p>La classe <code id="ios-base">ios_base</code> e la sua prima discendente <code id="basic-ios">basic_ios</code> sono classi generiche che forniscono le funzioni di base per la gestione degli stream, indipendentemente dal fatto che si tratti di stream di input o di output.<br />
Una peculiarità di <code>ios_base</code> è che non possiede un costruttore pubblico, quindi non è possibile utilizzarla per creare oggetti, ma solo come base per delle classi derivate.<br />
Le istanze specializzate di <code>basic_ios</code> sono:</p>
<pre><code>typedef basic_ios&lt;char&gt;    ios;
typedef basic_ios&lt;wchar_t&gt; wios;</code></pre>
<p>Tramite i metodi di queste classi è possibile verificare o modificare lo stato interno dello stream, la sua formattazione o definire delle funzioni callback per la gestione dei dati.<br />
Il dato membro <code>openmode</code>, per esempio, definisce il modo in cui debba essere aperto lo stream:</p>
<table>
<tbody>
<tr class="odd">
<td><em>app</em></td>
<td>Fa sì che ogni operazione di output avvenga alla fine dello stream.</td>
</tr>
<tr class="even">
<td><em>ate</em></td>
<td>In apertura dello stream, sposta il punto di inserimento al termine (<em><strong>at e</strong>nd</em>) del buffer di I/O.</td>
</tr>
<tr class="odd">
<td><em>binary</em></td>
<td>Gestisce il contenuto dello stream come un flusso di dati binario.</td>
</tr>
<tr class="even">
<td><em>in</em></td>
<td>Permette operazioni di input.</td>
</tr>
<tr class="odd">
<td><em>out</em></td>
<td>Permette operazioni di output.</td>
</tr>
<tr class="even">
<td><em>trunc</em></td>
<td>Azzera il contenuto dello stream all’apertura.</td>
</tr>
</tbody>
</table>
<p>Il dato membro <code>iostate</code>, che utilizzeremo in uno dei prossimi esempii, contiene le informazioni sullo stato corrente dello stream:</p>
<table>
<tbody>
<tr class="odd">
<td><em>goodbit</em></td>
<td>Nessun errore</td>
</tr>
<tr class="even">
<td><em>eofbit</em></td>
<td>È stata raggiunta la fine dello stream.</td>
</tr>
<tr class="odd">
<td><em>failbit</em></td>
<td>L’ultima operazione di I/O è fallita.</td>
</tr>
<tr class="even">
<td><em>badbit</em></td>
<td>L’ultima operazione di I/O non era valida.</td>
</tr>
<tr class="odd">
<td><em>hardfail</em></td>
<td>Si è verificato un errore irrecuperabile.</td>
</tr>
</tbody>
</table>
<p>Entrambi questi dati membro sono delle <a href="/man/note#bitmask" class="xref">bitmask</a>, quindi possono contenere più di un valore. L’istruzione seguente, per esempio, apre uno stream su file combinando in <code>OR</code> tre possibili valori per <code>openmode</code>:</p>
<pre><code>fstream file_io(&quot;io.txt&quot;
               , ios_base::in | ios_base::out | ios_base::app);</code></pre>
<p>Dopo <code>basic_ios</code>, le classi della libreria si specializzano nell’input o nell’output: da un lato <code>basic_istream</code>, da cui derivano i due stream standard di input <code>cin</code> e <code>wcin</code>; dall’altro <code>basic_ostream</code>, da cui derivano gli stream standard di output <code>cout</code>, <code>cerr</code>, <code>clog</code> e le loro controparti “wide”: <code>wcout</code>, <code>wcerr</code>, <code>wclog</code>.<br />
Da queste due classi generiche derivano delle classi template specializzate nell’input o nell’output su file o in memoria:</p>
<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ifstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_istringstream 
: public basic_istream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_ofstream 
: public basic_ostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_ostringstream 
: public basic_ostream&lt;Elem, Tr&gt;</code></pre>
<p>e una classe capace di gestire entrambe le operazioni:</p>
<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_iostream 
: public basic_istream&lt;Elem, Tr&gt;
, public basic_ostream&lt;Elem, Tr&gt;</code></pre>
<p>anche questa, con due specializzazioni per la gestione di file e memoria:</p>
<pre><code>template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;, class Alloc = allocator&lt;Elem&gt;&gt;
class basic_stringstream 
: public basic_iostream&lt;Elem, Tr&gt;

template 
&lt;class Elem, class Tr = char_traits&lt;Elem&gt;&gt;
class basic_fstream 
: public basic_iostream&lt;Elem, Tr&gt;</code></pre>
<p>Prima che ci assalga un attacco di narcolessia, vorrei mettere in atto tutto questo con qualche esempio.<br />
Abbiamo già visto diversi esempii di output su stream:</p>
<pre><code>cout &lt;&lt; &quot;Hello World!&quot;  // stringhe
     &lt;&lt; 12              // interi
     &lt;&lt; 0.35            // float
     &lt;&lt; argv[1]         // puntatori
     &lt;&lt; endl;               </code></pre>
<p>Non abbiamo ancora parlato dell’input da stream, che però ha un funzionamento piuttosto simile:</p>
<pre><code>/** 
 * @file src/stream-input.cpp
 * Programma di esempio per la gestione dell&#39;input da stream.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    string stringa;
    
    /** Scrive un messaggio sullo schermo */
    cout &lt;&lt; &quot;Inserire una stringa: &quot;;
    
    /** Legge una stringa da tastiera */
    cin &gt;&gt; stringa;

    /** La scrive sullo schermo */
    cout &lt;&lt; stringa &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Questo codice legge una stringa dallo standard input e la scrive sullo schermo, ma ci mostra una peculiarità dell’input da stream:</p>
<pre><code>&gt; g++ src/cpp/stream-input-1.cpp -o src/out/esempio
&gt; src/out/esempio                                
Inserire una stringa: Penso, quindi sono.
Penso,</code></pre>
<p>Come vedi, le operazioni di lettura con l’operatore » si arrestano al primo carattere di spaziatura; perciò, se vogliamo leggere tutta la stringa, dobbiamo modificare il codice:</p>
<pre><code>/** 
 * @file src/stream-input-2.cpp
 * Programma di esempio per la gestione dell&#39;input da stream.
 */
 
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    char   buffer[256];
    string stringa;
    
    /** 
    *   Legge una stringa da tastiera tramite
    *   la funzione membro della classe istream.
    */
    cout &lt;&lt; &quot;Inserire una stringa: &quot;;
    cin.getline(buffer, 256);
    cout &lt;&lt; buffer &lt;&lt; endl;


    /** 
    *   Legge una stringa da tastiera tramite
    *   la funzione globale getline.
    */
    cout &lt;&lt; &quot;Inserire una stringa: &quot;;
    getline(cin, stringa);
    cout &lt;&lt; stringa &lt;&lt; endl;

    return 0;
}
</code></pre>
<pre><code>&gt; g++ src/cpp/stream-input-2.cpp -o src/out/esempio
&gt; src/out/esempio                                  
Inserire una stringa: Penso, quindi sono.
Penso, quindi sono.
Inserire una stringa: Cogito ergo sum.
Cogito ergo sum.</code></pre>
<p>Un’altra caratteristica degli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code> è che la loro precedenza è minore di quasi tutti gli altri operatori, il che vi consente di scrivere delle istruzioni come questa:</p>
<pre><code>cout &lt;&lt; &quot;Due più due fa: &quot; &lt;&lt; 2 + 2 &lt;&lt; &#39;\n&#39; ;</code></pre>
<p>Gli operatori logici di AND <code>|</code>, di OR inclusivo <code>&amp;</code> e di XOR esclusivo <code>^</code>, hanno una precedenza minore degli operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code> e, se non vengono isolate tra parentesi, le operazioni che li coinvolgono possono essere causa di errori. Per esempio, in un’istruzione come la seguente, l’operatore <code>&amp;</code> verrebbe interpretato come un riferimento a un oggetto, con conseguenze diverse da quelle attese:</p>
<pre><code>cout &lt;&lt; &quot;Il valore è: &quot; &lt;&lt; 2 &amp; 2 &lt;&lt; &#39;\n&#39; ; // ERRORE! </code></pre>
<p>la sintassi corretta è, invece:</p>
<pre><code>cout &lt;&lt; &quot;Il valore è: &quot; &lt;&lt; (2 &amp; 2) &lt;&lt; &#39;\n&#39; ;   // OK</code></pre>
<p>Il comportamento di default degli operatori di input da stream prevede anche delle convenzioni di for­mattazione:</p>
<ul>
<li><strong>il formato di conversione della base è decimale</strong>;</li>
<li><strong>il carattere di riempimento è lo spazio</strong>;</li>
<li><strong>la precisione delle cifre a virgola mobile è la stessa utilizzata da print­f()</strong>, con arrotondamento della sesta cifra decimale;</li>
<li><strong>la larghezza del campo ha valore di default 0</strong>, il che significa che lo stream di output utilizzerà tutti i caratteri necessari alla visualizzazione dell’intero valore o stringa.</li>
</ul>
<p>Le prime tre modifiche sono per­manenti: una volta impostati, i nuovi valori saranno validi fino a che un’altra istruzione non torni a modificarli; le modifiche alla larghezza del campo di input, invece, valgono solo per l’istruzione che le richiede.<br />
In alcuni esempii precedenti abbiamo visto che è possibile modificare il formato di output di default di uno stream tramite dei <em>maipolatori</em>:</p>
<pre><code>cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._h &lt;&lt; &quot;:&quot; 
     &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._m &lt;&lt; &quot;:&quot; 
     &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(2) &lt;&lt; ora._s &lt;&lt; endl;</code></pre>
<p>Lo stesso risultato si può ottenere per mezzo di apposite funzioni delle classi <code>ios_base</code> e <code>basic_ios</code>, che permettono di alterare il carattere di riempimento, la precisione delle cifre decimali e la larghezza del campo:</p>
<pre><code>/** 
 * @file src/stream-format.cpp
 * Formattazione dell&#39;I/O con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;


int main(int argc, char** argv)
{    
    double d = 123.456789 ;

    /** Mostra i valori di default */
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Valori di default&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;  width:     &quot;  &lt;&lt; cout.width()        &lt;&lt; endl;
    cout &lt;&lt; &quot;  precision: &quot;  &lt;&lt; cout.precision()    &lt;&lt; endl;  
    cout &lt;&lt; &quot;  fill:      &#39;&quot; &lt;&lt; cout.fill()  &lt;&lt; &quot;&#39;&quot; &lt;&lt; endl;    
    cout &lt;&lt; &quot;  output:    &quot;  &lt;&lt; d                   &lt;&lt; endl;

    /** Modifica il formato e mostra il nuovo output */
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Modifica formato&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;  output:    &quot;  ;
    cout.precision(4) ;
    cout.fill(&#39;#&#39;) ;
    cout.width(10) ;
    cout &lt;&lt; d &lt;&lt; endl;
    
    /** Mostra la persistenza dei valori */
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Valori correnti&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;  width:     &quot;  &lt;&lt; cout.width()        &lt;&lt; endl;
    cout &lt;&lt; &quot;  precision: &quot;  &lt;&lt; cout.precision()    &lt;&lt; endl;  
    cout &lt;&lt; &quot;  fill:      &#39;&quot; &lt;&lt; cout.fill()  &lt;&lt; &quot;&#39;&quot; &lt;&lt; endl;    
    cout &lt;&lt; &quot;  output:    &quot;  &lt;&lt; d                   &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, ottieni:</p>
<pre><code>&gt; src/out/esempio                                 

Valori di default
  precision: 6
  fill:      &#39; &#39;
  width:     0
  output:    123.457

Valori modificati
  output:    #####123.5

Valori correnti
  precision: 4
  fill:      &#39;#&#39;
  width:     0
  output:    123.5</code></pre>
<hr />
<p>Quando un’operazione di lettura o scrittura su stream fallisce, il valore del dato membro <code>iostate</code> assume un valore differente da zero. La classe basic_ios ha delle funzioni membro booleane che tornano <code>true</code> o <code>false</code> se il valore <code>iostate</code> indica un determinato evento e la funzione <code>rdstate</code> che torna il valore assoluto di <code>iostate</code>:</p>
<table>
<tbody>
<tr class="odd">
<td>good</td>
<td>nessun errore: il valore di <code>iostate</code> è 0</td>
</tr>
<tr class="even">
<td>eof</td>
<td>è stata raggiunta la fine del file</td>
</tr>
<tr class="odd">
<td>fail</td>
<td>c’è stato un errore di I/O non bloccante</td>
</tr>
<tr class="even">
<td>bad</td>
<td>c’è stato un errore di I/O bloccante</td>
</tr>
<tr class="odd">
<td>rdstate</td>
<td>torna il valore corrente di <code>iostate</code></td>
</tr>
</tbody>
</table>
<p>Queste funzioni permettono di interrompere la lettura o la scrittura di uno stream quando si verifica un errore o se si è raggiunta la fine del file. Una cosa che non devi fare mai, però, è di utilizzare la funzione <code>eof</code> all’interno di un ciclo <code>while</code> per la lettura di un file:</p>
<pre><code>/** 
 * @file src/stream-eof.cpp
 * Gestione dell&#39;I/O su file con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;
    int      n;
    
    /** apre il file in lettura */
    testo.open(argv[1]);
    
    /** Verifica che il file sia aperto */
    if(testo.is_open()) {
        
        /** Utilizza eof per gestire il ciclo */
        while(!testo.eof()) {

            /** Legge un numero dal file */
            testo &gt;&gt; n;

            /** Lo scrive a video */
            cout &lt;&lt; n &lt;&lt; endl;
        }
        
    }
        
    /** Chiude il file di input */
    testo.close();
    
    return 0;
}
</code></pre>
<p>Se fai leggere a questo programma un file che contenga i numeri: 10, 20 e 30, otterrai questo output:</p>
<pre><code>&gt; g++ src/cpp/stream-eof.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/stream-eof.txt       
10
20
30
30</code></pre>
<p>L’errore si verifica perché il controllo della funzione <code>eof</code> avviene prima della quarta operazione di lettura, quando lo stream è ancora in stato <code>good</code>. Un modo migliore di gestire questi casi è di utilizzare la funzione <code>good</code>, che ci permette di verificare anche la corretta apertura del file:</p>
<pre><code>/** 
 * @file src/stream-good.cpp
 * Gestione dell&#39;I/O su file con gli stream.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;
    int      n;
    
    /** apre il file in lettura */
    testo.open(argv[1]);
    
    /** 
    *   Il ciclo si ripete fino a che non 
    *   si verifica un errore
    */
    while(testo.good()) {

        /** Legge un numero dal file */
        testo &gt;&gt; n;

        /** Si interrompe se il file è finito */
        if(testo.eof()) break;
        
        /** Altrimenti, scrive il numero */
        cout &lt;&lt; n &lt;&lt; endl;
    }
                
    /** Chiude il file di input */
    testo.close();
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo programma, ottieni il risultato corretto:</p>
<pre><code>&gt; g++ src/cpp/stream-good.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/stream-eof.txt        
10
20
30</code></pre>
<hr />
<p>Le <em>eccezioni</em> permettono di gestire gli errori che avvengono durante l’esecuzione del programma. Quando succede qualcosa di anormale, il sistema <em>lancia</em> un’eccezione, ovvero trasferisce il controllo del processo dalla funzione corrente a blocchi di istruzioni specifici, chiamati <em>exception handler</em>. Perché tutto questo avvenga, il codice che genera l’errore deve essere racchiuso in un blocco <code>try</code>/<code>catch</code>:</p>
<pre><code>try {
    
    // codice che potrebbe dare errore
    
} catch (...) {

    //  istruzioni per la gestione dell&#39;errore
}</code></pre>
<p>Le eccezioni possono essere lanciate e gestite sia da codice specifico all’interno del programma, sia dai meccanismi automatici del C++:</p>
<pre><code>/** 
 * @file src/stream-eccezioni-1.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main(int argc, char** argv)
{    
    ifstream testo;

    /** 
    *   Fa sì che, se sia generata un&#39;eccezione 
    *   in caso di errore nella gestione del file.
    */
    testo.exceptions ( ios_base::failbit );

    /** Questa istruzione genererà un&#39;eccezione */
    testo.open(&quot;fileinesistente.txt&quot;);
    
    testo.close();
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, causerai un errore che, non essendo gestito dal programma, è gestito dalla funzione standard del C++:</p>
<pre><code>&gt; g++ src/cpp/stream-eccezioni-1.cpp -o src/out/esempio
&gt; src/out/esempio
libc++abi: terminating with uncaught exception of type
std::__1::ios_base::failure: ios_base::clear
: unspecified iostream_category error
zsh: abort      src/out/esempio</code></pre>
<p>Se però inseriamo il codice che apre il file in un blocco <code>try</code>/<code>catch</code> e definiamo un <em>handler</em> per la gestione degli errori in apertura dei file, il risultato sarà più controllato:</p>
<pre><code>/** 
 * @file src/stream-eccezioni-2.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        testo.exceptions ( ios_base::failbit );
        testo.open(&quot;fileinesistente.txt&quot;);        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; &quot;Errore in esecuzione&quot; &lt;&lt; endl;      
   
    }    
   
    return 0;
}
</code></pre>
<pre><code>&gt; g++ src/cpp/stream-eccezioni-2.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Errore in esecuzione</code></pre>
<p>Possiamo addirittura prevenire gli errori in apertura del file facendo sì che sia lo stesso programma a lanciare un’eccezione se si accorge che manca il nome del file nei parametri di avvio:</p>
<pre><code>/** 
 * @file src/stream-eccezioni-3.cpp
 * Programma di esempio per la gestione delle eccezioni.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;


int main(int argc, char** argv)
{    
    ifstream testo;

    try {
        
        /** Verifica che esista il nome del file da aprire */
        if(argc &lt; 2)
            throw &quot;Nome file mancante&quot;;
            
        testo.exceptions ( ios_base::failbit );
        testo.open(argv[1]);        
        testo.close();
        
    } catch(ios_base::failure e) {
     
        cerr &lt;&lt; &quot;Errore in esecuzione&quot; &lt;&lt; endl;      
   
    } catch(char const* msg) {
        
        cerr &lt;&lt; msg &lt;&lt; endl;
    }
   
    return 0;
}
</code></pre>
<p>In questo modo, il programma è in condizione di gestire tutti i possibili errori di esecuzione:</p>
<pre><code>&gt; g++ src/cpp/stream-eccezioni-3.cpp -o src/out/esempio
&gt; src/out/esempio                                      
Nome file mancante
&gt; src/out/esempio nomefile.txt
Errore in esecuzione</code></pre>
<p>La libreria standard del C++ ha una classe specifica per la gestione delle eccezioni:</p>
<pre><code>class exception {
public:
    exception () throw();
    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();
    virtual ~exception() throw();
    virtual const char* what() const throw();
}</code></pre>
<p>Definendo una classe derivata da <code>exception</code> con altri dati membro e una funzione <code>what</code> specializzate, è possibile gestire in maniera più strutturata le segnalazioni di errore. È quello che faremo nel prossimo esempio.</p>
<pre><code>/** 
 * @file src/stream-eccezioni-4.cpp
 * Programma di esempio per la gestione delle eccezioni.
 * Richiede, in input, il numero di caratteri da leggere 
 * e il path del file di input:
 *
 *    src/out/esempio &lt;n caratteri da leggere&gt; &lt;file di input&gt;
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;exception&gt;

using namespace std;

/** Codici e stringhe di errore */
#define ERR_NONE          0
#define ERR_PARAMETRI   -10
#define ERR_FILE_OPEN   -20
#define S_SINTASSI      &quot;USO: esempio &lt;n caratteri&gt; &lt;path file&gt;&quot;
#define S_ERR_PARAMETRI &quot;Errore nei parametri di input.&quot;
#define S_ERR_FILE_OPEN &quot;Impossibile aprire il file di input&quot;

/**
*   Definisce una classe derivata da exception
*   per la gestione degli errori.
*/
class Eccezione: public exception
{
private:
    int         _codice;
    const char* _errore;
public:

    /** Costruttore */
    Eccezione(int codice, const char* errore) 
    : _codice(codice), _errore(errore) {        
    }
    
    /** Funzione virtuale pura: va ridefinita */
    virtual const char* what() const throw() {
        return _errore;
    }

    /** Funzioni di interfaccia */
    int getCodice() { return _codice; }
    const char* getErrore() { return _errore; }

    /** Ridefinizione dell&#39;operatore di output */
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, Eccezione e){
        os &lt;&lt; e._codice &lt;&lt; &quot;: &quot; &lt;&lt; e._errore &lt;&lt; endl;
        return os;
    }
};

int main(int argc, char** argv)
{    
    ifstream testo;
    testo.exceptions ( ios_base::badbit );

    try {

        char c     = 0;
        int  letti = 0;
                    
        /** 
        *   Verifica che ci siano sia il nome del file di input 
        *   che il numero di caratteri da leggere.
        */
        if (argc &lt; 3) 
            throw Eccezione(ERR_PARAMETRI, S_ERR_PARAMETRI);
            
        /** Definisce il numero di caratteri da leggere */
        int da_leggere = atoi(argv[1]);
        
        /** 
        *   Imposta la exception mask dello stream per fare
        *   sì che un errore di I/O generi un&#39;eccezione,
        *   poi apre il file in lettura.
        *   Usa un blocco try/catch per intercettare una
        *   eventuale eccezione e gestirla in maniera
        *   omogenea al resto del codice.
        */
        try {
            testo.exceptions ( ios_base::badbit 
                             | ios_base::failbit );
            testo.open(argv[2]);            
        } catch(ifstream::failure e) {
            throw Eccezione(ERR_FILE_OPEN, S_ERR_FILE_OPEN);      
        }

        /**
        *   Re-imposta la exception mask per evitare
        *   eccezioni a fine file.
        */
        testo.exceptions ( ios_base::goodbit);

        /** 
        *   Legge il testo e lo stampa a video 
        *   Se è stato definito un numero massimo di 
        *   caratteri, si ferma lì.
        */
        while(testo.good()) {
            if((c = testo.get()) != EOF) {     
                letti++;
                cout &lt;&lt; c;
            } 
            if((da_leggere != 0) &amp;&amp; (letti &gt;= da_leggere)) {
                cout &lt;&lt; endl;
                break;
            }
        } 
                
        /** Chiude il file di input */
        testo.close();
            
    } catch (Eccezione e) {

        /** Stampa a video l&#39;eccezione */
        cerr &lt;&lt; e &lt;&lt; endl;

        /** Mostra la sintassi di chiamata **/
        cerr &lt;&lt; S_SINTASSI &lt;&lt; endl;
        
        /** Esce con un codice di errore */
        exit(e.getCodice());
    }
    
    return 0;
}
</code></pre>
<p>Se compili ed esegui questo codice, otterrai il seguente output, a seconda dei parametri forniti:</p>
<pre><code>&gt; g++ src/cpp/stream-eccezioni-4.cpp -o src/out/esempio
&gt; src/out/esempio                                      
-10: Errore nei parametri di input.
USO: esempio &lt;n caratteri&gt; &lt;path file&gt;

&gt; src/out/esempio 41                                   
-10: Errore nei parametri di input.
USO: esempio &lt;n caratteri&gt; &lt;path file&gt;

&gt; src/out/esempio 41 src/cpp/stream-input.txt          
Nacqui da famiglia ricca, ma troppo tardi

&gt; src/out/esempio 0 src/cpp/stream-input.txt 
Nacqui da famiglia ricca, ma troppo tardi.  
Secondogenito, vidi la florida impresa paterna andare in dote  
per diritto di nascita, ma anche per naturale inclinazione
ai miei monozigotici fratelli maggiori e, com&#39;è consuetudine 
per i figli cadetti, fui avviato alla vita monastica.
Entrai in seminario all&#39;età di nove anni e presi i voti il 
giorno del mio diciottesimo compleanno.
Conobbi il Maestro quattro anni dopo.  </code></pre>
<hr />
<p>Il Maestro Canaro diceva che una filosofia, per spingere i suoi seguaci a comportarsi in maniera corretta, deve possedere due caratteristiche: <em>trascendenza</em> e <em>permanenza</em>.<br />
Se, per un caso o per volere del Cielo, gli esempii che ti ho fatto finora prendessero coscienza di sé, senza però sapere di far parte di una serie di lezioni, probabilmente si sentirebbero inutili e sciocchi. Perfino l’ultimo esempio che abbiamo visto, che è il più complesso di tutti, non potrebbe fare a meno di chiedersi quale sia il senso della sua esistenza, dato che lo stesso risultato si può ottenere con una semplice istruzione da riga di comando:</p>
<pre><code>head -c 41 src/cpp/stream-input.txt</code></pre>
<p>Qualche esempio riuscirebbe comunque a fare il proprio dovere, ma ce ne sarebbero altri che reagirebbero male a questa epifania: i più deboli si deprimerebbero, mentre i più ambiziosi cercherebbero una compensazione nell’accumulo eccessivo di risorse di sistema: RAM, spazio disco o cicli CPU.<br />
Al contrario, se gli esempii sapessero di essere parte integrante di una serie di lezioni, tutto ciò che altrimenti appare insensato o inutile, dai commenti pleonastici fino al parametro numerico dell’ultimo esempio, acquisterebbe il giusto significato e ciascun esempio saprebbe di essere non solo utile, ma necessario.<br />
Se c’è una cosa che sappiamo per certa dell’Universo in cui viviamo è che si sta espandendo. Se nulla interverrà a mutare questo stato di cose, tutto ciò che esiste, dagli esseri viventi alle stelle, è destinato o prima o poi a spegnersi nella vittoria di Pirro dell’Entropia come un computer portatile a cui si scarichi la batteria.<br />
Al contrario, se la Gravità riuscirà a invertire il moto delle galassie, tutto ciò che esiste, dalle stelle agli esseri viventi, è destinato o prima o poi ad annichilirsi nell’Uno in attesa di un nuovo ciclo di esistenza.<br />
Questo, però, non basterà da solo a dare un senso alle nostre esistenze, perché, senza persistenza, le nostre azioni saranno come degli oggetti di classe <code>streambuf</code>: una volta spento il computer, non esisteranno più e tutto ciò che abbiamo fatto, giusto o sbagliato che sia, non avrà alcuna influenza su ciò che accadrà successivamente.<br />
L’unica cosa che può salvarci dall’oblio e dall’insensatezza sono i <code>Post-It</code>, la persistenza.<br />
Per dare un senso alla nostra esistenza abbiamo bisogno di un <em>hard-disk</em> su cui salvare gli stream delle nostre vite, in modo che ogni ciclo di esistenza possa fare tesoro delle esperienze passate. Senza di esso, Hitler varrà quanto Ghandi e Albert Schweitzer quanto Ted Bundy. Dovrà essere però un <em>hard-disk</em> meta-fisico, per sfuggire al <em>Big Crunch</em>, e questo ci riporta all’importanza della trascendenza.<br />
Se mi guardo indietro, per il mezzo secolo su cui ho visibilità diretta, vedo una lunga serie di fallimenti ideologici. Il Sessantotto ha spazzato via delle parti sicuramente rivedibili, ma fondamentali della nostra Società senza darci nulla in cambio, tranne la minigonna. La lotta armata degli anni settanta ha sparato alle persone sbagliate, mentre la <em>reaganomics</em> è crollata alla fine degli anni ‘80 insieme al muro di Berlino. Le speranze degli anni ‘90 si sono schiantate l’11 Settembre 2001 sulle Torri Gemelle e anche Internet, che nelle intenzioni iniziali sarebbe dovuta essere un mezzo per dare a tutti la possibilità di esprimere le proprie idee si è trasformata, nel tempo, in un sistema di controllo e di dis-informazione di massa.<br />
Quel poco che restava dei nostri valori e delle nostre idee è stato annichilito dagli <em>smart-phone</em> e dai <em>social-network</em>.<br />
Esiste un fattore comune alle ideologie degli ultimi cinquant’anni che ne ha accelerato l’obsolescenza e le ha rese incapaci di sopravvivere alla prima sconfitta: il rifiuto più o meno accanito di ogni forma non strumentale di spiritualità.<br />
Se si definisce uno schema di valori negando allo stesso tempo qualsiasi forma di trascendenza, si è costretti a ricercare i valori e le motivazioni della propria etica all’interno dello schema stesso. Si può fare, ma è sbagliato e limitativo. È sbagliato, perché le regole che si definiscono sono sempre una conseguenza di esigenze contingenti (guerre, sopraffazioni, disparità sociali), venendo a mancare le quali lo schema logico del sistema perde di significato e si disgrega. È limitativo, perché restringe il numero dei possibili obiettivi da perseguire a un insieme finito di azioni o traguardi, raggiunti i quali non esiste più possibilità di migliorare.<br />
Pensa al gioco degli Scacchi: non esiste nessun motivo, all’interno della scacchiera, che costringa ciascun pezzo a muoversi solo in una specifica maniera. Le torri si muovono in orizzontale, gli alfieri in diagonale e il cavallo salta con una traiettoria a “L” in ossequio a delle regole definite al di fuori della scacchiera<a href="/man/note#scacchi" class="nota"></a>, ma è proprio da queste limitazioni che deriva il fascino del gioco. Al contrario, la Società moderna è una scacchiera in cui ciascun pezzo si muove nella maniera che preferisce perché, in ossequio a un malinteso senso di libertà, sono state eliminate tutte le regole. Le persone di successo che si privano della vita sono pedoni che, arrivati alla fine della scacchiera grazie alla loro abilità, hanno scoperto che non esiste alcuna forma di promozione, perché insieme alle regole sono stati aboliti anche i giocatori.</p>
<hr />
<p>Il Maestro Canaro una volta mi disse:</p>
<blockquote>
<p>Io non credo alla storia della conversione. David Chapman ha ucciso John Lennon perché pensava che sopra di lui ci fosse “only sky” e che solo così, avrebbe potuto dare un senso alla sua esistenza.</p>
</blockquote>
</section>
</section>
<a href="/man/polimorfismo" class="left" title="Vai a: Il polimorfismo"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/debug" class="right" title="Vai a: Il debug"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/stream" class="left" title="Vai a: Gli stream"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/epilogo" class="right" title="Vai a: Epilogo"><em></em></a>
<section id="il-debug-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Il debug</a></h1>
<blockquote>
Cento Mondi di peccato sono dissipati dalla luce di un solo ticket
</blockquote>
<section class="testo">
<p>Il debug potrà non essere il senso della vita, come recita il titolo del tuo libro, ma è indubbiamente l’aspetto più importante della programmazione.<br />
Nella tua carriera di programmatore potrai non utilizzare mai una classe <em>functor</em> o ridefinire l’operatore <code>-&gt;</code>, ma sicuramente farai degli errori e li dovrai correggere. Malgrado ciò, i manuali di programmazione non parlano mai del <em>debug</em>. Si sono scritte migliaia di pagine sui diversi linguaggi di programmazione; non c’è primavera che non veda fiorire un nuovo paradigma di programmazione — strutturata, <em>object-oriented</em>, <em>agile</em>, <em>fuzzy</em> — eppure, nessuno si è mai preoccupato di formalizzare il processo di correzione del codice.</p>
<blockquote>
<p>La decadenza del software è iniziata quando le stampanti laser hanno soppiantato le vecchie stampanti ad aghi. Il codice non si può leggere su un foglio A4: a meno che non sia un programma banale, non c’entrerà né in altezza né in larghezza. Il modulo in continuo di una stampante ad aghi a 136 colonne, al contrario, ti permette di stampare tutto il tuo codice e di rileggerlo con calma; correggerlo, se necessario e migliorarlo se possibile. È così che si facevano le revisioni di codice, quando c’erano il tempo e i soldi per fare le revisioni di codice.</p>
</blockquote>
<p>Trascurare il debug è come affermare che non si faranno mai errori. Non importa quanto sia efficiente il linguaggio di programmazione; non importa quanto sia astuto e vigile il compilatore; non importa nemmeno quanto sia bravo il programmatore: o prima o poi, la distrazione, la stanchezza o un evento esterno permetteranno a un errore di intrufolarsi nel codice. Un puntatore utilizzato impropriamente, un ciclo in più o in meno in un’istruzione <code>for</code> o una virgola dimenticata fra i parametri di una <code>printf</code>: qualunque cosa sia, se il compilatore non sarà in grado di riconoscerla, finirà nel programma è resterà lì in attesa di produrre i suoi effetti dannosi. Il programma potrà funzionare correttamente per anni, ma poi, un bel giorno, qualcosa non andrà come sarebbe dovuto andare e a quel punto bisognerà analizzare il codice per trovare l’errore.<br />
Fare degli errori è inevitabile, ed è importante sapere come porvi rimedio. Ancora più importante, però, è sapersi accorgere degli errori. Così come <em>l’Ikebarba inizia nel negozio</em>, il debug comincia nel momento in cui si scrive il codice. Il modo migliore per evitare che il codice contenga degli errori è scrivere del buon codice. Scrivere del buon codice vuol dire fare sempre il meglio che ti è possibile. Non salvare mai un file se non sei certo che funzionerà come deve e cerca sempre di pensare a cos’altro potrebbe fare il tuo codice, oltre a quello che vuoi tu. Come di ho detto <a href="/man/programmatore#buon-programmatore" class="xref">in una delle nostre prime chiacchierate</a>, il Buon Programmatore non si accontenta della strada più rapida, ma cerca sempre quella più efficiente e sicura, perché sa che scrivere del buon codice costa meno che riparare del codice fatto male. Il Maestro Canaro, una volta disse:</p>
<blockquote>
<p>Il Buon Programmatore è come un marinajo che, prima di un lungo viaggio, verifica tutta la sua attrezzatura di coperta, smontando ogni singolo elemento e sostituendo tutto ciò che potrebbe rompersi, perché non sa cosa succederà una volta che sarà in mare.</p>
</blockquote>
<p>Il Buon Programmatore non può farne a meno, perché è nella sua natura; è questa, la differenza fra chi <em>fa</em> il programmatore e chi <em>è</em> un programmatore.</p>
<hr />
<p>Gli errori del software possono essere di tre tipi:</p>
<ul>
<li>gli errori che si manifestano durante la fase di compilazione;</li>
<li>gli errori che si manifestano durante l’esecuzione del programma;</li>
<li>gli errori di analisi.</li>
</ul>
<p>Gli <strong>errori di compilazione</strong> sono causati da costrutti incorretti, che bloccano il processo di creazione del programma. Un errore che farai spesso è di dimenticare il punto e virgola alla fine della dichiarazione di una classe:</p>
<pre><code>class C {
private:
    float _raggio;
    float _area;
public:
    C (int m) : _raggio(m) {}
    float getRaggio() { return _raggio; }
    float area() {
       Quadrato q;
       return 3.14159 * q(_raggio);
    }
}</code></pre>
<p>una banale distrazione che causerà immancabilmente il messaggio:</p>
<pre><code>&gt; g++ src/cpp/debug-errori.cpp  -c -o src/out/esempio 
src/cpp/debug-errori.cpp:28:2: error: expected &#39;;&#39; after class
}
 ^
 ;
1 error generated.</code></pre>
<p>Gli errori di compilazione sono i più facili da gestire, perché è il compilatore stesso a dirti quale sia il problema e in quale punto del codice si trovi. L’unica difficoltà che potresti avere, specie se stai lavorando con la <code>STL</code>, è decifrare i messaggi del compilatore:</p>
<pre><code>In file included from /Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/iostream:38:
In file included from /Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/ios:216:
In file included from /Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/__locale:15:
/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/string:2027:19: error: no viable conversion from
      &#39;const std::__1::basic_string&lt;char&gt;&#39; to &#39;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;,
      std::__1::allocator&lt;char&gt; &gt;::value_type&#39; (aka &#39;char&#39;)
        push_back(*__first);
/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/string:2075:5: note: in instantiation of function
      template specialization &#39;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;
      &gt;::__init&lt;std::__1::istream_iterator&lt;std::__1::basic_string&lt;char&gt;, char, std::__1::char_traits&lt;char&gt;, long&gt; &gt;&#39;
      requested here
    __init(__first, __last);
    ^
src/cpp/debug-errori.cpp:43:12: note: in instantiation of function template specialization
      &#39;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;
      &gt;::basic_string&lt;std::__1::istream_iterator&lt;std::__1::basic_string&lt;char&gt;, char, std::__1::char_traits&lt;char&gt;,
      long&gt; &gt;&#39; requested here
    string s(begin,end);
           ^
/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/string:876:5: note: candidate function
    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }
    ^
/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/string:1055:31: note: passing argument to parameter
      &#39;__c&#39; here
    void push_back(value_type __c);</code></pre>
<p>Se un costrutto è formalmente corretto, ma <em>potrebbe</em> essere un errore, il compilatore può segnalarlo con un <strong>warning</strong>, un messaggio di avviso che non blocca la compilazione, ma richiama l’attenzione del programmatore sull’anomalia.<br />
Ho usato il condizionale (<em>può segnalarlo</em>) perché la notifica dei <em>warning</em> è un’opzione che deve essere attivata dal programmatore, specificando, fra i parametri di compilazione, quali avvisi vuole ricevere. Dato che i parametri per attivare i diversi tipi di <em>warning</em> sono davvero tanti:</p>
<pre><code>-Waddress   
-Wbool-compare  
-Wbool-operation  
-Wchar-subscripts  
-Wcomment  
-Wformat   
-Wformat-overflow  
-Wformat-truncation  
-Wint-in-bool-context  
-Winit-self  
-Wlogical-not-parentheses 
-Wmaybe-uninitialized 
-Wmemset-elt-size 
-Wmemset-transposed-args 
-Wmisleading-indentation 
-Wmismatched-dealloc 
-Wmismatched-new-delete 
-Wmissing-attributes 
-Wmultistatement-macros  
-Wnarrowing   
-Wnonnull  
-Wnonnull-compare  
-Wopenmp-simd 
-Wparentheses  
-Wpessimizing-move   
-Wpointer-sign  
-Wrange-loop-construct   
-Wreorder   
-Wrestrict   
-Wreturn-type  
-Wsequence-point  
-Wsign-compare   
-Wsizeof-array-div 
-Wsizeof-pointer-div 
-Wsizeof-pointer-memaccess 
-Wstrict-aliasing  
-Wstrict-overflow=1  
-Wswitch  
-Wtautological-compare  
-Wtrigraphs  
-Wuninitialized  
-Wunknown-pragmas  
-Wunused-function  
-Wunused-label     
-Wunused-value     
-Wunused-variable  
-Wvolatile-register-var  
-Wzero-length-bounds</code></pre>
<p>e che possono essere tutti rilevanti nel processo di creazione del codice, la cosa migliore che puoi fare è di attivarli globalmente, con il parametro: <code>-Wall</code></p>
<pre><code>/** 
 * @file src/debug-errori-warning.cpp
 * Tipi di errore e di warning.
 */

#include &lt;iostream&gt;

using namespace std;

class Quadrato
{
public:
    double operator()(double x) { return x * x; }
};

class C {
private:
    float _raggio;
    float _area;
public:
    C (int m) : _raggio(m) {}
    float getRaggio() { return _raggio; }
    float area() {
       Quadrato q;
       return 3.14159 * q(_raggio);
    }
};

int main(int argc, char** argv) 
{
    C c(10);    
    cout &lt;&lt; c.area() &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>Se compili questo codice senza attivare i <em>warning</em>, il compilatore non ti segnala nulla di anomalo:</p>
<pre><code>&gt; g++ src/cpp/debug-errori-warning.cpp -c -o src/out/esempio
&gt; </code></pre>
<p>Se però aggiungi il parametro <code>-Wall</code> alla riga di comando, scopri che il parametro <code>_area</code> della classe <code>C</code> non viene utilizzato:</p>
<pre><code>&gt; g++ src/cpp/debug-errori-warning.cpp -Wall -c -o src/out/esempio
src/cpp/debug-errori-warning.cpp:19:11: 
    warning: private field &#39;_area&#39; is not used 
        [-Wunused-private-field]
    float _area;
          ^
1 warning generated.</code></pre>
<p>Il codice è stato compilato, perché questa potrebbe essere una scelta intenzionale, ma il sistema ti notifica comunque l’anomalia, in modo che tu possa decidere se mantenerla o eliminarla.<br />
Aggiungendo il parametro <code>-Wextra</code>, ottieni un <em>warning</em> aggiuntivo perché i parametri della funzione <code>main</code> non sono utilizzati:</p>
<pre><code>&gt; g++ src/cpp/debug-errori-warning.cpp -Wall -Wextra -o src/out/esempio
src/cpp/debug-errori-warning.cpp:29:14: 
    warning: unused parameter &#39;argc&#39; 
        [-Wunused-parameter]
int main(int argc, char** argv) 
             ^
src/cpp/debug-errori-warning.cpp:29:27: 
    warning: unused parameter &#39;argv&#39; 
        [-Wunused-parameter]
int main(int argc, char** argv) 
                          ^
src/cpp/debug-errori-warning.cpp:19:11: 
    warning: private field &#39;_area&#39; is not used 
        [-Wunused-private-field]
    float _area;
          ^
3 warnings generated.</code></pre>
<p>Oltre a quelli definiti dai parametri <code>-Wall</code> e <code>-Wextra</code>, il compilatore prevede una lunga lista di <em>warning</em> che possono essere definiti individualmente, a seconda delle esigenze del programma. Per esempio, il parametro <code>-Wdouble-promotion</code> segnala quando una variabile di tipo <code>float</code> è promossa implicitamente a <code>double</code>:</p>
<pre><code>&gt; g++ src/cpp/debug-errori-warning.cpp -Wall -Wextra \
    -Wdouble-promotion -c -o src/out/esempio
src/cpp/debug-errori-warning.cpp:25:27: 
    warning: implicit conversion increases 
        floating-point precision: &#39;float&#39; to
      &#39;double&#39; [-Wdouble-promotion]
       return 3.14159 * q(_raggio);
                        ~ ^~~~~~~
src/cpp/debug-errori-warning.cpp:29:14: 
    warning: unused parameter &#39;argc&#39; [-Wunused-parameter]
int main(int argc, char** argv) 
             ^
src/cpp/debug-errori-warning.cpp:29:27: 
    warning: unused parameter &#39;argv&#39; [-Wunused-parameter]
int main(int argc, char** argv) 
                          ^
src/cpp/debug-errori-warning.cpp:19:11: 
    warning: private field &#39;_area&#39; is not used 
        [-Wunused-private-field]
    float _area;
          ^
4 warnings generated.</code></pre>
<p>Molti programmatori ignorano i <em>warning</em>, pensano che se il programma può essere compilato non ci sia nient’altro di cui preoccuparsi. Tu non fare questo errore: nessun avviso deve essere ignorato.</p>
<hr />
<p>Solo un programma formalmente ineccepibile può dare luogo a <strong>errori di esecuzione</strong>. Se non fosse formalmente ineccepibile, infatti, non sarebbe stato compilato e non potrebbe essere eseguito.<br />
Gli errori di esecuzione sono tanto più pericolosi quanto più i loro effetti sono lievi. Un errore che causi il blocco del sistema sarà certamente rilevato e corretto; al contrario, un leggero errore di calcolo potrebbe passare inosservato e quindi causare grandi problemi.<br />
Se dimentichi l’operatore di incremento all’interno di un ciclo <code>while</code> produrrai un ciclo infinito, che certamente attirerà la tua attenzione:</p>
<pre><code>/** 
 * @file pianeti-while-errore.cpp
 * Gestione dei Pianeti con errore evidente.
 */
 
#include &lt;iostream&gt;
#include &quot;pianeti.h&quot;

using namespace std;

int main(int argc, char** argv)
{    
    int    p  = POS_MERCURIO;
    string nome;

    while (!(nome = nomePianeta(p)).empty()) {
        cout &lt;&lt; nome &lt;&lt; endl;
    }
        
    return 0;
}
</code></pre>
<pre><code>&gt; g++ src/cpp/pianeti-while-errore-1.cpp \
      src/cpp/pianeti-2.0.cpp \
   -o src/out/esempio
&gt; src/out/esempio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
Mercurio
...</code></pre>
<p>Se invece incrementi la variabile nel modo sbagliato:</p>
<pre><code>/** 
 * @file pianeti-while-errore.cpp
 * Gestione dei Pianeti con errore nel ciclo while
 */
 
#include &lt;iostream&gt;
#include &quot;pianeti.h&quot;

using namespace std;

int main(int argc, char** argv)
{    
    int    p  = POS_MERCURIO;
    string nome;

    while (!(nome = nomePianeta(++p)).empty()) {
        cout &lt;&lt; nome &lt;&lt; endl;
    }
        
    return 0;
}
</code></pre>
<p>causerai un errore che, in questo caso, è evidente, perché all’elenco manca Mercurio, ma che in un programma più complesso potrebbe essere difficile da individuare:</p>
<pre><code>&gt; g++ src/cpp/pianeti-while-errore-2.cpp \
      src/cpp/pianeti-2.0.cpp \
   -o src/out/esempio
&gt; src/out/esempio
Venere
Terra
Marte
Giove
Saturno
Urano
Nettuno
Plutone</code></pre>
<p>Gli errori di esecuzione possono essere di due tipi: quelli che si manifestano in maniera deterministica e quelli che si manifestano in maniera casuale. L’errore nell’elenco dei pianeti si manifesterà a ogni esecuzione del programma e sarà quindi (relativamente) facile da individuare. Al contrario, questo codice produrrà un errore solo in determinate condizioni:</p>
<pre><code>/** 
 * @file debug-errore-stocastico.cpp
 * Errore che si verifica solo in deterinate circostanze.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

#define ERR_FILE_NONE       -10
#define ERR_FILE_OPEN       -20
#define S_ERR_FILE_NONE     &quot;Definire un file di input&quot;
#define S_ERR_FILE_OPEN     &quot;Impossibile aprire il file di input&quot;
#define N_CHAR_MIN          300
#define N_BANNER_MAX        3
#define PUNTO               &#39;.&#39;

/**
*   Aggiunge un banner dopo ogni punto, 
*   ogni N_CHAR_MIN caratteri.
*/
int banner_testo(ifstream&amp; testo)
{
    int  n_banner = 1;
    int  letti = 0;
    char c = 0;
 
    /** 
    *  Legge tutto il contenuto del file di input
    */
    while(testo.good()) {
        
        /** 
        *   Legge il cotenuto del file, 
        *   carattere per carattere 
        */
        if((c = testo.get()) != EOF) {            

            /** Incrementa il numero di caratteri letti */
            letti++;

            /** Scrive il carattere letto */
            cout &lt;&lt; c;            

            /** 
            *   Se il carattere corrente è un punto
            *   e ha letto almeno N_CHAR_MIN caratteri
            *   e ha ancora banner da aggiungere, 
            *   inserisce il codice del banner nel testo. 
            */
            if(c == PUNTO 
            &amp;&amp; letti &gt;= N_CHAR_MIN 
            &amp;&amp; n_banner &lt;= N_BANNER_MAX) {                
                cout &lt;&lt; endl 
                     &lt;&lt; &quot;&lt;div id=\&quot;banner-&quot; 
                     &lt;&lt; n_banner 
                     &lt;&lt; &quot;\&quot;&gt;&lt;/div&gt;&quot; 
                     &lt;&lt; endl;
                n_banner++;
                letti = 0;
            }
        }       
    } 
    
    cout &lt;&lt; endl;
    
    return n_banner;
} 
 
int main(int argc, char** argv)
{    
    ifstream testo;
    
    /** Verifica che ci sia il nome del file di input */
    if(argc &lt; 2) {
        cerr &lt;&lt; S_ERR_FILE_NONE &lt;&lt; endl;
        exit(ERR_FILE_NONE);
    }
    
    /** Apre il file in lettura */
    testo.open(argv[1]);
    if(!testo.good()) {
        cerr &lt;&lt; S_ERR_FILE_OPEN &lt;&lt; endl;
        exit(ERR_FILE_OPEN);
    }

    /** Elabora il testo */
    banner_testo(testo);
    
    /** Chiude il file */
    testo.close();
    
    return 0;
}
</code></pre>
<p>La funzione <code>banner_testo</code> inserisce il <em>tag</em> HTML di un banner all’interno del testo di una pagina Web. I banner devono essere posizionati dopo un punto fermo, a distanza di almeno <code>N_CHAR_MIN</code> caratteri l’uno dall’altro.<br />
Questo codice funziona correttamente con alcuni tipi di testo:</p>
<blockquote>
Essere un ossessivo-compulsivo con una leggera tendenza alla paranoia, se ti guadagni da vivere facendo l’esperto di sicurezza, è un bene; le medesime peculiarità caratteriali, al contrario, sono decisamente un male quando alle 21:55 la tua donna di servizio ti scrive: "Ho fatto un molecolare e sono risultata positiva.
<div id="banner-1">

</div>
Non potrai farti un tampone prima delle 8:00 dell’indomani quindi sai che ti aspettano almeno dieci ore di panico controllato; qualcuna di meno, se riesci ad addormentarti. Cerchi di distrarti guardando la televisione, ma l’ennesimo thriller con Jason Statham, intervallato da pubblicità di ansiolitici (un conflitto di interessi che ti riprometti di studiare con più attenzione, se sopravvivi), non fa che aumentare la tua agitazione; così, spegni il televisore, ti prepari una tisana relax, leggi un po’ e poi cerchi di dormire.
<div id="banner-2">

</div>
</blockquote>
<p>Il codice della funzione <code>banner_testo</code>, però, è troppo ottimistico e delle piccole variazioni nel file di input, come l’aggiunta di punti di sospensione o di una URL, <em>potrebbero</em> causare degli errori nel posizionamento dei banner:</p>
<blockquote>
Essere un ossessivo-compulsivo con una leggera tendenza alla paranoia, se ti guadagni da vivere facendo l’esperto di sicurezza, è un bene; le medesime peculiarità caratteriali, al contrario, sono decisamente un male quando alle 21:55 la tua donna di servizio ti scrive: "Ho fatto un molecolare e sono risultata positiva".
<div id="banner-1">

</div>
.. Non potrai farti un tampone prima delle 8:00 dell’indomani quindi sai che ti aspettano almeno dieci ore di panico controllato. Qualcuna di meno, se riesci ad addormentarti. Cerchi di distrarti guardando la televisione, ma l’ennesimo thriller con Jason Statham, intervallato da pubblicità di ansiolitici (un conflitto di interessi che ti riprometti di studiare con più attenzione, se sopravvivi), non fa che aumentare la tua agitazione; così, spegni il televisore, ti prepari una tisana relax, &lt;a href="http://chiplusplus.
<div id="banner-2">

</div>
org"&gt;leggi un po’&lt;/a&gt; e poi cerchi di dormire.
</blockquote>
<p>Questo tipo di errori possono aspettare anni, prima di venire alla luce. Per esempio, un errore nella valutazione di una data in coincidenza con gli anni bisestili potrebbe aspettare quattro anni prima di manifestarsi; nel frattempo, il codice sarà stato distribuito agli utenti e chi lo ha scritto ne avrà perso memoria o potrebbe addirittura aver cambiato lavoro.<br />
La correzione dell’errore della funzione <code>banner_testo</code>, se fatta per tempo, richiederebbe solo l’aggiunta di una condizione all’istruzione <code>if</code>, per verificare che il punto si trovi prima di un a capo:</p>
<pre><code>if(c == PUNTO 
&amp;&amp; letti &gt;= N_CHAR_MIN 
&amp;&amp; n_banner &lt;= N_BANNER_MAX
&amp;&amp; testo.peek() == A_CAPO) { 
    cout &lt;&lt; endl 
         &lt;&lt; &quot;&lt;div id=\&quot;banner-&quot; &lt;&lt; n_banner &lt;&lt; &quot;\&quot;&gt;&quot;
         &lt;&lt; &quot;&lt;/div&gt;&quot; 
         &lt;&lt; endl;
    n_banner++;
    letti = 0;
}</code></pre>
<p>La stessa correzione, fatta dopo che il programma è andato in esercizio, potrebbe richiedere giorni, se non settimane, perché dovrà essere ripetuto tutto il processo di rilascio del sistema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">attività</th>
<th style="text-align: center;">ore/uomo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">creazione di un ambiente di test</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">debug</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">correzione dell’errore</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">test funzionale</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">test di carico</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">test di sicurezza</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">collaudo</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;">rilascio/distribuzione</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Al costo di queste attività vanno ovviamente aggiunti i possibili danni derivanti dal mancato funzionamento del sistema, che potrebbero facilmente essere pari a un mese se non a un anno di stipendio del programmatore.<br />
Devi pensare a tutto questo, quando scrivi codice, perché hai una responsabilità sia nei confronti del tuo datore di lavoro che degli utenti del sistema, che potrebbero essere anche i tuoi amici o i tuoi parenti.<br />
Se lavori male per la Coca-Cola, puoi sempre pensare: “Chi se ne frega, io bevo Pepsi”; non è etico, ma almeno non è auto-lesionista. Se però lavori male per lo Stato, stai peggiorando la tua vita e di tutte le persone che conosci e questo, oltre a non essere etico, è anche stupido.</p>
<hr />
<p>Gli <strong>errori di analisi</strong> sono una conseguenza dell’Annosa Dicotomia — e dell’inesperienza dell’analista, ovviamente.<br />
Come tutti gli esseri senzienti, anche i clienti possono essere vittime dell’Annosa Dicotomia fra ciò che desiderano e ciò di cui realmente hanno bisogno. Un cliente che espone le sue esigenze è come un bambino che dice alla madre cosa vuole mangiare. Lo stimolo è reale — appetito o fame che sia —, ma il modo in cui lui vorrebbe placarlo non è necessariamente il più corretto; anzi: di solito è un desiderio indotto dal callido servitore dell’Entropia: il Marketing.<br />
Il cliente ha diritto di comportarsi in questo modo: ciascuno di noi fa la stessa cosa quando entra in un negozio; come analista, però, non devi permettere che i tuoi giudizi siano influenzati dai desiderii del tuo cliente. In questo, l’Analisi è assimilabile a una disciplina mistica: così come il Buddha dà a ciascuna persona con cui viene in contatto ciò di cui ha bisogno, tu devi annullare te stesso e <em>diventare</em> l’altro, pensare come lui, sentire le sue necessità. Da quello che dice e da come lo dice, devi riuscire a distinguere i suoi bisogni dai suoi desiderii, evitando che l’ottenimento di questi ultimi intralci il buon successo del progetto.<br />
Ovviamente, dovrai anche evitare che i <em>tuoi</em> desiderii intralcino o rallentino il progetto. Così come influenza le opinioni del tuo cliente, il Marketing può influire su di te, spingendoti a scegliere una tecnologia di moda, ma inadatta allo scòpo che devi raggiungere. Fà attenzione che ciò non accada. Sorveglia costantemente le tue scelte; così come il Buon Programmatore, pensa sempre su più livelli e confrontati con altri colleghi o con il tuo superiore per essere certo di aver fatto le scelte giuste. Non vergognarti dei tuoi errori: sono i mattoni su cui edificherai la tua esperienza.<br />
Sii anche preparato a dover fare degli errori. O prima o poi, capiterà che un cliente ti chieda di fare una scelta che tu ritieni sbagliata. Quando ciò accadrà, dovrai per prima cosa cercare di convincerlo dell’errore, spiegandogli perché la sua richiesta non sia corretta. Se non ci riesci, ripeti la tua opposizione, perché sia chiaro che la tua non è un’ipotesi, ma una certezza, però non insistere oltre: sia perché questo potrebbe creare degli attriti con il tuo interlocutore, sia perché alla lunga potresti scoprire che è lui ad avere ragione.<br />
Se non riuscirai a convincere il cliente di un suo errore, dovrai portare a termine ciò che ti chiede, ma al contempo dovrai fare in modo che le conseguenze di quella scelta non possano essere attribuite a te in futuro. Dato che le conseguenze nefaste di un errore architetturale potrebbero manifestarsi dopo mesi o anche anni dalla fase di analisi, non limitarti a <em>dire</em> al cliente che si sbaglia, ma scrivilo, in modo che resti traccia della tua opposizione.<br />
Il tuo peggior nemico, in questi casi, sarà il tuo orgoglio. Una volta, il Maestro Canaro mi disse:</p>
<blockquote>
<p>Quando ero un giovane <em>project-manager</em> e discutevo con i miei clienti, cercavo sempre di dimostrare loro che avevo ragione; ora cerco solo di far ciò che dev’essere fatto.</p>
</blockquote>
<hr />
<p>Parafrasando Iacopone da Todi, un programma per il debug può aiutarti a identificare il punto del tuo codice che genera un errore, ma devi prima capire quale sia la funzione da esaminare, perché fare il debug di tutto il codice di un programma, nei casi in cui questo sia possibile, sarebbe lungo ed estremamente frustrante.<br />
Il modo in cui è stato scritto il codice lo renderà più o meno facile da verificare. Immagina che il problema sia la variabile <code>x</code>: se tutto il tuo codice ha la possibilità di modificarne il valore, potresti dover esaminare ogni singola funzione per verificare che non ne faccia un uso improprio. Al contrario, se la variabile <code>x</code> può essere modificata solo alcuni punti del codice, la tua sarà una ricerca più mirata e veloce. È per questo motivo, che <a href="/man/istruzioni-iterative#isolamento-funzionale" class="xref">nella lezione sulle funzioni iterative</a> abbiamo diviso l’elaborazione dei dati dalla gestione dell’interfaccia utente: perché in questo modo, a seconda del tipo di errore che dovesse presentarsi — di calcolo o di output — sapremo quale funzione andare a guardare.<br />
Alcune caratteristiche del C++, come la <a href="/man/note.html#tipizzazione" class="xref">tipizzazione forte</a> e l’<a href="/man/note.html#incapsulamento" class="xref">incapsulamento</a> potranno esserti di aiuto in questo senso, ma non sempre saranno sufficienti a identificare il punto esatto in cui il tuo codice fa qualcosa di errato. In questi casi, dovrai procedere per tentativi, scomponendo il tuo programma in parti sempre più piccole, in modo da ridurre il numero di righe di codice da verificare. Un modo rapido per farlo è di mettere a commento tutte le chiamate nella funzione <code>main</code> ripristinandole poi a una a una, fino a che non individuerai quella in cui è contenuto l’errore:</p>
<pre><code>int main(int argc, char** argv)
{    
    ifstream testo;        
        
    verifica_parametri(argc, argv);
    apri_file(testo, argv[2]);            
/*
    elabora_file(testo);
    chiudi_file(testo);
*/    
    return 0;
}</code></pre>
<p>Se la <em>funzione che non funziona</em> è troppo complessa per farne un debug diretto, ripeterai il processo, mettendo a commento le sue chiamate fino a che la quantità di codice da esaminare sarà ragionevolmente poca.<br />
Un altro modo in cui puoi semplificare la ricerca degli errori nel codice è l’aggiunta di messaggi che ti permettano di sapere quale operazione sta compiendo il programma:</p>
<pre><code>int apri_file(ifstream&amp; testo, const char* path)
{
#ifdef __LOG__    
    log(LOG_DEBUG, 2, &quot;Apro il file: &quot;,  path);
#endif

    testo.open(path);
    return ERR_NONE;
} </code></pre>
<p>La funzione <code>log</code> è quella che abbiamo visto nella <a href="/man/funzioni.html#parametri-variabili" class="xref">lezione sulle funzioni con parametri variabili</a> e ci permette di conoscere il nome del file che viene aperto durante l’esecuzione del programma.<br />
Queste funzioni di tracciatura sono utili nella fase di debug, ma rallentano l’esecuzione del programma perché richiedono l’accesso a un dispositivo esterno, sia esso lo schermo del computer o un file sul disco rigido. Per questo motivo, è bene avere la possibilità di disabilitarle nella versione definitiva del programma. In questo caso, l’abbiamo fatto inserendo la chiamata in una direttiva <code>ifdef</code> del precompilatore, in modo che venga inserita nel codice solo se è definita la costante <code>__LOG__</code>. Dato che si tratta di una costante che non viene utilizzata dal codice, ma che serve solo per modificare il modo in cui è compilato il programma, possiamo definire <code>__LOG__</code> direttamente nella linea di comando del compilatore:</p>
<pre><code>&gt; g++ sorgente.cpp -D __LOG__ -o eseguibile</code></pre>
<hr />
<p>Quando l’errore si manifesterà — di solito pochi minuti prima che tu debba smettere di lavorare per uscire o fare qualcos’altro — e tu dovrai identificarne la causa, il primo problema che avrai sarà di riuscire a riprodurre le condizioni in cui si manifesta. Come abbiamo visto poco fa, se l’errore dipende dai dati in input, per identificare il problema, dovrai capire quali sono i dati che lo generano; qualche volta sarà facile, ma in altri casi potrà rivelarsi estremamente complesso.<br />
Diversi anni or sono, il Maestro Canaro dovette registrarsi su un sito Web che gli chiese anche la sua data di nascita — che, come sai, fu il 29 Febbraio del 1964 . La maschera di inserimento nuovo utente non gli diede problemi, ma la maschera di modifica dati, evidentemente scritta da un programmatore meno esperto, non gli permise di aggiornarli perché, a suo dire, la data di nascita era sbagliata. Ciò vuol dire che il sistema utilizzava due funzioni distinte per il controllo della data di nascita, una nella funzione di inserimento e un’altra nella funzione di modifica, e che almeno la funzione utilizzata in modifica non era una funzione standard, ma codice scritto <em>ad-hoc</em>.<br />
Entrambe queste scelte sono errori: a una determinata azione sui dati deve corrispondere una singola funzione. Fare la stessa operazione con parti di codice distinte è sbagliato; sia perché aumenta la probabilità di commettere degli errori, sia perché rallenta i tempi di identificazione dell’errore in fase di debug. È sbagliato anche riscrivere delle funzioni che già esistono: D. J. Bernstein lo fece, con le funzioni di I/O di <a href="http://cr.yp.to/djb.html">qmail</a>, ma la sua fu una precisa scelta architetturale perché voleve delle funzioni che fossero migliori e più sicure delle funzioni della libreria standard.<br />
A questi due errori di programmazione — inammissibili, in un sito che gestisca transazioni economiche — si aggiunge una profonda sciatteria della fase di debug del codice, perché la corretta gestione dei casi particolari, come gli anni bisestili, va sempre verificata. Quando verifichi il funzionamento di un programma, non puoi limitarti a controllare che faccia ciò che deve fare, ma devi anche assicurarti che non faccia ciò che non deve fare. In particolare, devi verificare che si comporti correttamente se:</p>
<ul>
<li>gli fornisci i dati di input corretti;</li>
<li>non gli fornisci alcun dato;</li>
<li>gli fornisci dati errati;</li>
<li>gli fornisci dati in eccesso.</li>
</ul>
<p>Quindi, se l’input è una data, dovrai verificare che il tuo sistema gestisca correttamente sia il valore <code>29-02-1964</code> che il valore <code>29-02-1965</code>; se l’input è una stringa di testo, dovrai accertarti che il sistema gestisca correttamente anche il caso in cui riceva più caratteri del previsto e che elimini eventuali caratteri di spazio all’inizio o alla fine del testo, a meno che questo non sia un requisito funzionale.</p>
<hr />
<p>In questo programma, una piccola cosa non è stata fatta come si dovrebbe e ne è derivato un errore:</p>
<pre><code>/** 
 * @file src/debug-gestione-errori.cpp
 * Modalità di gestione degli errori.
 */
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;exception&gt;

using namespace std;

/** Codici e stringhe di errrore */
#define LOG_DEBUG         1
#define LOG_AVVISO        2
#define LOG_ERRORE        3
#define ERR_NONE          0
#define ERR_FILE_NONE   -10
#define ERR_FILE_OPEN   -20
#define ERR_FILE_READ   -30
#define S_DEBUG         &quot;DEBUG&quot;
#define S_AVVISO        &quot;AVVISO&quot;
#define S_ERRORE        &quot;ERRORE&quot;
#define S_ERR_FILE_NONE &quot;Definire un file di input&quot;
#define S_ERR_FILE_OPEN &quot;Impossibile aprire il file di input&quot;
#define S_ERR_FILE_READ &quot;Impossibile leggere il file di input&quot;

/**
*   Definisce una classe derivata da exception
*   per la gestione degli errori.
*/
class Eccezione: public exception
{
private:
    int         _codice;
    const char* _errore;
public:

    /** Costruttore */
    Eccezione(int codice, const char* errore) 
    : _codice(codice), _errore(errore) {        
    }
    
    /** Funzione virtuale pura: va ridefinita */
    virtual const char* what() const throw() {
        return _errore;
    }

    /** Funzioni di interfaccia */
    int getCodice() { return _codice; }
    const char* getErrore() { return _errore; }

    /** Ridefinizione dell&#39;operatore di output */
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, Eccezione e){
        os &lt;&lt; e._codice &lt;&lt; &quot;: &quot; &lt;&lt; e._errore &lt;&lt; endl;
        return os;
    }
};

/** Funzione di gestione degli errori */
void errore(int codice, bool exit = true)
{
    const char* errore = NULL;

    /** 
    *   Identifica la stringa di errore corrispondente 
    *   al codice di errore ricevuto.
    */
    switch(codice) {
        case ERR_FILE_NONE: errore = S_ERR_FILE_NONE; break;
        case ERR_FILE_OPEN: errore = S_ERR_FILE_OPEN; break;
        case ERR_FILE_READ: errore = S_ERR_FILE_READ; break;
    }

    /** Se ne trova una, lancia un&#39;eccezione */
    if(errore != NULL){
        Eccezione e(codice, errore);
        throw e;
    }
}

/** 
*   Questa è la funzione di log che abbiamo visto 
*   nella lezione sulle funzioni.
*/
void log(int livello, int n_parametri, ...)
{        
    /** Definisce il livello del messaggio */
    const char* s_livello; 
    switch(livello) {
        case LOG_DEBUG:  s_livello = S_DEBUG ; break;
        case LOG_AVVISO: s_livello = S_AVVISO; break;
        default:         s_livello = S_ERRORE; break;
    }
    
    /** Scrive il testo del messaggio */
    cerr &lt;&lt; &#39;[&#39; &lt;&lt; s_livello &lt;&lt; &quot;] &quot;;

    /** Scrive i parametri della lista */
    va_list lista_parametri;
    va_start(lista_parametri, n_parametri);
    for(int p = 1; p &lt;= n_parametri; p++) {        
        cerr &lt;&lt; va_arg(lista_parametri, char*) ;        
    }    
    va_end(lista_parametri);

    cerr &lt;&lt; endl;
}

/** Verifica la presenza dei parametri di avvio */
int verifica_parametri(int argc, char** argv)
{
    return (argc &lt; 2) ? ERR_FILE_NONE : ERR_NONE;
} 

/** Apre il file in lettura */
int apri_file(ifstream&amp; testo, const char* path)
{
/**
*   Questo codice viene compilato solo se
*   è definita la macro __LOG__
*/    
#ifdef __LOG__    
    log(LOG_DEBUG, 2, &quot;Apro il file: &quot;,  path);
#endif

    testo.open(path);
    return ERR_NONE;
} 

/** Legge il file di input e lo scrive a video */
int elabora_file(ifstream&amp; testo)
{
    int  letti = 0;
    char c = 0;
    while ((c = testo.get()) != EOF) {            
        letti++;
        cout &lt;&lt; c;            
    } 
    return letti;
} 

/** Chiude il file di input */
void chiudi_file(ifstream&amp; testo)
{
    testo.close();
} 
 
int main(int argc, char** argv)
{    
    ifstream testo;
    
    try {
        
        int esito = ERR_NONE;
        
        /** 
        *   Verifica che ci sia il nome del file di input 
        *   e gestisce eventuali errori.
        */
        esito = verifica_parametri(argc, argv);
        errore(esito);
        
        /** 
        *   Imposta la exception mask dello stream per fare
        *   sì che un errore di I/O generi un&#39;eccezione,
        *   poi apre il file in lettura.
        *   Usa un blocco try/catch per intercettare una
        *   eventuale eccezione e gestirla in maniera
        *   omogenea al resto del codice.
        *   Non può aggiungere una catch in fondo perché
        *   l&#39;eccezione non dà informazioni sulla causa 
        *   dell&#39;errore che l&#39;ha generata.
        */
        try {
            testo.exceptions ( std::ifstream::badbit 
                             | std::ifstream::failbit );
            esito = apri_file(testo, argv[2]);            
        } catch(ifstream::failure e) {
            errore(ERR_FILE_OPEN);            
        }
        
        /** 
        *   Elabora il testo e gestisce eventuali errori.
        *   Dato che la funzione torna il numero di 
        *   caratteri letti, deve chiamare errore solo
        *   se non ce ne sono.
        */
        testo.exceptions ( std::ifstream::goodbit);
        if(elabora_file(testo) == 0) {
            errore(ERR_FILE_READ);            
        }
        
        
        /** Chiude il file di input */
        chiudi_file(testo);
    
    } catch (Eccezione e) {
        cerr &lt;&lt; e;
        exit(e.getCodice());
    }
    
    return 0;
}
</code></pre>
<p>In ossequio a quanto abbiamo detto poco fa, per verificare il funzionamento di questo programma dovremo fare almeno quattro prove:</p>
<pre><code># dati corretti
src/out/esempio src/cpp/debug-testo-1.txt 

# nessun dato
src/out/esempio 

# dati errati
src/out/esempio src/cpp/file-inesistente 

# dati in eccesso
src/out/esempio src/cpp/debug-testo-1.txt abcdefghilmenopqrstuvz  </code></pre>
<p>Dobbiamo poi verificare che tutte le condizioni di errore siano gestite correttamente. Nel nostro caso, gli errori previsti sono:</p>
<pre><code>#define ERR_FILE_NONE   -10
#define ERR_FILE_OPEN   -20
#define ERR_FILE_READ   -30</code></pre>
<p>I primi due errori sono verificati dalle prove standard; il terzo caso lo possiamo verificare passando al programma un file vuoto:</p>
<pre><code>src/out/esempio src/cpp/debug-vuoto.txt </code></pre>
<p>Sfortunatamente, però, se compili ed esegui questo codice con i dati corretti, ottieni un errore, anche se il file esiste:</p>
<pre><code>&gt; g++ src/cpp/debug-gestione-errori.cpp -o src/out/esempio
&gt; src/out/esempio src/cpp/debug-testo-1.txt               
-20: Impossibile aprire il file di input
&gt; ls src/cpp/debug-testo-1.txt 
src/cpp/debug-testo-1.txt</code></pre>
<p>Se ri-compili il programma definendo la macro <code>__LOG__</code> per verificare quale sia il file che il programma sta aprendo:</p>
<pre><code>#ifdef __LOG__    
    log(LOG_DEBUG, 2, &quot;Apro il file: &quot;,  path);
#endif</code></pre>
<p>quando esegui i programma, ottieni un nuovo errore:</p>
<pre><code>&gt; g++ src/cpp/debug-gestione-errori.cpp -D __LOG__ -o src/out/esempio 
&gt; src/out/esempio src/cpp/debug-testo-1.txt                           
[DEBUG] Apro il file: zsh: segmentation fault  src/out/esempio src/cpp/debug-testo-1.txt</code></pre>
<p>Questo non è il comportamento atteso dalla funzione, ma ci permette comunque di capire quale possa essere il problema. L’errore: <code>segmentation fault</code> vuol dire che il programma sta cercando di accedere a un’area di memoria che non gli appartiene. L’area di memoria in questione è quella associata al parametro <code>path</code>, che a sua volta è stato inizializzato con il valore della variabile <code>argv[2]</code>:</p>
<pre><code>esito = apri_file(testo, argv[2]);</code></pre>
<p>Il <em>bug</em> è l’indice <code>2</code> nell’array <code>argv</code>. Come certamente avrai notato, il codice di questo programma è una rielaborazione del codice della <a href="/man/stream.html" class="xref">lezione sugli stream</a>, che doveva gestire tre parametri da riga di comando. Stavolta, però, la stringa di chiamata del programma ha solo due valori: il path del programma e il nome del file di input:</p>
<pre><code>&gt; src/out/esempio src/cpp/debug-testo-1.txt</code></pre>
<p>Riutilizzare il codice è una cosa buona; scordarsi di modificare il valore dell’indice dell’array <code>argv</code> è una cosa sbagliata, perché l’indirizzo di memoria puntato da <code>argv[2]</code>, adesso, non appartiene al programma: non possiamo utilizzarlo come path per una funzione <code>open</code> e non possiamo stamparlo a video.<br />
Se correggiamo l’indice, il programma gestisce correttamente tutte le condizioni d’uso:</p>
<pre><code>&gt; g++ src/cpp/debug-gestione-errori.cpp \
    -D __LOG__ \
    -o src/out/esempio
&gt; src/out/esempio
-10: Definire un file di input

&gt; src/out/esempio src/cpp/file-inesistente
[DEBUG] Apro il file: src/cpp/file-inesistente
-20: Impossibile aprire il file di input

&gt; src/out/esempio src/cpp/debug-vuoto.txt
[DEBUG] Apro il file: src/cpp/debug-vuoto.txt
-30: Impossibile leggere il file di input

&gt; src/out/esempio src/cpp/debug-testo-1.txt
[DEBUG] Apro il file: src/cpp/debug-testo-1.txt
Essere un ossessivo-compulsivo con una leggera tendenza ...</code></pre>
<p>Questo errore di distrazione è stato facilitato dall’utilizzo di una costante numerica per la definizione dell’indice dell’array. Scrivere direttamente un numero o una stringa nel codice è sicuramente più rapido e allettante che definire delle costanti per il precompilatore:</p>
<pre><code>#define PARAM_PATH 1
...
esito = apri_file(testo, argv[PARAM_PATH]);</code></pre>
<p>ma, sul lungo periodo, è controproducente perché rende il codice più complesso da leggere e da modificare.<br />
<em>Più complesso da leggere</em> perché le costanti aiutano a capire cosa faccia il codice. Se leggi l’istruzione:</p>
<pre><code>return (argc &lt; 2) ? ERR_FILE_NONE : ERR_NONE;</code></pre>
<p>puoi capire cosa faccia anche se non conosci il codice. Se invece leggi la stessa istruzione, ma senza le costanti:</p>
<pre><code>return (argc &lt; 2) ? -10 : 0;</code></pre>
<p>per capire cosa faccia dovrai andare a leggere la documentazione del programma, posto che ce ne sia una.<br />
<em>Più complesso da modificare</em> perché l’utilizzo di costanti al posto di valori <em>hard-coded</em> permette di cambiare il valore di una costante agendo in un solo punto:</p>
<pre><code>#define ERR_NONE  1 </code></pre>
<p>Se non avessimo usato una costante, per ottenere lo stesso risultato avremmo dovuto modificare tre istruzioni distinte:</p>
<pre><code>return (argc &lt; 2) ? ERR_FILE_NONE : ERR_NONE;

...

return ERR_NONE;

...

int esito = ERR_NONE;</code></pre>
<p>In un programma più complesso del nostro esempio, le modifiche sarebbero state sicuramente di più e più difficili da identificare; inoltre, se ce ne fossimo dimenticata una (probabile), avremmo introdotto un errore nel sistema.<br />
Le costanti <em>hard-coded</em> possono essere utilizzate solo nella prima fase dello sviluppo del programma, quando non sei ancora sicuro che la strada che hai scelto sia quella giusta. In questa fase è ammissibile che tu faccia delle prove inserendo dei valori direttamente nel codice, ma quando l’algoritmo sarà ragionevolmente stabile, dovrai convertire tutti i valori in costanti.</p>
<hr />
<blockquote>
<p>Un sistema è una casa che, subito dopo costruita e adornata, ha bisogno (soggetta com’è all’azione corroditrice degli elementi) di un lavorio più o meno energico, ma assiduo, di manutenzione, e che a un certo momento non giova più restaurare e puntellare, e bisogna gettare a terra e ricostruire dalle fondamenta. Ma con siffatta differenza capitale: che, nell’opera del pensiero, la casa perpetuamente nuova e sostenuta perpetuamente dall’antica, la quale, quasi per opera magica, perdura in essa.<a href="/man/note#croce" class="nota"></a></p>
</blockquote>
<p>O prima o poi, la tua vita andrà in errore, come il software.<br />
Non importa quanto tu sia stato prudente o quale sia il tuo <em>Karma</em>: a un certo punto la terra sotto i tuoi piedi comincerà a franare e tu cadrai giù, lungo la montagna che stavi scalando, ritrovandoti al punto di partenza. Quello che farai in quel momento deciderà del resto della tua vita e ti farà capire che tipo di uomo sei — o che donna, visto che queste cose non succedono solo ai maschietti.<br />
Comincia a prepararti da adesso a quel momento, perché, quando avverrà (<em>quando</em>, non: <em>se</em>), probabilmente sarai solo e prendere delle decisioni sarà molto difficile perché avrai perso ogni fiducia in te stesso. Se ti rompi una gamba, o un braccio, il tuo cervello ti può dire se stanno guarendo o peggiorando, ma se batti la testa non è facile capire come stai, perché l’organo in esame e l’organo esaminatore coincidono. Allo stesso modo, se non ti fidi di te stesso, è difficile capire se le scelte che fai sono corrette. La paura o la prudenza potrebbero spingerti a non fare la scelta giusta, quindi, per prima cosa, dovrai fare il <em>debug</em> della tua vita per capire se e in quale misura devi biasimarti per ciò che è avvenuto; fatto ciò, dovrai identificare i tuoi errori e trovare un modo per non ripeterli.<br />
L’approccio più comune è di guardarsi indietro e cercare di capire quali siano state le proprie colpe, considerando queste degli eventi isolati in un’esistenza fatta prevalentemente di scelte corrette. Dato però che ciascuno di noi tende — più o meno inconsciamente —, a cercare cause esogene alle sue sventure inventandosi complotti o trasferendo le proprie responsabilità a terzi, la cosa migliore, in questi casi, è di adottare l’atteggiamento opposto e partire dal presupposto che <em>tutto</em> ciò che è successo di male nella tua vita sia una tua colpa, per poi individuare i casi in cui ciò che è successo, in effetti, non è dipeso da te. Questo approccio <em>bottom-down</em><a href="/man/note#bottom-down" class="nota"></a> ha due pregi: il primo è che, analizzando gli eventi passati potresti scoprire che alcune colpe che ti attribuivi non erano reali; il secondo è che sarà più difficile mentire a te stesso. Ciascuno di noi ha una parte di responsabilità in ciò che gli succede, anche negli eventi che non genera direttamente. Assumersi a priori la colpa di tutto il male che ci è successo rende più difficile mentirci e ci permette di identificare tutte le nostre colpe, per piccole che siano.<br />
Attenzione, però: non devi pensare alle tue colpe come se fossi un inquisitore del tredicesimo Secolo, ma come se fossero dei <em>bug</em> nel programma della tua vita. Qualcuna genererà degli errori, altre solo dei <em>warning</em> e il tuo dovere è quello di identificarne il più possibile, per poi cercare di correggerle per migliorare il funzionamento del sistema.</p>
<blockquote>
<p>Il cambiamento inizia quando si intraprende un nuovo sentiero , anche se questo sentiero non è che una traccia lasciata da una capra assetata che ha trovato una sorgente.<a href="/man/note#deen" class="nota"></a></p>
</blockquote>
<p>Contrariamente a quello che avviene con il software, non sempre è possibile correggere i <em>bug</em> della nostra esistenza. Si può modificare un aspetto deteriore del nostro carattere, ma non è detto che sia possibile rimediare ai danni che questo ha causato a noi o a terzi. Per fare un paragone con il debug del software, i difetti caratteriali sono errori di compilazione, mentre gli effetti dei nostri sbagli sono errori di esecuzione; i primi li possiamo correggere, gli errori di esecuzione, no: ormai è andata. Quello che possiamo e che dobbiamo fare, però, è di <a href="/man/istruzioni-condizionali#pentimento" id="pentimento" class="xref">pentircene sinceramente</a>, ovvero riconoscerli come errori, in modo da evitare di ripeterli nei prossimi cicli di esistenza.<br />
Anche se non possiamo cancellare gli effetti di un nostro errore, possiamo comunque chiedere perdòno a coloro i quali abbiamo arrecato danno. Non basterà chiedere scusa: si chiede scusa quando ciò che hai fatto non dipende da te, come quando qualcuno di urta e tu versi il tuo vino sul vestito del vicino; se invece il vino glielo hai tirato addosso intenzionalmente, dovrai chiedere <em>perdòno</em>, cercare per quanto possibile di riparare all’errore fatto e non commetterlo mai più, né con lui (o lei) né con altri.<br />
Non sottovalutare il potere terapeutico del perdono, anche se ci saranno dei casi in cui non lo otterrai. Se è vero che non si può cambiare il passato per qualcuno che abbiamo ferito, è altrettanto vero che si può provare a compensare il danno fatto rendendogli migliore il presente o il futuro. Le persone a cui facciamo del male sono spesso quelle a cui siamo più legati; far sapere loro che che non li abbiamo dimenticati e che ciò che è successo ci addolora, può servire a ricucire delle ferite; dall’una e dall’altra parte.</p>
<hr />
<p>Quando ripenserai a ciò che ti è avvenuto in passato, come un buon analista, dovrai cercare di immedesimarti nelle persone con cui hai avuto a che fare, capire le loro ragioni al di là di eventuali rancori o recriminazioni. Per fare ciò, dovrai tenere a mente alcuni fattori che influenzano il comportamento di tutti noi. Il primo, ovviamente, è l’influenza dell’Annosa Dicotomia, che, per mano del suo lacché il Marketing, spinge le persone a soddisfare i proprii desiderii invece che i proprii bisogni, creando degli schemi di valori fallaci e spingendoli a dimenticare che esistono per tutti la vecchiaia e la morte.<br />
Il secondo fattore da considerare è la natura umana; ricorda:</p>
<blockquote>
<p>Non cercare di spiegare con la malizia quello che può essere spiegato con la stupidità.</p>
</blockquote>
<p>O, per dirla con De Santillana:</p>
<blockquote>
<p><a href="/man/note#stoltezza" class="nota"></a></p>
</blockquote>
<p>Per derimere le questioni relative ai rapporti di coppia, invece, l’approccio più sicuro è quello antropologico. Come diceva il Maestro Canaro:</p>
<blockquote>
<p>Cento anni di femminismo non possono battere centomila anni di evoluzione.</p>
</blockquote>
<p>Secondo lui, qualsiasi comportamento anomalo nell’ambito di una coppia può essere spiegato tenendo a mente tre principii:</p>
<ol>
<li>le donne sono incubatrici parlanti;<br />
</li>
<li>gli uomini sono dispenser di sperma;<br />
</li>
<li>ogni eccesso nasconde un eccesso di natura opposta e pari entità.</li>
</ol>
<p>Parafrasando quel senza Dio di Dawkins, noi siamo l’<em>hard-disk</em> dei nostri geni, la memoria di massa che garantisce loro una persistenza. Il nostro software può variare, ma il <a href="/man/note#firmware" class="xref">firmware</a> che definisce il nostro comportamento a basso livello è immutato da migliaia di anni e ci spinge a fare ciò per cui siamo stati creati, ovvero riprodurci.<br />
Né le sovrastrutture culturali che abbiamo inventato, né gli idoli ai cui piedi ci prostriamo e nemmeno l’Annosa Dicotomia possono modificare la nostra ROM. Ignorare o, peggio, ribellarsi a questo stato di fatto è il primo passo verso la rovina o l’infelicità o entrambe le cose.</p>
<hr />
<p>Ecco: questo è tutto. Ricorda però: ciò che ti ho insegnato non è un punto di arrivo, ma un punto di partenza. La fine del cammino che abbiamo percorso insieme coincide con l’inizio del cammino che percorrerai da solo. Da questo momento in poi tu hai il dovere di diffondere le idee che ti ho trasmesso e, allo stesso tempo, di metterle costantemente alla prova per emendarle dai molti errori che certamente avrò commesso, così come il Maestro Canaro prima di me. Così come agli antichi Cristiani era vietato adorare gli idoli, io ti vieto di adorare le parole. Scrivi il tuo libro, se lo desideri, ma che non sia un libro stupido; fa’ in modo che lo si possa correggere facilmente, se necessario, in modo che ciò che afferma sia sempre il punto più vicino alla verità che tu possa raggiungere, perché l’oggetto dei tuoi sforzi dev’essere sempre la verità, non la tradizione.<br />
Noi viviamo prevalentemente sulla terraferma e riteniamo perciò che la normalità sia questa. Se però si trascorre un lungo periodo di tempo su una nave o in un’isola, si ha modo di capire come la normalità sia l’acqua e la terra sia solo un’eccezione. Similmente, noi diamo grande importanza al ciclo di nascita, riproduzione e morte che chiamiamo “vita” e in essa vediamo il fine ultimo dell’Universo, dimenticandoci che la vita è solo un caso particolare di esistenza e che un universo di sassi sarebbe comunque prodigioso.<br />
Ciascuna forma di vita consociata, per poter sopravvivere, richiede la legittimazione di alcune follie biologiche. Il rispetto di queste follie, essendo in-naturale, richiede l’istituzione di un livello superiore di costrizione, ovvero un corpo di regole formali ancora più distante del precedente dal comportamento biologico degli esseri viventi. Con il passare del tempo, molte di queste convenzioni nate in seguito a esigenze contingenti, finiscono inevitabilmente per contrastare con il senso comune di giustizia e devono essere o abolite o modificate, solo che ciascuna modifica o adattamento invece di renderle più “giuste”, le allontana ulteriormente dal loro scòpo iniziale e le rende soggette a interpretazioni errate o addirittura opposte a quelle che era il loro fine primario.<br />
Sant’Agostino ha detto la stessa cosa, ma molto meglio di quanto stia facendo io adesso.<br />
Si vede che era sobrio.</p>
</section>
</section>
<a href="/man/stream" class="left" title="Vai a: Gli stream"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/epilogo" class="right" title="Vai a: Epilogo"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/debug" class="left" title="Vai a: Il debug"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/ringraziamenti" class="right" title="Vai a: Ringraziamenti"><em></em></a>
<section id="epilogo-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Epilogo</a></h1>
<blockquote>
Dopo di me, il reboot
</blockquote>
<section class="testo">
<p>Fu uno dei confratelli ad avvisarmi. Aprì la porta della mia cella senza nemmeno bussare, una sagoma nera contro la luce del corridoio alle sue spalle.<br />
«Il vecchio si è sentito male, lo hanno portato in infermeria,» disse. «È meglio che ti sbrighi se lo vuoi salutare, non credo che gli resta molto tempo.»<br />
Avrei dovuto essergli grato, per aver pensato ad avvisarmi, invece lo odiai, sia per la notizia che per l’errore nel congiuntivo. Mi alzai e mi vestii al buio, pensando a quanto sono astuti i Benedettini che dormono vestiti e che non devono inquinare la drammaticità di momenti simili con pensieri come: “Dove ho messo le mutande?”.<br />
Appena ebbi qualcosa addosso, uscii di corsa e, a piedi nudi, scesi in infermeria. Indugiai prima di aprire la porta così come avevo indugiato davanti alla porta della sua cella la prima volta che ero andato a cercarlo. Quando alla fine mi feci coraggio e l’aprii, lo vidi sdraiato su uno dei letti in fondo alla stanza. Era appena un’increspatura sul piano della coperta, ma la coperta — notai con un certo sollievo —, si muoveva leggermente, seguendo il flusso del suo riespiro. Lui si accorse della mia presenza (o forse sapeva che sarei arrivato) e, con un filo di voce disse:<br />
«Toh! guarda chi si vede: Nino lo studente..»<br />
Stava morendo, probabilmente era l’ultima volta che ci vedevamo e mi salutava con una battuta di un film di Nino D’Angelo. Odiaii anche lui, ma per poco; giusto il tempo di capire perché l’aveva fatto.<br />
«Sei contento, ora?» mi chiese il Maestro.<br />
«Di cosa?» chiesi, e aggiunsi: «No, non sono contento. Perché dovrei essere contento?» Il Maestro fece due respiri prima di rispondere.<br />
«Hai il tuo libro, no? Ti ho insegnato tutto quello che so; non servo più a nulla.»<br />
Non capivo: voleva dire che stava morendo a causa mia?<br />
«Non capisco,» dissi. «Vuol dire che sta morendo a causa mia?»<br />
(Non so se ci avete fatto caso, ma quando muore qualcuno che amiamo, i pensieri e le frasi tendono a diventare meno letterarii e più elementari.)<br />
«Tutto quello che ti ho insegnato, pensavi che scherzassi? Siamo qui per uno scopo; quando non serviamo più, possiamo essere rimossi.» Tossì, poi riprese: «L’operatore <code>delete</code>, ricordi? Bisogna liberare la memoria, altrimenti il programma non avrà più spazio per girare.»<br />
Lo avevo ucciso io? Davvero? Sentii il cuore pulsarmi nelle orecchie e guardai con cupidigia uno sfigmo-manometro poggiato su uno dei tavoli dell’infermeria; chissà quanto avevo di pressione.<br />
«Il Cielo non fa favoritismi: per lui, siamo tutti preziosi e inutili allo stesso tempo, come la Regina in una partita di Scacchi. È il pezzo più importante, dopo il Re, ma un buon giocatore non ha problemi a sacrificarlo, se questo gli permette di vincere la partita.»<br />
Mi fece cenno di dargli un po’ d’acqua; bevve, poi riprese a parlare.<br />
«O forse no. Ti è mai passato per la testa, che tutta questa teoria potrebbe essere sbagliata? Che potrei essere davvero pazzo, come dicono i tuoi confratelli? Wittgenstein a trent’anni, definì una filosofia che egli stesso rinnegò dieci anni dopo, a favore di un nuovo credo. Se fosse vissuto per altri dieci anni, avrebbe cambiato ancora idea? La storia dell’Umanità è costellata di idee bizzarre, ciascuna con il suo bravo seguito di fedeli; cosa ti fa pensare, che il C’hi++ sia diverso? Il fatto che possa dare una risposta razionale e coerente ad alcuni fenomeni che altrimenti sarebbero senza spiegazione non vuol dire necessariamente che corrisponda a verità. Sì, certo: i suoi assiomi sembrano trovare conferma nella realtà, ma questo cosa conta? Potremmo essere noi, che non ci accorgiamo degli errori. Abbiamo creduto per centinaja di anni che il Sole girasse intorno alla terra e anche quella era un’ipotesi confortata dai fatti, almeno apparentemente.»<br />
Sorrise del mio sguardo perplesso, poi riprese a parlare;<br />
«Sta’ tranquillo: non sono pazzo, ma tu non pensare che quello che ti ho insegnato sia scienza. C’hi++ non è né scienza né religione, anche se ogni tanto finge di essere o l’una o l’altra cosa. Cerca la Verità, come la scienza e prova dare un significato alla nostra esistenza, come la religione, ma non può dimostrare ciò che afferma, come la scienza, e non vuole che tu lo accetti per forza, come la religione. Lo scòpo del C’hi++ è aiutarci a vivere meglio, quindi, quello che ti devi chiedere non è se le tesi dello Spazionismo siano corrette, ma se quello che ti ho insegnato ti rende la vita migliore o no.»<br />
Bevve un altro sorso di acqua, poi, con gli occhi chiusi, disse:<br />
«Il tuo maestro sta morendo e tu sei visibilmente addolorato, quindi è un ottimo momento per verificarlo. Va’ fuori, guarda in alto e chiediti se quello che ti ho insegnato rende questo momento meno difficile da affrontare.»<br />
Replicai che non mi sembrava il caso: pioveva ed ero a piedi nudi, ma era solo parte del problema: in realtà non volevo lasciarlo perché mi sembrava che le sue condizioni stessero rapidamente peggiorando.<br />
«È l’ultima cosa che ti chiedo. Davvero me la vuoi negare?»<br />
Mi arresi: uscii fuori, sotto la pioggia, e guardai in alto, come mi era stato ordinato di fare. La luna e le stelle erano nascoste dalle nuvole e comunque la pioggia colpiva i miei occhi impedendomi di vedere con chiarezza. Ciò non ostante, o forse proprio per questo motivo, non abbassai lo sguardo e lasciai che le gocce di pioggia si confondessero con le lacrime. Fu così che capii. Quelle gocce di acqua che adesso erano pioggia, erano state, prima, vapore acqueo e mare e fiume e prima ancora — per quello che ne potevo sapere — sangue, sudore, piscio, ghiaccio, vino, muscoli, piante, saliva, fango, calce o cemento. A qualunque cosa si fossero legate, nella loro esistenza precedente, adesso erano di nuovo acqua, ed erano pronte per un altro ciclo di vita. Il calore del sole le aveva portate in alto, ora la gravità le riportava in basso, verso il mare.<br />
Tornai nella cella del Maestro per dirgli che avevo capito, ma la coperta non si muoveva più.<br />
“Non importa”, pensai. “Glielo dirò la prossima volta”.</p>
<hr />
<p>Questa è la poesia funeraria del Maestro. Una poesia funeraria “ready-made”, come la definiva lui, perché il testo è quello della poesia funeraria del monaco Zen Gesshu Soko. Il Maestro la tradusse in Tedesco quando scoprì che il verbo <em>zu Treffen</em> può significare sia: <em>incontrarsi</em> che: <em>fare centro</em>.</p>
<blockquote>
Einatmen, Ausatmen,<br />
Vorwärts gehen, Rückwärts gehen,<br />
Leben, sterben, kommen, gehen.<br />
Wie zwei Pfeile, die sich im Flug treffen.<br />
Mitten im Nichts,<br />
Eine Straße, die direkt zu meinem wirklichen Zuhause führt.
</blockquote>
</section>
</section>
<a href="/man/debug" class="left" title="Vai a: Il debug"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/ringraziamenti" class="right" title="Vai a: Ringraziamenti"><em></em></a>
</div>
<div class="page capitolo">
<a href="/man/epilogo" class="left" title="Vai a: Epilogo"><em></em></a> <a href="/" class="center" title="Torna alla home-page"><em></em></a> <a href="/man/indice" class="center" title="Torna all&#39;indice del Manuale"><em></em></a> <a href="/man/note" class="right" title="Vai a: Note"><em></em></a>
<section id="ringraziamenti-1" class="corpo pubblicato" role="main">
<h1><a href="#dottrina">Ringraziamenti</a></h1>
<blockquote>

</blockquote>
<section class="testo">
<p>A mia madre, per la favola del Cavallo Fuggito e per aver piantato il seme da cui è nato tutto questo. A mio padre, per avermi insegnato a distinguere uno scrittore onesto da uno disonesto, anche quando lo scrittore sono io. A Wayne, per avermi regalato il libro, dicendo: «Read it. It changed my life». A Claudio, per avermi insegnato a programmare i computer e per Coomarawsami. A Manuela, per Musashi. Al Cane Lele, per avermi aiutato a capire.</p>
</section>
</section>
<a href="/man/epilogo" class="left" title="Vai a: Epilogo"><em></em></a> <a href="#top" title="Torna all&#39;inizio"><em></em></a> <a href="/man/note" class="right" title="Vai a: Note"><em></em></a>
</div>
</main>
</body>
</html>
