<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Il polimorfismo |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Il polimorfismo" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    <a title="Vai a: L'ereditarietà" 
        
        href="/man/ereditarieta" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Gli stream" 
        
        href="/man/stream" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Il polimorfismo
            </h1>

            <blockquote class="motto">When Me they fly, I am the wings<br />I am the double and the int</blockquote>

            <section id="testo">

                <p>Come avrai certamente intuito da tutto ciò che abbiamo detto finora, la caratteristica principale del C++ è il polimorfismo.</p>

<p>Avevamo iniziato a parlarne durante la <a href="/man/c-plus-plus#polimorfismo" class="xref">lezione introduttiva sul C++</a> e l’avevamo illustrato con un esempio che, a questo punto, non dovrebbe più avere segreti, per te:</p>

<pre><code>/** 
 *  @file src/cplusplus-template.cpp
 *  Esempio utlizzo dei template di classi.
 */

#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;list&gt;

using namespace std;

/** Definisce due nuovi tipi di dato */
typedef time_t Data;
typedef enum _sesso {
    maschio = 'm',
    femmina = 'f'
} Sesso;

/** Definisce una classe base per la gestione degli animali */
class Animale {
private:
    string _razza;
    Sesso  _sesso;
public:
    /** Costruttori di copia e parametrico */
    Animale() {}
    Animale(const char* razza, const Sesso sesso ) {
        _razza  = razza;
        _sesso  = sesso;
    }
    /** Funzione virtuale pura: rende la classe "astratta" */
    virtual const char* getSpecie() const {
        return ""; 
    } 
    /** Funzioni di interfaccia */
    const char getSesso() const {        
        return (char)_sesso;
    } 
    const char* getRazza() const {
        return _razza.c_str();
    }
};

/** Operatore di output su stream per la classe Animale */
ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; "Specie:" &lt;&lt; animale.getSpecie() &lt;&lt; "\t"
        &lt;&lt; "Razza:"  &lt;&lt; animale.getRazza()  &lt;&lt; "\t"
        &lt;&lt; "Sesso:"  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}

/** Definizione della classe derivata Cavallo */
class Cavallo : public Animale {
public:
    /** Definizione dei costruttori della classe */
    Cavallo() {}
    Cavallo(const char* razza, const Sesso sesso )
    : Animale(razza, sesso ) { 
    }
    /** Ridefinizione della funzione virtuale pura */
    const char* getSpecie() const {
        return "Cavallo"; 
    }     
};

/** Definizione della classe derivata Cavallo */
class Asino : public Animale {
public:
    /** Definizione del costruttore della classe */
    Asino() {}
    Asino(const char* razza, const Sesso sesso )
    : Animale(razza, sesso ) { 
    }
    /** Ridefinizione della funzione virtuale pura */
    const char* getSpecie() const {
        return "Asino"; 
    }     
};

/** Definizione della classe Monta */
class Monta {
private:
    Animale* _maschio;
    Animale* _femmina;
    Data     _giorno;
    string   _esito;
    /** 
    *   Funzione privata per la definizione 
    *   dell'esito della monta 
    */
    void setEsito() {
        if(strcmp(_maschio-&gt;getSpecie(),"Asino") == 0) {
            if(strcmp(_femmina-&gt;getSpecie(),"Asino") == 0) {
                _esito = "asino";
            } else {
                _esito = "mulo";
            } 
        } else {        
            if(strcmp(_femmina-&gt;getSpecie(),"Cavallo") == 0) {
                _esito = "puledro";
            } else {
                _esito = "bardotto";
            } 
        }
    }
public:
    /** Costruttore della classe */
    Monta(Animale* maschio, Animale* femmina) {
        _maschio = maschio;
        _femmina = femmina;
        time(&amp;_giorno);
        setEsito();
    }
    /** Operatore di output, "friend" della classe Monta */
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Monta&amp; copula) {
        os &lt;&lt; "DATA:    " &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
           &lt;&lt; "MASCHIO: " &lt;&lt; *copula._maschio 
           &lt;&lt; "FEMMINA: " &lt;&lt; *copula._femmina
           &lt;&lt; "ESITO:   " &lt;&lt; copula._esito
           &lt;&lt; endl;
           return os;   
     };
};

int main()
{
    /** 
     *  Crea gli oggetti di classe derivata  
     *  e li assegna a puntatori della classe base.
     */
    Animale* cavallo  = new Cavallo("lipizzano", maschio);    
    Animale* giumenta = new Cavallo("maremmano", femmina);    
    Animale* asino    = new Asino("amiatino", maschio);
    Animale* asina    = new Asino("sardo", femmina);

    /** Crea una lista con una classe template */
    list&lt;Monta&gt; monte;

    /** Associa alla lista degli oggetti di classe Monta */
    monte.push_back(Monta(cavallo, giumenta)); 
    monte.push_back(Monta (asino, asina));       
    monte.push_back(Monta (asino, giumenta));     
    monte.push_back(Monta (cavallo, asina));

    /** Mostra il contenuto della lista */
    list&lt;Monta&gt;::iterator it;
    for (it=monte.begin(); it!=monte.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; endl;
    }

    return 0;               
}

</code></pre>

<p>L’output di questo codice, nel caso l’avessi scordato, è:</p>

<pre><code>&gt; g++ src/cpp/cplusplus-template.cpp -o src/out/esempio
&gt; src/out/esempio
DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   puledro

DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   asino

DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Asino   Razza:amiatino  Sesso:m
FEMMINA: Specie:Cavallo Razza:maremmano Sesso:f
ESITO:   mulo

DATA:    Sun May 23 14:42:51 2021
MASCHIO: Specie:Cavallo Razza:lipizzano Sesso:m
FEMMINA: Specie:Asino   Razza:sardo     Sesso:f
ESITO:   bardotto
</code></pre>

<p>Prima di andare avanti, però, è necessario fare un po’ di chiarezza su tre termini legati al polimorfismo: <em>overload</em>, <em>override</em> e <em>ridefinizione</em>.<br />
Con il termine: <b id="overload">overload</b> di una funzione si intende la una funzione che abbia lo stesso nome di un’altra, ma dei parametri differenti. 
Un tipico esempio di <em>function overload</em> sono le differenti versioni del costruttore di una classe:</p>

<pre><code>Cavallo() {}
Cavallo(const char* razza, const Sesso sesso )
: Animale(razza, sesso ) { 
}
</code></pre>
<p>Le due funzioni hanno lo stesso nome e il compilatore sceglierà l’una o l’altra in base ai parametri che vengono utilizzati.<br />
Una funzione <b id="overridden">overridden</b> è una funzione che ha una definizione diversa da quella di una funzione virtuale di una sua classe-base:</p>

<pre><code>const char* getSpecie() const {
    return "Asino"; 
}     
</code></pre>

<p>Come abbiamo visto, il compilatore sceglie l’una o l’altra in base al tipo di oggetto utilizzato per la chiamata.<br />
Se la funzione della classe base non fosse stata virtuale, questa sarebbe stata una semplice <strong>ridefinizione</strong>:</p>

<pre><code>class Persona {
public:
    void getClass(){
        cout &lt;&lt; "Persona" &lt;&lt; endl;
    }
};
</code></pre>

<p>Quando gestisce queste funzioni, il compilatore non fa un controllo di tipo dinamico, basato sul tipo dell’oggetto al momento dell’esecuzione, ma sceglie la funzione da chiamare in base al tipo di puntatore o riferimento utilizzato, cosa che, come sai, può creare dei problemi:</p>

<pre><code>Madre   * ptrM = new Madre;
Persona * ptrP = ptrM ;
ptrM-&gt;getClass() ;
ptrP-&gt;getClass() ;  // chiama la funzione di Persona - ERRORE
</code></pre>

<p>Alla luce di tutto ciò, possiamo correggere i commenti del codice di esempio:</p>

<pre><code>/** Overload dell'operatore di output su stream  */
ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; "Specie:" &lt;&lt; animale.getSpecie() &lt;&lt; "\t"
        &lt;&lt; "Razza:"  &lt;&lt; animale.getRazza()  &lt;&lt; "\t"
        &lt;&lt; "Sesso:"  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}

/** Override della funzione virtuale pura */
const char* getSpecie() const {
    return "Cavallo"; 
}  

/** Override della funzione virtuale pura */
const char* getSpecie() const {
    return "Asino"; 
}     

/** Overload dell'operatore di output su stream */
friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Monta&amp; copula) {
    os &lt;&lt; "DATA:    " &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
       &lt;&lt; "MASCHIO: " &lt;&lt; *copula._maschio 
       &lt;&lt; "FEMMINA: " &lt;&lt; *copula._femmina
       &lt;&lt; "ESITO:   " &lt;&lt; copula._esito
       &lt;&lt; endl;
       return os;   
 };
</code></pre>

<hr id="overload-operatori" />

<p>Nel C++, a ogni operatore corrisponde una funzione.
Quella dell’operatore binario <code>+=</code>, per esempio, è:</p>

<pre><code>&lt;tipo&gt;&amp; operator +=  (&lt;tipo&gt;&amp; a, &lt;tipo&gt;&amp; b) ;
</code></pre>

<p>laddove <code>a</code> e <code>b</code> sono i due oggetti che intervengono nell’operazione e <code>&lt;tipo&gt;</code> è il tipo delle variabili che intervengono nell’operazione.</p>

<pre><code>int&amp;    operator +=  (int&amp;    a, int&amp;    b) ;
float&amp;  operator +=  (float&amp;  a, float&amp;  b) ;
double&amp; operator +=  (double&amp; a, double&amp; b) ;
</code></pre>

<p>Dato che gli operatori unari possono essere prefissi o postfissi, per consentire al compilatore di distinguere le funzione corretta da utilizzare, alla funzione dell’operatore postfisso si aggiunge un secondo parametro, non utilizzato:</p>

<pre><code>void operator ++ (&lt;tipo&gt; a) ;           // versione prefissa
void operator ++ (&lt;tipo&gt; a, &lt;tipo&gt;) ;   // versione postfissa
</code></pre>

<p>Le funzioni degli operatori <em>overloaded</em> possono essere richiamate in maniera diretta.
Le due istruzioni qui sotto, una volta compilate, producono il medesimo codice e lo stesso risultato.
Se riesci a trovare una qualunque ragione per usare la prima sintassi piuttosto che la seconda, fallo pure:</p>

<pre><code>a = b.operator + (c) ;  
a = b + c ;
</code></pre>

<p>Il comportamento degli operatori è predefinito per tutti i tipi standard e può essere ridefinito per gestire anche dei tipi di dato aggregati come le strutture o le classi. 
La classe <code>string</code>, della libreria standard del C++, per esempio, ridefinisce, fra le altre cose, il comportamento degli operatori di assegnazione <code>+=</code> e <code>+</code> e dell’operatore di output su stream <code>&lt;&lt;</code> in modo che si possano compiere delle operazioni sulle stringhe con la stessa sintassi che si utilizza per altri tipi di dato:</p>

<pre><code>/** 
 * @file src/polimorfismo-operatori.cpp
 * Esempio di overload di un operatore.
 */

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main ()
{
    string s1 ("Pip");
    string s2 ("po");
    const char* s3 = "Plut";

    /** 
     *  La classe string definisce tre overload 
     *  per l'operatore += .
     *
     *  string&amp; operator+= (const string&amp; str);
     *  string&amp; operator+= (const char* s);
     *  string&amp; operator+= (char c);
     */
    s1 += s2;
    s1 += s3;

    cout &lt;&lt; (s1 + 'o') &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>L’output di questo codice è ben noto:</p>

<pre><code>&gt; g++ src/cpp/polimorfismo-operatori.cpp -o src/out/esempio
&gt; src/out/esempio                                          
PippoPluto
</code></pre>

<p>Lo stesso risultato si può ottenere anche con la funzione <code>append</code>:</p>

<pre><code>string&amp; append (const string&amp; str)
</code></pre>

<p>ma utilizzare un operatore standard rende il codice più facile da leggere e da scrivere, se non altro perché non ti devi ricordare come si chiama la funzione per unire due stringhe.<br />
Gli unici operatori che non possono essere ridefiniti da una classe sono:</p>

<ul>
  <li>l’operatore di selezione <code>.</code>;</li>
  <li>l’operatore di risoluzione di indirizzamento dei puntatori a membri della classe <code>.*</code>;</li>
  <li>l’operatore di risoluzione del campo d’azione <code>::</code>;</li>
  <li>l’operatore condizionale <code>? :</code>;</li>
  <li>i simboli <code># </code> e <code>##</code>, che vengono utilizzati dal preprocessore.</li>
</ul>

<hr id="operatori-classi" />

<p>Tranne alcune eccezioni che vedremo fra poco, tutti gli operatori del C++ possono essere ridefiniti o come funzione membro di una classe o come funzione globale:</p>

<pre><code>/** 
 * @file src/polimorfismo-in-out.cpp
 * Operatori come funzioni membro o globali.
 */

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

struct A
{
    int _a;
    A(int a) : _a(a) {}
};

struct B
{
    int _b;
    B(int b) : _b(b) {};   
    /** Overload come funzione membro */
    int operator + (const A&amp; a) {
        return _b + a._a;
    }
};

/** Overload come funzione globale */
int operator + (const A&amp; a, const B&amp; b) { return a._a + b._b; }

int main ()
{
    struct A a(3);
    struct B b(5);
    
    cout &lt;&lt; (a + (b + a)) &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>Quando si ridefinisce il comportamento di un operatore per una classe, bisogna tenere conto della visibilità dei dati membro che deve utilizzare.
Se l’operatore, com’è probabile, deve gestire dei dati privati o protetti, le possibilità sono due: o sfruttare le funzioni di interfaccia della classe o  dichiarare l’operatore <code>friend</code> della classe.
Nell’esempio iniziale sono applicate entrambe le possibilità: l’operatore di output su stream per la classe <code>Animale</code> utilizza le funzioni di interfaccia della classe:</p>

<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; os, const Animale&amp; animale) {
    os  &lt;&lt; "Specie:" &lt;&lt; animale.getSpecie() &lt;&lt; "\t"
        &lt;&lt; "Razza:"  &lt;&lt; animale.getRazza()  &lt;&lt; "\t"
        &lt;&lt; "Sesso:"  &lt;&lt; animale.getSesso()  
        &lt;&lt; endl;
    return os;   
}
</code></pre>

<p>mentre l’operatore di output per la classe <code>Monta</code> è dichiarato come <code>friend</code> della classe e quindi può accedere direttamente ai dati membro dell’istanza:</p>

<pre><code>friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Monta&amp; copula) {
    os &lt;&lt; "DATA: "    &lt;&lt; asctime(localtime(&amp;copula._giorno)) 
       &lt;&lt; "MASCHIO: " &lt;&lt; *copula._maschio 
       &lt;&lt; "FEMMINA: " &lt;&lt; *copula._femmina;
       return os;   
};
</code></pre>

<p>La scelta fra l’una o l’altra possibilità dipende dal tipo di programma che devi scrivere: se punti alla velocità, scegli la seconda, che è più diretta, altrimenti scegli la prima, che sarà probabilmente più lenta in esecuzione, ma non necessiterà di riscritture in caso di modifiche alla struttura della classe.
Non è possibile, però, ridefinire come funzione membro di una classe una funzione operatore che abbia come primo parametro una classe di cui non si ha il controllo (come, per esempio, la funzione operatore <code>&lt;&lt;</code>  che ha come primo parametro un riferimento a <code>ostream</code>) perché nella funzione membro questo parametro sarebbe sostituito dal parametro implicito <code>this</code>, che ha un altro tipo di dato, causando un errore di compilazione.<br />
Gli operatori <code>=</code>, <code>()</code>, <code>[]</code> e <code>-&gt;</code> non possono essere ridefiniti come funzioni globali, ma devono sempre essere implementati come funzione membro non statica di una classe
Le altre regole da ricordare, in questi casi, sono:</p>

<ul>
  <li>
    <p>l’operatore unario di assegnamento <code>=</code> è l’unico caso di funzione membro che non viene eredi­tata da eventuali classi figlie; se non viene ridefinito, prevede l’assegnamento membro a membro degli attributi e ha la sintassi:</p>

    <pre><code>  C&amp; C::operator = (const C&amp; origine) ;
</code></pre>
  </li>
  <li>
    <p>l’operatore binario <code>[]</code> permette di implementare vettori di tipo particolare, mantenendo una sintassi standard e ha la forma:</p>

    <pre><code>  c.operator [] (n) ;
</code></pre>

    <p>dove <code>c</code> è un oggetto di classe <code>C</code> e l’indice n può essere un qualsiasi tipo di dato ;</p>
  </li>
  <li>
    <p>per ridefinire l’operatore binario di chiamata a funzione <code>()</code>, va utilizzata la sintassi:</p>

    <pre><code>  c.operator()(p) ;
</code></pre>

    <p>dove <code>c</code> è sempre un oggetto di classe <code>C</code> e <code>p</code> è un elenco anche vuoto, di parametri;</p>
  </li>
  <li>
    <p>l’operatore unario di accesso ai membri della classe <code>-&gt;</code> viene interpre­tato come:</p>

    <pre><code>  (C.operator -&gt; ())-&gt;m ;
</code></pre>

    <p>e ritorna o un oggetto o un puntatore a un oggetto di classe <code>C</code>.</p>
  </li>
</ul>

<p>Ridefinire gli operatori <code>new</code> e <code>delete</code>, il cui comportamento è strettamente le­gato all’hardware, potrebbe non essere una scelta astuta dal punto di vista della port­abilità del codice; detto ciò, se una classe ha bisogno di gestire la memoria in modo particolare, lo può fare, ma deve rispettare due regole:</p>

<ul>
  <li>l’operatore <code>new</code> deve avere il primo argomento di tipo <code>size_t</code> e resti­tuire un puntatore a <code>void</code>;</li>
  <li>l’operatore <code>delete</code> deve essere una funzione di tipo <code>void</code> che abbia un primo argomento di tipo <code>void*</code> e un secondo argomento, facoltativo, di tipo <code>size_t</code>.</li>
</ul>

<hr id="cast" />

<!-- @todo: verificare queste affermazioni per il post-C++11 -->
<p>In C, per trasformare un <code>int</code> in un <code>double</code> si utilizzano gli operatori di cast:</p>

<pre><code>long int i = 5 ;
double d = (double) i ;
</code></pre>

<p>Il C++ accetta questa sintassi, così come accetta che si usi <code>malloc</code> al posto di <code>new</code>, ma la sua sintassi standard, che ricorda vagamente i costruttori delle classi, prevede che il dato da convertire sia passato come parametro a una funzione con lo stesso nome del tipo in cui si vuole che avvenga la conversione :</p>

<pre><code>long int i = 5 ;
double d = double(i) ;
</code></pre>

<p>Il compilatore del C++ ha la possibilità di convertire un qualunque tipo di dato primitivo in un altro, ma non può sapere come comportarsi con i tipi di dato definiti dall’utente; dobbiamo quindi istruirlo, così come abbiamo fatto con i costruttori e gli operatori, definendo dei cam­mini di coercizione dai tipi di dato primitivi e viceversa.
Il primo caso, ovvero la trasformazione dal tipo primitivo a quello definito dall’utente, è il più semplice: di fatto si tratta di definire, laddove non ci sia già, un cos­truttore per la nuova classe che richieda dei parametri di tipo primitivo. 
Quando invece non esiste un costruttore da estendere, ovvero quando la coercizione è dal tipo definito dall’utente a un tipo di dato primitivo o fornito in una libreria di cui non si possiede il codice sorgente, è necessario ridefinire l’operatore di conversione <code>()</code>.<br />
Immagina di aver creato un nuovo tipo di dato <code>Frazione</code> per la gestione dei numeri razionali. 
Per poterlo utilizzare in espressioni contenenti dati di tipo primi­tivo dovresti ridefinire ciascun operatore per fargli accettare dei dati di tipo misto, sia come primo che come secondo parametro:</p>

<pre><code>Frazione operator + (int i, Frazione f) :
Frazione operator - (int i, Frazione f) :
Frazione operator + (double i, Frazione f) :
Frazione operator - (double i, Frazione f) :
...
Frazione operator + (Frazione f, int i) :
Frazione operator - (Frazione f, int i) :
Frazione operator + (Frazione f, double i) :
Frazione operator - (Frazione f, double i) :

</code></pre>

<p>Puoi risparmiarti questa seccatura ridefinendo solo il com­portamento degli operatori per la nuova classe e fornendo al compilatore dei cammini di conversione dai tipi primitivi al nuovo tipo di dato, in modo che possa trasformare i dati nel tipo appropriato, nel caso di espressioni miste:</p>

<pre><code>/** 
 * @file src/polimorfismo-cast.cpp
 * Gestione della conversione esplicita.
 */

#include &lt;iostream&gt;

using namespace std;

class Frazione
{
private:
    
    int _num ;
    int _den ;

public:
    
    /** Costruttore con parametri interi */
    Frazione(int n, int d = 1) 
    : _num(n), _den(d) {} 
    
    /** 
     * Costruttore con parametro a virgola mobile.
     * La definizione è piuttosto complessa, te la risparmio.  
     */
    Frazione(double d) ;

    /** Overload dell'operatore di cast a intero */
    operator int () { 
        return _num / _den ; 
    }

    /** Overload dell'operatore di cast a double */
    operator double() { 
        return (double) _num / (double) _den ; 
    }

    /** Overload degli operatori di somma e sottrazione */
    friend Frazione operator+ (Frazione f1, Frazione f2); 
    friend Frazione operator- (Frazione f1, Frazione f2); 

};

</code></pre>
<hr id="template" />

<p>L’ultima cosa di cui ti devo parlare, a proposito del polimorfismo, sono i <em>template</em>.<br />
I template, nel C++, sono dei modelli che si utilizzano per definire delle funzioni o delle classi polivalenti.
Se uno stesso compito può essere eseguito in maniera simile su parametri di tipo differente, invece di scrivere delle funzioni o delle classi identiche per ciascun tipo di parametro, si può scrivere una funzione o una classe template e richiamarla ogni volta con il tipo di parametro appropriato:</p>

<pre><code>int    somma(int    a, int    b) { return a + b; }
float  somma(float  a, float  b) { return a + b; }
double somma(double a, double b) { return a + b; }

template &lt;class T&gt; 
somma(T a, T b) { return a + b; }
</code></pre>

<p>Quando il compilatore trova nel codice un template, sia esso la dichiarazione di una classe o una chiamata a funzione, la sostituisce con il codice corrispondente, così come avviene per le <a href="/man/preprocessore#macro" class="xref">macro-istruzioni del precompilatore</a>, ma, a differenza di quello che avviene per le macro, il tipo dei parametri del template è sottoposto a uno stretto controllo, così come il resto del codice.<br />
Il formato per la dichiarazione di una <i id="funzioni-template">funzione template</i> è:</p>

<p class="code">
<b>template &lt;class</b> <i>identificatore</i><b>&gt;</b> <i>dichiarazione</i>;
<br />  
<b>template &lt;typename</b> <i>identificatore</i><b>&gt;</b> <i>dichiarazione</i>;
</p>

<p>Non c’è nessuna differenza fra la prima e la seconda forma: sia <code>class</code> che <code>typename</code> producono lo stesso effetto.<br />
<em>identificatore</em> è un simbolo che identifica un determinato tipo di dato o una classe definita dall’utente.
Per esempio, la sintassi di una funzione template che torna il maggiore di due parametri sarà qualcosa di simile:</p>

<pre><code>template&lt;class T&gt;
T maggiore (T x, T y) {
    return (x &gt; y) ? x : y;
}
</code></pre>

<p>In questo caso, l’identificativo del tipo è la lettera <code>T</code> che compare sia fra gli apici nella prima riga che fra parentesi nella seconda, ma può essere qualsiasi stringa. 
I parametri possono essere più di uno:</p>

<pre><code>template&lt;class C1, class C2&gt;
T funz (C1 x, C2 y) {
...
}
</code></pre>

<p>e possono avere un valore di default:</p>

<pre><code>template&lt;class N = int&gt;
T funz (N n) {
...
}
</code></pre>

<p>La chiamata delle funzioni template è simile a quella delle funzioni ordinarie, con l’aggiunta del tipo dei parametri che devono essere gestiti:</p>

<pre><code>cout &lt;&lt; maggiore&lt;int&gt;   (  9,  12) &lt;&lt; endl;    
cout &lt;&lt; maggiore&lt;double&gt;(0.4, 1.2) &lt;&lt; endl;    
cout &lt;&lt; maggiore&lt;char&gt;  ('a', 'z') &lt;&lt; endl;    
</code></pre>
<!-- @todo: verificare i casi in cui non c'è specifica del tipo di dato -->
<p>Il prossimo esempio mostra la differenza fra una macro del precompilatore e una funzione template:
<!-- NOTA: se si cambia o si rimuove la macro nel codice, va aggiornato il testo del capitolo sul preprocessore --></p>
<pre><code>/** 
 * @file src/polimorfismo-macro-template.cpp
 * Funzioni template e macro precompilatore.
 */

#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

/**
*  Definzione di una macro istruzione per il 
*  precompilatore: nessun controllo di tipo.
*/
#define MAGGIORE(a,b) ((a &gt; b) ? a : b) 

/**
*  Definzione di una funzione template
*  che torna il maggiore fra due parametri.
*/
template&lt;class T&gt;
T maggiore (T x, T y) {
    return (x &gt; y) ? x : y;
}

int main ()
{     
    int    a = 10;
    short  b = 0;   
    double d = 3.123456789;
    
    /** Utilizzo della macro */
    cout &lt;&lt; MAGGIORE(9,12)     &lt;&lt; endl;    
    cout &lt;&lt; MAGGIORE(0.4, 0.7) &lt;&lt; endl;    
    cout &lt;&lt; MAGGIORE('a', 'z') &lt;&lt; endl;    

    /** 
    *  La stessa funzione si può utilizzare 
    *  con tipi di dato diversi:
    */
    cout &lt;&lt; maggiore&lt;int&gt;   (  9,  12) &lt;&lt; endl;    
    cout &lt;&lt; maggiore&lt;double&gt;(0.4, 1.2) &lt;&lt; endl;    
    cout &lt;&lt; maggiore&lt;char&gt;  ('a', 'z') &lt;&lt; endl;    
   
    /** Errore: confronta un carattere con un double */
    cout &lt;&lt; MAGGIORE('a', d) &lt;&lt; endl;    

    /**
    *   Errore: il compilatore non sa quale
    *   dei due tipi di dato utilizzare.
    */
    cout &lt;&lt; maggiore(a, b) &lt;&lt; endl;    
    
    return 0;
}

</code></pre>

<p>La macro <code>MAGGIORE</code> e la funzione template <code>maggiore</code> eseguono la stessa operazione: confrontano i due parametri che hanno ricevuto in input e tornano il maggiore dei due.
La grossa differenza fra questi due approcci<!-- ce ne sono anche altre, ma sono legate al tipo di compilatore e preferisco tralasciarle --> è che, mentre il tipo dei parametri del template è verificato dal compilatore, la macro è una banale sostituzione che non fa alcun controllo sulle variabili che utilizza.
L’istruzione:</p>

<pre><code>cout &lt;&lt; MAGGIORE('a', b) &lt;&lt; endl; 
</code></pre>

<p>compara un carattere con un double e, senza dare problemi in compilazione torna il valore <code>97</code>, corrispondente al codice ASCII della lettera <code>a</code>.
Al contrario, l’istruzione:</p>

<pre><code>int   a = 10;
short b = 0;
cout &lt;&lt; maggiore(a, b) &lt;&lt; endl;  
</code></pre>

<!-- @todo: correggere questo codice, sia qui che nello script: l'errore si manifesta solo se si omette lo specificatore del tipo per il template -->
<p>causa un errore di compilazione perché i due parametri sono di tipo differente:</p>

<pre><code>&gt; g++ src/cpp/polimorfismo-template.cpp -o src/out/esempio
src/cpp/polimorfismo-template.cpp:52:13: 
    error: no matching function for call to 'maggiore'
    cout &lt;&lt; maggiore(a, b) &lt;&lt; endl;    
            ^~~~~~~~
src/cpp/polimorfismo-template.cpp:22:3: 
    note: candidate template ignored: 
        deduced conflicting types for parameter 'T'
      ('int' vs. 'short')
T maggiore (T x, T y) {
  ^
</code></pre>

<p>La dichiarazione di una <i id="classi-template">classe template</i> ha la forma:</p>

<p class="code">
<b>template &lt;class</b> <i>identificatore</i><b>&gt;</b> <i>dichiarazione</i>;
</p>

<p>La lista dei parametri fra i simboli <code>&lt;&gt;</code> può contenere uno o più simboli per i tipi dato gestiti dalla classe.
L’utilizzo di queste classi è simile a quello delle funzioni template:</p>

<pre><code>/** 
 * @file src/polimorfismo-classe-template.cpp
 * Esempio di classe template.
 */

#include &lt;iostream&gt;

using namespace std;

/**
*   Definisce una classe che gestisce coppie 
*   di coordinate.
*/
template&lt;class T&gt;
class Coord {
private:
    /** Dati membro con tipo variabile */
    T _x, _y; 
public:
    /** Costruttore con tipo di parametri variabile */
    Coord(const T x, const T y) 
    : _x(x), _y(y) {        
    }
    friend ostream&amp; operator &lt;&lt; (ostream&amp; o, const Coord&amp; c) {
        o &lt;&lt; c._x &lt;&lt; ',' &lt;&lt; c._y ;
        return o;
    }
};

int main ()
{         
    /** Istanza con coordinate geografiche */
    Coord&lt;double&gt; obelisco(41.903219, 12.458157);
    
    /** Istanza con coordinate schermo */
    Coord&lt;int&gt;    pixel(821, 134);
    
    cout &lt;&lt; "Obelisco:" &lt;&lt; obelisco &lt;&lt; endl;    
    cout &lt;&lt; "Pixel:   " &lt;&lt; pixel    &lt;&lt; endl;    
    
    return 0;
}

</code></pre>

<hr id="stl" />

<p>Il codice che ti ho mostrato all’inizio di questa lezione utilizza una classe template:</p>

<pre><code>list&lt;Monta&gt; monte;
</code></pre>

<p>La classe <code>list</code> è una delle classi della <em>Standard Template Library</em> del C++, una libreria di classi e di funzioni che permettono di risolvere dei problemi comuni della programmazione, come la memorizzazione, l’ordinamento o la ricerca di una serie di dati.
Le componenti della STL è sono:</p>

<ul>
  <li>una libreria di <strong>container</strong> che permettono di immagazzinare oggetti e dati;</li>
  <li>degli <strong>iteratori</strong> che consentono di scorrere il contenuto dei container;</li>
  <li>una collezione di <strong>algoritmi</strong> che permettono di eseguire delle operazioni di ordinamento e ricerca su insiemi di dati;</li>
  <li>degli oggetti-funzioni, o: <strong>functors</strong>, che incapsulano una specifica funzione.</li>
</ul>

<p>La classe <code>list</code> è un esempio di container e rappresenta un elenco di elementi memorizzati in aree non contigue della memoria. 
Al contrario, la classe <code>vector</code> implementa un elenco di elementi memorizzati in un’unica area di memoria, così come avviene per gli array del C.<br />
Tutti i vettori della STL posseggono delle funzioni membro che consentono di gestirne gli elementi; la funzione <code>push_back</code>, per esempio, aggiunge un elemento in coda alla lista:</p>

<pre><code>monte.push_back(Monta(cavallo, giumenta)); 
monte.push_back(Monta (asino, asina));       
monte.push_back(Monta (asino, giumenta));     
monte.push_back(Monta (cavallo, asina));
</code></pre>

<p>Gli <i id="iteratori-stl">iteratori</i> sono dei costrutti che permettono di scorrere il contenuto di un container, individuandone gli elementi.
Ne abbiamo utilizzato uno nell’istruzione:</p>

<pre><code>list&lt;Monta&gt;::iterator it;
for (it=monte.begin(); it!=monte.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; endl;
}
</code></pre>

<p>La prima istruzione del ciclo <code>for</code> assegna all’iteratore <code>it</code> il primo elemento della lista, tornato dalla funzione membro <code>monte.begin</code>.
La seconda istruzione, verifica che l’iteratore sia differente da <code>monte.end</code>, che punta alla fine della lista.
La terza istruzione incrementa l’iteratore di una posizione e dimostra come la ridefinizione di un operatore per una classe renda il codice più facile da leggere: anche se tu non hai mai visto una classe template, capisci subito che quella istruzione incrementa il valore di <code>it</code> di un’unità.<br />
Gli <i id="algoritmi-stl">algoritmi</i> della STL, definiti nell’header <code>&lt;algorithm&gt;</code> sono funzioni template che permettono di individuare, copiare, ordinare, unire o eliminare i dati all’interno di un container.</p>

<!-- @todo: aggiungere commenti -->
<pre><code>/** 
 * @file src/polimorfismo-algoritmi.cpp
 * Esempio di utilizzo degli algoritmi della STL.
 */

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    vector&lt;int&gt; vect;
    
    vect.push_back(10);
    vect.push_back(70);
    vect.push_back(21);
    vect.push_back(49);
    vect.push_back(35);

    cout &lt;&lt; *min_element(vect.begin(), vect.end()) &lt;&lt; endl;
    cout &lt;&lt; *max_element(vect.begin(), vect.end()) &lt;&lt; endl;
    
    vector&lt;int&gt;::iterator i;
    for(i = vect.begin(); i != vect.end(); i++) {
        cout &lt;&lt; *i &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    int n = vect.size();
    sort(vect.begin(), vect.end());
    for (int i=0; i&lt;n; i++) {
        cout &lt;&lt; vect[i] &lt;&lt; " ";       
    }
    cout &lt;&lt; endl;

    reverse(vect.begin(), vect.end());
    for (int i=0; i&lt;n; i++) {
        cout &lt;&lt; vect[i] &lt;&lt; " ";       
    }
    cout &lt;&lt; endl;

 
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, ottieni:</p>

<pre><code>&gt; g++ src/cpp/polimorfismo-algoritmi.cpp -o src/out/esempio
&gt; src/out/esempio                                          
10
70
10 70 21 49 35 
10 21 35 49 70 
70 49 35 21 10 
</code></pre>

<p>Le function-class o: <i id="functors-stl">functors</i> sono delle classi che ridefiniscono il comportamento dell’operatore <code>()</code> e che possono quindi agire come se fossero delle funzioni:</p>

<pre><code>/** 
 * @file src/polimorfismo-functor-stl.cpp
 * Esempio di function objects della STL.
 */

#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

int main ()
{
    int a = 12;
    int b = 4;

    /** Dichiarazione di oggetti functor */
    plus&lt;int&gt;       p;
    minus&lt;int&gt;      m;
    multiplies&lt;int&gt; x;
    divides&lt;int&gt;    d;
    modulus&lt;int&gt;    o;

    /** Utilizzo degli oggetti come fossero delle funzioni */
    cout &lt;&lt; "plus: "       &lt;&lt; p(a,b) &lt;&lt; endl;
    cout &lt;&lt; "minus: "      &lt;&lt; m(a,b) &lt;&lt; endl;
    cout &lt;&lt; "multiplies: " &lt;&lt; x(a,b) &lt;&lt; endl;
    cout &lt;&lt; "divides: "    &lt;&lt; d(a,b) &lt;&lt; endl;
    cout &lt;&lt; "modulus: "    &lt;&lt; o(a,b) &lt;&lt; endl;

    /** "esegue"" l'oggetto o con nuovi parametri */
    cout &lt;&lt; "modulus: "    &lt;&lt; o(a,5) &lt;&lt; endl;

    return 0;
}

</code></pre>
<p>Utilizzati così, i <em>functor</em> hanno poco senso, ma possono essere (e sono) molto utili quando si utilizzano quelle funzioni della STl che elaborano tutti gli elementi di un container, come per esempio la funzione <code>transform</code>:</p>

<pre><code>/** 
 * @file src/polimorfismo-rot13.cpp
 * Trasformazione di una stringa con una funzione.
 */

#include &lt;string&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

/** 
*   Funzione che converte i caratteri di una stringa in rot13  
*   Il ROT13 è un algoritmo di cifratura piuttosto banale, 
*   perché incrementa di 13 il valore di ciascun carattere. 
*   Non è un algoritmo realmente sicuro, però, perché per 
*   decifrare il testo crittografato basta crittografarlo 
*   di nuovo.  
*/
unsigned char rot13(unsigned char c) 
{ 
    unsigned char rot = c;
    if (isalpha(c)) {
        rot = ((tolower(c) - 'a') &lt; 14) ? c + 13 : c - 13;
    }
    return rot;
}

int main ()
{
    string pp("PippoPluto"); 

    /** Elabora la stringa con la funzione transform */
    transform(
               pp.begin()   // inizio del container da modificare
             , pp.end()     // fine del container da modificare
             , pp.begin()   // container di output
             , rot13        // funzione da applicare
             );

    cout &lt;&lt; pp &lt;&lt; endl; 

    /** Ripetendo l'operazione, il testo torna normale. */
    transform(
               pp.begin()   
             , pp.end()     
             , pp.begin()   
             , rot13        
             );

    cout &lt;&lt; pp &lt;&lt; endl; 
    
    return 0;
}

</code></pre>
<p>Se compili ed esegui questo programma, otterrai :</p>

<pre><code>&gt; g++ src/cpp/polimorfismo-rot13.cpp -o src/out/esempio     
&gt; ./src/out/esempio
CvccbCyhgb
PippoPluto
</code></pre>

<p>Le funzioni ordinarie ti permettono di sfruttare l’algoritmo <code>transform</code> per cifrare un testo con un valore fisso, ma non puoi fare la stessa cosa utilizzando una chiave variabile, perché il quarto parametro non accetta funzioni con più di un parametro. 
Se provassi a utilizzarlo con qualcosa come:</p>

<pre><code>unsigned char cifra(unsigned char c, int chiave) 
{ 
    return c + chiave;
}
</code></pre>

<p>otterresti l’errore:</p>

<pre><code>/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/algorithm:1855:34: error: too few arguments to
      function call, expected 2, have 1
        *__result = __op(*__first);
                    ~~~~         ^
src/cpp/polimorfismo-transform-chiave.cpp:25:5: note: in instantiation of function template specialization
      'std::__1::transform&lt;std::__1::__wrap_iter&lt;char *&gt;, std::__1::__wrap_iter&lt;char *&gt;, unsigned char
      (*)(unsigned char, int)&gt;' requested here
    transform(
    ^
</code></pre>

<p>È in questi casi che tornano utili i <em>functor</em>, perché possono essere inizializzati con uno o più valori specifici e poi essere utilizzati come funzioni unarie:</p>

<pre><code>/** 
 * @file src/polimorfismo-functor.cpp
 * Creazione di una classe functor.
 */

#include &lt;string&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

/** Dichiarazione della classe functor */
class Cifra
{
private:

    int _chiave;

public:
    
    /** 
    *   Il costruttore della classe ha come parametro
    *   il valore della chiave di cifratura
    */
    Cifra(int chiave) : _chiave(chiave) {  }
  
    /** Ridefinizione dell'operatore () */
    unsigned char operator () (unsigned char c) const {
        return c + _chiave;
    }
};

int main ()
{
    string pp("PippoPluto"); 

    /** 
    *   Richiama transform passando come parametro
    *   un'istanza del functor, inizializzata con 
    *   la chiave di cifratura.
    */
    transform(
               pp.begin()   
             , pp.end()     
             , pp.begin()   
             , Cifra(1)        
             );

    cout &lt;&lt; pp &lt;&lt; endl; 
    
    return 0;
}

</code></pre>

<p>Compilando ed eseguendo questo programma, ottieni :</p>

<pre><code>&gt; g++ src/cpp/polimorfismo-functor.cpp -o src/out/esempio
&gt; ./src/out/esempio
QjqqpQmvup
</code></pre>
<p>che corrisponde ai caratteri della stringa <em>PippoPluto</em> incrementati di un’unità.</p>

<hr id="dottrina" />

<p>Il Maestro Canaro applicò alla sua dottrina lo stesso approccio che adottava quando doveva realizzare un software. 
Ci sono due modi diversi di progettare un software: il primo consiste nell’analizzare tutti i sistemi che svolgono azioni simili, prendere il meglio di ciascuno e metterlo nel nuovo sistema; in alternativa, si può progettare il sistema da zero e solo quando se ne è definita per grandi linee la struttura, studiare le soluzioni adottate dagli altri, integrandole nel proprio programma, se lo si ritiene utile.<br />
Il primo approccio è più rapido e sicuro, ma ripetitivo; il secondo approccio è più complesso, sia in termini di analisi che di implementazione, ma facilita l’innovazione perché l’immaginazione dell’analista non è condizionata da ciò che ha visto.<br />
Il Maestro Canaro era un sostenitore del secondo metodo e lo applicò anche al C’hi++.<br />
Partì da un presupposto semplice:</p>

<blockquote>
  <p>È possibile dare una spiegazione dell’esistenza sfruttando solo ciò di cui abbiamo esperienza diretta?</p>
</blockquote>

<p>Fra il C’hi++ e le religioni canoniche c’è la stessa differenza che passa fra una mappa topografica e un’immagine da satellite.<br />
Quel senza Dio di Dawkins, ha detto che:</p>

<blockquote>
  <p>Uno dei caratteri di una folle stravaganza è un uso troppo entusiasta dell’analogia.<a href="/man/note#dawkins-analogia" class="nota"></a></p>
</blockquote>

<p>Una frase curiosa, da parte di un esponente di una setta che cerca di descrivere tutto ciò che esiste con analogie matematiche e nega l’esistenza di ciò che non riesce a convertire..<br />
Entusiasmi a parte, le mappe e le immagini da satellite hanno diverse analogie con le discipline metafisiche.
Anche le mappe e le immagini, come la metafisica, sono costrette a rappresentare il loro soggetto a un rapporto di scala ridotto e con due sole dimensioni in vece di tre (o di quattro se, oltre alla profondità, vuoi considerare anche il tempo).
Anche le mappe e le immagini, per questo motivo, devono rappresentare il loro soggetto per mezzo di analogie: le carte topografiche usano delle linee altimetriche e dei simboli; le immagini satellitari usano dei pixel o dei piccoli punti di colore.
In nessuno dei due casi ciò che noi vediamo è davvero ciò che rappresenta; è il nostro cervello che decide di crederlo tale: nel caso della carta topografica, perché la legenda ci permette di definire una correlazione fra significato e significante; nel caso dell’immagine, perché il nostro occhio riconosce in quelle combinazioni di pixel o di punti di colore degli alberi, il mare o delle case.<br />
Un’altra analogia, conseguenza dei due punti precedenti, è che è sbagliato confondere i simboli con ciò che rappresentano: i quadratini scuri delle mappe <em>non</em> sono case; i punti colorati delle immagini <em>non</em> sono un bosco.
Mappe e immagini hanno senso solo a un certo livello di lettura; se lo oltrepassiamo, se cerchiamo di ottenere più informazioni o verosimiglianza avvicinando lo sguardo, otteniamo l’effetto opposto, perché i simboli si rivelano per quello che sono: punti colorati o linee su un foglio. 
Questo però non vuol dire che ciò che rappresentano sia falso, ma che noi non stiamo guardando con <em>il giusto paio di occhi</em>, come direbbe Hunter Thompson.<br />
Il Maestro Canaro pensava che fosse per questo motivo che alcune religioni sono contrarie alla rappresentazione diretta della Divinità: perché è facile che poi si confonda il simbolo con ciò che rappresenta. 
<!-- 
Agli Ebrei è vietato dal secondo Comandamento e anche i Cristiani si attennero a questa regola fino al Concilio di Nicea del 787.
@todo: verificare regole simili per l'Islam. 
--> 
Tornando al paragone iniziale, le religioni tradizionali sono delle immagini da satellite, mentre il C’hi++ è una mappa topografica.<br />
Mentre i Credi religiosi riescono a riprodurre — nei limiti imposti dalla nostra condizione — tutta la bellezza del Creato, il C’hi++ si limita a darne una descrizione schematica, più povera di contenuti e di poesia, ma più facile da accettare per chi non abbia la benedizione della Fede.
Un’immagine da satellite ha un valore contemplativo: è bella da guardare sullo schermo del tuo computer o anche da appendere al muro, come un quadro, ma 
se ti sei perso in un bosco o in mezzo ai monti, una mappa topografica, proprio in virtù della sua schematicità, ti permetterà più facilmente di ritrovare la strada di casa.<br />
Il C’hi++ non cerca di rubare fedeli alle religioni canoniche.
Non avrebbe senso: sarebbe come cercare di convincere chi sia già sposato con l’amore della sua vita a fare un matrimonio di interesse: se tu hai la Fede non hai bisogno di conferme razionali; possono compiacerti, ma non ti sono necessarie. 
Il C’hi++, però, può dare forza a quelle (tante) persone che <em>ancora credono in tutto ciò in cui più nessuno crede</em>, come li descrisse Longanesi; quella <em>Banda degli Onesti</em><a href="/man/note#banda-onesti" class="nota"></a> che tutti i giorni fa il proprio dovere al meglio possibile anche se non gli conviene, anche tutto e tutti intorno a loro sembrano spingerli all’egoismo e all’indifferenza.
Può aiutarli a non arrendersi e può insegnare loro che non è importante vincere le partite, ma giocare sempre meglio.
Riconoscere gli sbagli che si sono fatti, imparare da essi e cercare di non ripeterli più, partita dopo partita, in una ricerca continua del meglio.
Se si comporteranno così, qualunque sarà il loro lavoro, fosse anche pulire i cessi, sarà comunque Arte.</p>

<!--

Da migliaia di anni, gli uomini cercano di capire quale sia il significato dell'Esistenza.  
Le risposte che si sono dati variano a seconda del periodo storico e del territorio in cui il profeta o il filosofo ha vissuto.


Data una classe: `umano` si possono ridefinire gli operatori di relazione per capire se un oggetto sia piò o meno ricco o più o meno giovane di un altro, ma sarebbe estremamente complesso scrivere una funzione che permetta di capire se un oggetto sia più o meno amato da un altro.
Nel caso di oggetti che hanno una linea genealogica comune, la funzione potrebbe basarsi, come dice Dawkins, sulla percentuale di DNA che i due oggetti condividono, moltiplicata per il tempo passato insieme, tenendo conto anche di com'è stato quel tempo, ma nel caso di due oggetti che appartengono a genealogie differenti, quale sarebbe l'algoritmo?

Riprendere la genealogia di classi del capitolo precedente ed esaminare la funzione virtuale pura `isGood` nelle sue variazioni: nel caso della classe `Mare`, il risultato è già definito perché lo ha determinato Dio; per le altre classi, non è altrettanto certo.
Ogni categoria ha una sua implementazione di questa funzione, uno specifico criterio di riscontro per determinare ciò che debba essere considerato ben fatto. 
Per alcuni è il pubblico: il droghiere ti chiede di assaggiare le olive, lo scrittore ti fa leggere ciò che ha scritto, l'attore aspetta la risata o l'applauso alla fine della scena.
Per i filosofi è `true` tutto ciò che può essere descritto con le parole; per gli scienziati, tutto ciò che può essere descritto dalla matematica; per gli informatici è `true` tutto quello che può essere descritto dal codice. 

v. Kant citato da Hertha von Dechend nella prefazione tedesca a Il Mulino di Amleto

Le diverse religioni, possono essere delle forme derivate di una stessa mistica iniziale?
Esistono dei "dati membro" e delle funzioni comuni, che siano state ridefinite con il passare del tempo, ma che facciano capo a un corpo di credenze (o di nozioni) iniziale?
Anche solo in questa mappa, se ne trovano diverse (p.es. Empedocle -&gt; Poe).
Così come le classi di un lunguaggio OO sono ridefinite per adattarsi a uno specifico contesto di utilizzo, così pure la Mistica iniziale potrebbe essere stata "overloaded" per adattarsi a uno specifico luogo o tempo.
Se fosse così, tanto più si va indietro nel tempo, e quindi nella gerarchia di classi, tanto più ci si dovrebbe avvicinare alle caratteristiche proprie della Mistica.
E' possibile definire una gerarchia di classi figlie della classe astratta "credo"?(semplificando molto, visto che sono le 3 di notte) Budda e Zoroastro influenzano i greci, che influenzano gli ebrei, che a loro volta infulenzano i cristiani, che alla fine producono i Testimoni di Geova...
Allo stesso modo (sempre semplificando), dal C si è evoluto il C++ e dal C++, Java.Sfortunatamente, però, i (cattivi) programmatori Java hanno fatto alla programmazione quello che i cattolici hanno fatto al cristianesimo.
V. Corano

Quando il programmatore definisce un nuovo tipo di dato per mezzo di una o più classi, può allo stesso tempo istruire le funzioni e gli operatori del linguaggio ad utilizzarlo correttamente.

Noi viviamo prevalentemente sulla terraferma e riteniamo perciò che la normalità sia questa. Se però si trascorre un lungo periodo di tempo su una nave o in un'isola, si ha modo di capire come la normalità sia l'acqua e la terra sia solo un'eccezione.
Similmente, noi diamo grande importanza al ciclo di nascita, riproduzione e morte che chiamiamo "vita" e in essa vediamo il fine ultimo dell'Universo, dimenticandoci che la vita è solo un caso particolare di esistenza e che un universo di sassi sarebbe comunque prodigioso.
Ciascuna forma di vita consociata, per poter sopravvivere, richiede la legittimazione di alcune follie biologiche.
Il rispetto di queste follie, essendo in-naturale, richiede l'istituzione di un livello superiore di costrizione, ovvero un corpo di regole formali ancora più distante del precedente dal comportamento biologico degli esseri viventi.
Con il passare del tempo, molte di queste convenzioni nate in seguito a esigenze contingenti, finiscono inevitabilmente per contrastare con il senso comune di giustizia e devono essere o abolite o modificate, solo che ciascuna modifica o adattamento invece di renderle più "giuste", le allontana ulteriormente dal loro scòpo iniziale e le rende soggette a interpretazioni errate o addirittura opposte a quelle che era il loro fine primario.
Sant'Agostino ha detto la stessa cosa, ma molto meglio di quanto stia facendo io adesso.
Si vede che era sobrio.


<!-- @todo: trovare il riferimento bibliografico per il prossimo paragrafo; so che esiste, ma non mi ricordo quale fosse -->
<p>Le religioni nate in zone temperate, con abbondanza di acqua e di cibo, hanno un pantheon di divinità più o meno benevole, mentre quelle nate in zone aspre hanno un numero ristretto di Dei, più severi.</p>

<p>La specializzazione come un male.</p>

<p>“La specializzazione va bene per gli insetti” (dove l’ho letto?)</p>

<p>Un tempo, l’uomo virtuoso sapeva fare molte cose, più o meno bene.
Ora se ne sa fare solo una, benissimo.
Si cerca l’eccesso, il continuo superamento del limite.</p>

<p>Lo sport (citare Arlìa?), da attività formativa è diventato una forma di intrattenimento e, come tale, deve essere sempre più spettacolare.
Lo sportivo è visto come un costoso strumento usa e getta.</p>

<p>È però importante che il polimorfismo non dia luogo ad anfibologie.
Non ti dirò cosa vuol dire, cercalo sul vocabolario come ho fatto io.</p>

<p>parlare degli operatori di cast 
dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)</new_type></new_type></new_type></new_type></p>

<p>@todo: verificare
Se eliminassimo le parentesi nell’istruzione di output finale:</p>

<pre><code>cout &lt;&lt; (a + b + a) &lt;&lt; endl;
</code></pre>

<p>otterremmo un errore di compilazione, perché non esiste un operatore <code>+</code> capace di gestire la somma di un <code>int</code> (il tipo tornato dalla somma di <code>a + b</code>) con un oggetto di classe <code>A</code>.</p>

<pre><code>/** 
 * @file src/polimorfismo-simmetria.cpp
 * Overload operatori simmetrici.
 */

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

struct A
{
    int _a;
    A(int a) : _a(a) {}
};

struct B
{
    int _b;
    B(int b) : _b(b) {};   
};

int operator + (const A&amp; a, const B&amp; b) { return a._a + b._b; }
int operator + (const B&amp; b, const A&amp; a) { return a + b; }

int main ()
{
    struct A a(3);
    struct B b(5);
    
    cout &lt;&lt; (a + b + a) &lt;&lt; endl;

    return 0;
}

</code></pre>

<p>–&gt;</p>


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/ereditarieta" 
           title="Vai a: L'ereditarietà" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/stream" 
           title="Vai a: Gli stream" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
