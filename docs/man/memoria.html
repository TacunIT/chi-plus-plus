<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Gestione della memoria |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Gestione della memoria" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top">
    
    
    <a href="/man/preprocessore" 
       title="Vai a: Il preprocessore" 
       class="left">
        <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    
    <a href="/man/funzioni" 
       title="Vai a: Le funzioni" 
       class="right" >
            <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Gestione della memoria
            </h1>

            <blockquote class="motto">Amiamo ciò che ci ucciderà (se tutto va bene) </blockquote>

            <section id="testo">

                <p>La gestione della memoria è l’attività più importante della programmazione.</p>

<p>Come ti ho detto, tutti i linguaggi di programmazione sono un modo di vedere la memoria del computer.
Quando tu <em>dichiari</em> una variabile con un’istruzione come:</p>

<pre><code>int a = 1;
</code></pre>

<p>in realtà, stai dicendo al compilatore di prendere un’area di memoria di 32 bit (un <code>int</code> è grande 4 byte, ricordi?), associarle il nome <code>a</code> e scriverci dentro il valore binario:</p>

<pre><code> 00000000 00000000 00000000 00000001
</code></pre>

<p>Come puoi vedere, la maggior parte della variabile è inutilizzata, quindi, se hai a che fare con valori minori di 65.535, è meglio usare degli <code>short int</code>, che occupano solo due byte.<br />
 Allo stesso modo, se dichiari la stringa:</p>

<pre><code> const char* motto = "Amiamo ciò che ci ucciderà";
</code></pre>

<p>stai chiedendo al compilatore di prendere un’area di memoria di 28 bytes, di associarle il nome <code>motto</code> e scriverci dentro i 27 caratteri della frase più un ultimo carattere, con valore <code>0</code>, che indica la fine della stringa.<br />
Puoi usare questo metodo se sai in anticipo quanto saranno grandi le variabili con cui avrai a che fare, ma se invece devi gestire dei valori di grandezza variabile (come, per esempio, l’input di un utente), hai due possibilità: o riservi preventivamente una quantità abbondante di spazio, o la allochi sul momento, in base alle tue necessità.
Il primo caso va bene se devi gestire pochi dati di dimensioni ridotte, ma se devi gestire molte variabili di grandi dimensioni, l’allocazione dinamica, anche se più complessa da gestire, è più efficiente.<br />
Il codice seguente è un esempio di gestione statica della memoria:</p>

<pre><code>/** 
 * @file memoria-statica.cpp
 * Gestione statica della memoria.
 */
 
#include &lt;iostream&gt;

/** Definisce la dimensione della stringa */
#define DIM_STRINGA 200

using namespace std;

int main(int argc, char** argv)
{    
    /** Riserva uno spazio di 200 caratteri */
    char stringa[DIM_STRINGA];

    /** 
    * Qui dovrebbe controllare che le stringhe ci siano 
    * e che, sommate, siano più corte di 200 caratteri.. 
    */
    
    /** Copia le stringhe nell'area di memoria */
    sprintf(stringa, "%s %s", argv[1], argv[2]);

    /** Stampa la stringa a video */
    cout &lt;&lt; stringa &lt;&lt; endl;
        
    return 0;
}
       

</code></pre>

<p>Se lo compili e lo esegui, passando due stringhe come parametri, ottieni questo output:</p>

<pre><code>% g++ src/cpp/memoria-statica.cpp -o src/out/esempio                
% src/out/esempio "Amiamo ciò che ci ucciderà" "(se tutto va bene)"
Amiamo ciò che ci ucciderà (se tutto va bene)
</code></pre>

<p>Questo codice funziona se devi gestire solo due stringhe che, sommate, hanno meno di 200 caratteri: una condizione piuttosto restrittiva.
Puoi aumentare il numero di stringhe e la dimensione dello spazio in memoria, ma otterresti un programma che è o sovra o sotto dimensionato.
Questa non è buona programmazione.
Il buon programmatore non deve sprecare risorse; per lui, il proverbiale bicchiere non è né mezzo pieno né mezzo vuoto: è grande il doppio del necessario.</p>

<pre><code>/** 
 * @file memoria-dinamica.cpp
 * Gestione dinamica della memoria.
 */
 
#include &lt;iostream&gt;


using namespace std;

int main(int argc, char** argv)
{    
    /** 
    * Qui dovrebbe controllare che le stringhe ci siano.. 
    */
   
    /** Legge la lunghezza delle due stringhe */        
    size_t len1 = strlen(argv[1]);
    size_t len2 = strlen(argv[2]);

    /** 
     * Alloca un'area di memoria grande quanto le due
     * stringhe più un carattere di spazio e un
     * carattere terminatore.
     */   
    size_t lunghezza = len1 + len2 + 2; 
    char* stringa = new char[lunghezza];

    /** Copia le stringhe nell'area di memoria */
    sprintf(stringa, "%s %s", argv[1], argv[2]);

    /**
     * Mostra l'indirizzo dell'area di memoria,
     * la sua dimensione e il suo contenuto
     */
    cout &lt;&lt; (void*)stringa &lt;&lt; endl;
    cout &lt;&lt; lunghezza      &lt;&lt; endl; 
    cout &lt;&lt; stringa        &lt;&lt; endl;
    
    /** Libera la memoria allocata */
    delete[] stringa;
    
    return 0;
}

</code></pre>

<p>L’output di questo programma, molto più parsimonioso della sua versione statica, è il seguente:</p>

<pre><code>% src/out/esempio "Stringa uno" "Stringa due"        
0x7fead1405910
24
Stringa uno Stringa due

% src/out/esempio "Stringa uno" "Stringa due più lunga"
0x7fbb6e405910
35
Stringa uno Stringa due più lunga

% src/out/esempio "Stringa uno" ""                     
0x7fcf8f405910
13
Stringa uno 
</code></pre>

<p>La parola-chiave <code>new</code> permette di allocare una determinata quantità di memoria e torna un puntatore al primo indirizzo dell’area allocata:</p>

<pre><code>char* stringa = new char[lunghezza];
</code></pre>

<p>Il puntatore <code>stringa</code>, adesso, contiene l’indirizzo dell’area di memoria allocata dall’istruzione <code>new</code>. 
Se lo passiamo come parametro all’operatore <code>&lt;&lt;</code>, dato che si tratta di un puntatore a <code>char</code>, verrà visualizzato come una stringa:</p>

<pre><code>cout &lt;&lt; stringa &lt;&lt; endl;
</code></pre>

<p>Per conoscere il suo valore effettivo, dobbiamo convertirlo in un puntatore <code>void</code> con un’operazione di <a href="/man/tipi-di-dato#casting">casting</a>:</p>

<pre><code>cout &lt;&lt; (void*)stringa &lt;&lt; endl;
</code></pre>

<p>Il lato negativo dell’allocazione dinamica della memoria è che, mentre un buffer dinamico “vive” quanto il blocco di istruzioni in cui è stato creato, la memoria allocata dinamicamente rimane occupata fino a che non viene liberata con un’istruzione <code>delete</code>:</p>

<pre><code>delete[] stringa;
</code></pre>

<p>Il prossimo esempio dovrebbe aiutarti a capire come funziona la visibilità delle variabili nel C++:</p>

<pre><code>/** 
 * @file memoria-visibilita.cpp
 * Visibilità delle variabili.
 */
 
#include &lt;iostream&gt;

using namespace std;

/** 
 * Le variabili definite all'esterno delle funzioni
 * si chiamano "variabili globali" e sono visibili
 * in tutto il codice. 
 */
const char* stringa = "Stringa globale";

void funz() 
{    
    /** 
     * Le variabili definite all'interno di una 
     * funzione sono visibili solo all'interno
     * della funzione stessa. 
     */
    const char* stringa = "Stringa esterna";
    
    /** Blocco di codice generico */
    {
        /** 
         * Le variabili definite all'interno di un 
         * blocco di codice sono visibili solo 
         * all'interno del blocco di codice. 
         */
        const char* stringa = "Stringa interna";
        
        /** Mostra la variabile interna */
        cout &lt;&lt; "blocco: " &lt;&lt; stringa &lt;&lt; endl;
    }

    /** 
     * Qui è visibile la variabile esterna. 
     */
    cout &lt;&lt; "funz:   " &lt;&lt; stringa &lt;&lt; endl;

    /** 
     * L'operatore :: permette di accedere alla 
     * variabile globale. 
     */
    cout &lt;&lt; "funz:   " &lt;&lt; ::stringa &lt;&lt; endl;
    
}

int main(int argc, char** argv)
{    
    /** Richiama la funzione esterna */
    funz();

    /** 
     * La funzione main non definisce una variabile
     * "stringa", quindi mostra la variabile globale. 
     */
    cout &lt;&lt; "main:   " &lt;&lt; stringa &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>Se compili ed esegui questo codice, otterrai:</p>

<pre><code>% g++ src/cpp/memoria-visibilita.cpp -o src/out/esempio
% src/out/esempio                                      
blocco: Stringa interna
funz:   Stringa esterna
funz:   Stringa globale
main:   Stringa globale
</code></pre>

<p>Come vedi, la stringa definita globalmente è visibile sia nella funzione <code>main</code> che nella funzione <code>funz</code>; la variabile definita all’inizio della funzione <code>funz</code> è visibile all’interno della funzione stessa, ma non nel blocco di codice, dove è visibile la nuova variabile <code>stringa</code>.
L’ “aspettativa di vita” di ciascuna variabile dipende dal punto in cui è stata definita: la prima variabile “vivrà” per tutta la durata del programma; la seconda variabile viene creata quando si richiama la funzione <code>funz</code> e viene eliminata quando la funzone termina; la variabile all’interno del blocco di codice esiste solo per due istruzioni, poi il blocco di codice finisce e viene eliminata.<br />
Al contrario, quando un’area di memoria è allocata dinamicamente, rimane occupata fino a che il programma (o, più precisamente: il programmatore) non la rilascia con un’istruzione <code>delete</code>.
Se il programma fa una sola chiamata, come nel nostro esempio, il fatto che una cinquantina di byte non siano disponibili per qualche minuto non crea grossi problemi (lo so per certo perché, nella prima versione dell’esempio, avevo dimenticato di aggiungere l’istruzione <code>delete</code> alla fine e il computer ha continuato a funzionare lo stesso), se però quello stesso programma continuasse a girare sullo stesso computer per lungo tempo, a poco a poco esaurirebbe tutta la memoria disponibile, causandone il blocco.<br />
Per questo motivo, il linguaggio con la “J” ha un sistema di <em>garbage collection</em> che, come le squadre di pulizia dei Servizi Segreti, provvede a eliminare le prove dell’incompetenza dei suoi programmatori prima che questa arrechi danno ai sistemi. 
Qualcuno ti dirà che non è vero, che i programmatori “J” sono dei professionisti competenti, ma ragiona: se esiste un sistema di raccolta dei rifiuti, ci dovrà pur essere qualcuno che li produce, no?</p>

<hr />

<!--

@todo: spiegare la differenza fra dichiarazione e definizione; parlare della parola-chiave extern

Utlizzare l'peratore `delete` per illustrare il rapporto del C’hi++ con la morte, che non è più considerata un nemico da combattere, ma un fenomeno naturale necessario al buon funzonamento dell’Universo. 
Questo approccio si rirova anche nel precetto:

    Amiamo ciò che ci ucciderà (se tutto va bene) 

Introdurre il concetto di visibilità delle variabili, che serve in seguito per i PostIt.

Questo è anche il capitolo in cui parlare della posizione di un certo dato in memoria, che può variare in successive esecuzioni del programma.
Allo stesso modo, l'io cosciente di ciascuno di noi non è detto che si manifesterà nello stesso individuo, ma potrà essere "allocato" in altri esseri

-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/preprocessore" 
           title="Vai a: Il preprocessore" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/funzioni" 
           title="Vai a: Le funzioni" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
