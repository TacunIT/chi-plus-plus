<!DOCTYPE html>
<html lang="it-IT"><head>
    <title>Le funzioni |  C'hi++
</title>
    <meta charset="utf-8" />
    <meta name="viewport"     content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="canonical"            href="https://chiplusplus.org" />
    <meta     name="thumbnail"       content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta     name="keyword"         content="C'hi, C++, c plus plus, religione, open-source" />
    <meta     name="description"     content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:title"        content="Le funzioni" />
    <meta property="og:type"         content="website" />    
    <meta property="og:description"  content="Chi++ - Proposta per una metafisica open-source" />
    <meta property="og:image"        content="https://chiplusplus.org/assets/img/chi-plus-plus.png" />
    <meta property="og:image:height" content="260" />
    <link rel=icon href=/assets/img/favicon.ico type=image/x-icon>
    <link href="/assets/fa/css/all.css" rel="stylesheet"> 
    <link rel="stylesheet" href="/assets/css/screen.css" ><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-159394431-1');
</script></head>
<body class="manuale capitolo ">

    <div id="page">

        <header><nav class="menu-top man">
    
    <a title="Vai a: Gestione della memoria" 
        
        href="/man/memoria" 
        class="left"
        
       >
       <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
    </a>
    
    <a href="/" class="center" title="Torna alla home-page">
        <i class="fa fa-home fa-2x" aria-hidden="true"></i>
    </a>
    <a href="/man/indice" class="center" title="Torna all'indice del Manuale">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </a>

    <a title="Vai a: Istruzioni condizionali" 
        
        href="/man/istruzioni-condizionali" 
        
        class="right" 
        >
        <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
    </a>
    
</nav>
</header>

        <main class="redazione">
            
        

            <h1>
                Le funzioni
            </h1>

            <blockquote class="motto">Call me: IsNull</blockquote>

            <section id="testo">

                <p>Le funzioni sono la caratteristica principale del C++.</p>

<p>Lo scopo delle funzioni è di migliorare la gestione del codice.
È possibile scrivere un programma che abbia solo la funzione <code>main</code>, ma questo ha un senso solo per programmi molto semplici, come alcuni degli esempii che abbiamo visto finora.
Il flusso di un programma <em>non banale</em>, come direbbe Stroutsup, sarà sempre suddiviso in più funzioni perché in questo modo il codice sarà più facile da leggere, da correggere e da modificare.</p>

<pre><code>/** 
 * @file tipi-di-dato-dimensione.cpp
 * Mostra la dimensione dei principali tipi di dato del C++.
 */
 
#include &lt;iostream&gt;
#include &lt;iomanip&gt; 

using namespace std;

int main()
{    
    int w = 12;
    
    cout &lt;&lt; setw(w) &lt;&lt; "bool: "   &lt;&lt; sizeof(bool)   &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; "char: "   &lt;&lt; sizeof(char)   &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; "int: "    &lt;&lt; sizeof(int)    &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; "float: "  &lt;&lt; sizeof(float)  &lt;&lt; endl;
    cout &lt;&lt; setw(w) &lt;&lt; "double: " &lt;&lt; sizeof(double) &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>Questo è il codice di un esempio che abbiamo visto nel capitolo sui <a href="/man/tipi-di-dato">tipi di dato</a>.
Se decidessimo di modificare il modo in cui il programma mostra i dati all’utente, dovremmo intervenire su tutte le righe del programma, cosa che sarebbe noiosa e potrebbe generare degli errori.
Al contrario, se isoliamo la funzione di visualizzazione, le eventuali modifiche o correzioni dovranno essere applicate solo in un punto.
Il codice dell’esempio successivo è un esempio, perfettibile, di questo approccio:</p>

<pre><code>/** 
 * @file tipi-di-dato-limiti.cpp
 * Mostra i valori possibili per i principali tipi di dato del C++.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;limits&gt;

using namespace std;

/**
 * Funzione template che mostra la dimensione e i 
 * valori minimi e massimi per un tipo di dato.
 */
template&lt;typename T&gt;
void dimensione()
{
    cout &lt;&lt; sizeof(T) &lt;&lt; " bytes,"
         &lt;&lt; setw(4)   &lt;&lt; "da:"   
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::min()
         &lt;&lt; setw(4)   &lt;&lt; "a:"    
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::max() 
         &lt;&lt; endl;
}

int main()
{    
    /** Variazione della dimensione e dei valori del tipo int */
    cout &lt;&lt; setw(16) &lt;&lt; "int: "; 
    dimensione&lt;int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; "unsigned int: "; 
    dimensione&lt;unsigned int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; "short int: "; 
    dimensione&lt;short int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; "unsigned short: "; 
    dimensione&lt;unsigned short&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; "long int: "; 
    dimensione&lt;long int&gt;();
    cout &lt;&lt; setw(16) &lt;&lt; "unsigned long: "; 
    dimensione&lt;unsigned long&gt;();
    
    return 0;
}

</code></pre>
<p>Ogni volta che nel tuo codice ci sono delle istruzioni che si ripetono, valuta la possibilità di isolarle in una funzione.
Per esempio, nella funzione <code>main</code> del programma qui sopra ci sono delle funzioni di output ripetute, cosa che complica la lettura del codice, ne rende laboriosa la modifica e aumenta la probabilità di fare degli errori, perché sei tu che definisci la stringa con il nome del tipo di dato e devi fare attenzione a scrivere il valore giusto ogni volta:</p>

<pre><code>cout &lt;&lt; setw(16) &lt;&lt; "int: "; 
...
cout &lt;&lt; setw(16) &lt;&lt; "unsigned int: "; 
...
cout &lt;&lt; setw(16) &lt;&lt; "short int: "; 
...
cout &lt;&lt; setw(16) &lt;&lt; "unsigned short: "; 
...
cout &lt;&lt; setw(16) &lt;&lt; "long int: "; 
...
cout &lt;&lt; setw(16) &lt;&lt; "unsigned long: "; 
</code></pre>

<p>Nel caso specifico, si trattava di una scelta inevitabile perché, essendo uno dei primi esempii che ti ho fatto, non volevo complicarti troppo le idee, ma non è questo il modo corretto di scrivere codice.
È sbagliato (o, quanto meno, rischioso) mischiare elaborazione dei dati e funzioni di interfaccia, specie in questo caso, dove parte dell’output è già demandato a una funzione specifica.
Meglio lasciare che sia la funzione <code>dimensione</code> a gestire tutto l’output, mentre la funzione <code>main</code> si limiterà a definire il flusso dell’elaborazione, richiamando la funzione di output per i tipi di dato che ci interessano:</p>

<pre><code>/** 
 * @file funzioni-limiti-modificato.cpp
 * Esempio sui limiti del C++ con output in un'unica funzione.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;limits&gt;
#include &lt;typeinfo&gt;
#include &lt;cxxabi.h&gt;

using namespace std;

/** 
 * Mostra il nome, la dimensione e i valori minimi 
 * e massimi per il tipo di dato corrente.
 */
template&lt;typename T&gt;
void dimensione()
{
    cout &lt;&lt; setw(14)  
         &lt;&lt; abi::__cxa_demangle(typeid(T).name(), NULL, NULL, NULL) 
         &lt;&lt; ": "
         &lt;&lt; sizeof(T) &lt;&lt; " bytes,"
         &lt;&lt; setw(4)   &lt;&lt; "da:"   
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::min()
         &lt;&lt; setw(4)   &lt;&lt; "a:"    
         &lt;&lt; setw(21)  &lt;&lt; numeric_limits&lt;T&gt;::max() 
         &lt;&lt; endl;
}

/** 
 * Il nuovo codice della funzione main:  più compatto 
 * e più facile da leggere o modificare.
 */
int main(int argc, char** argv)
{    
    dimensione&lt;int&gt;();
    dimensione&lt;short int&gt;();
    dimensione&lt;unsigned short&gt;();
    dimensione&lt;long int&gt;();
    dimensione&lt;unsigned long&gt;();
    return 0;
}

</code></pre>

<p>L’istruzione:</p>

<pre><code>abi::__cxa_demangle(typeid(T).name(), NULL, NULL, NULL);
</code></pre>

<p>mostra il tipo di dato della variabile corrente.
Per il momento, accettala in maniera dogmatica; ti spiegherò il comportamento dell’operatore <code>::</code> quando parleremo delle classi.<br />
L’output di questo codice è identico a quello dell’esempio precedente; anzi: è un po’ meglio, perché ho ridotto la spaziatura della prima colonna da 16 a 14 caratteri e l’ho fatto modificando solo un’istruzione <code>setw(14)</code>, contro le sei del codice precedente:</p>

<pre><code>% g++ src/cpp/funzioni-limiti-modificato.cpp -o src/out/esempio
% src/out/esempio                                              
           int: 4 bytes, da:          -2147483648  a:           2147483647
         short: 2 bytes, da:               -32768  a:                32767
unsigned short: 2 bytes, da:                    0  a:                65535
          long: 8 bytes, da: -9223372036854775808  a:  9223372036854775807
 unsigned long: 8 bytes, da:                    0  a: 18446744073709551615
</code></pre>

<hr />

<p>Le funzioni sono uno dei <a href="/man/tipi-di-dato#funzioni">tipi di dato</a> del C++ e, come tutti i tipi di dato, possono essere <em>dichiarate</em> e <em>definite</em>.<br />
La <a id="dichiarazione">dichiarazione</a> di una funzione stabilisce il suo tipo di ritorno e i parametri richiesti in input:</p>

<pre><code>float scorporaIVA(long stipendio, float aliquota);
</code></pre>

<p>La <a id="definizione">definizione</a> di una funzione, ne stabilisce il comportamento:</p>

<pre><code>float scorporaIVA(long stipendio, float aliquota)
{
    float valore;
    valore = stipendio / ((100 + aliquota) / 100);
    return valore;
}
</code></pre>

<p>Come ti ho detto quando abbiamo parlato dei <a href="/man/linguaggi-di-programmazione">linguaggi di programmazione</a>, la generazione di un file eseguibile avviene in due fasi: per prima cosa il compilatore converte il codice C++ in un <em>file oggetto</em>, poi il <em>linker</em> trasforma i file oggetto (potrebbero essere più d’uno) in un unico eseguibile. 
Perché questo processo possa funzionare, la <em>dichiarazione</em> di una funzione deve essere presente in tutti i brani di codice che la utilizzano, per consentire al compilatore di controllare che l’utilizzo che se ne fa sia corretto; la <em>definizione</em>, al contrario, deve comparire solo una volta.</p>

<pre><code>/** 
 * @file funzioni-stipendio-main.cpp
 * Funzione main del programma con file oggetto separati.
 */
#include &lt;iostream&gt; 

/** 
 * Dichiarazione della funzione raddoppiaStipendio. 
 * L'ho messa qui per semplicità: di solito, le dichiarazioni
 * si trovano in un file di include separato.
 */
float raddoppiaStipendio(float stipendio);

/**
 * La funzione main richiama la funzione raddoppiaStipendio,
 * che è definita in un altro file sorgente.
 */
int main(int argc, char** argv)
{        
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;    
    return 0;
}

</code></pre>

<pre><code>/** 
 * @file funzioni-stipendio-funz.cpp
 * Funzione del programma con file oggetto separati.
 */

/** 
 * Definizione della funzione raddoppiaStipendio. 
 */
float raddoppiaStipendio(float stipendio)
{
    return stipendio * 2;
}

</code></pre>
<p>Se compiliamo separatamente i due file qui sopra, aggiungendo il parametro <code>-c</code>, che dice al compilatore di generare solo il file oggetto senza richiamare il linker per la generazione di un eseguibile:</p>

<pre><code>% g++ -c src/cpp/funzioni-stipendio-main.cpp -o src/out/main.o
% g++ -c src/cpp/funzioni-stipendio-funz.cpp -o src/out/funz.o
</code></pre>
<p>e poi generiamo un file eseguibile utilizzando i due file oggetto:</p>

<pre><code>% g++ -o src/out/esempio src/out/main.o src/out/funz.o        
</code></pre>
<p>otterremo tre file, due <em>object-file</em> e il file eseguibile <code>esempio</code>, che darà il risultato atteso:</p>

<pre><code>% ls -1 src/out                                               
esempio
funz.o
main.o

% src/out/esempio                                             
3000
</code></pre>

<p>Ma siccome io sono pigro, negli esempii che ti farò, utilizzerò sempre un comando unico per la compilazione e il <em>linking</em> dei programmi:</p>

<pre><code>g++ src/cpp/funzioni-stipendio-funz.cpp  \                                                       
    src/cpp/funzioni-stipendio-main.cpp  \
    -o src/out/esempio
% src/out/esempio                                                                                 
3000
</code></pre>

<p>Se non dichiarassimo la funzione <code>raddoppiaStipendio</code> nel file che contiene la funzione <code>main</code>, il compilatore ci darebbe l’errore:</p>

<pre><code>src/cpp/funzioni-stipendio-main.cpp:19:18: error: use of undeclared identifier 'raddoppiaStipendio'
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;                     ^
1 error generated.
</code></pre>

<p>Otterremmo lo stesso errore se definissimo una funzione dopo che un altra parte del programma l’ha richiamata:</p>

<pre><code>/** 
 * @file funzioni-stipendio-errore.cpp
 * Funzione che genera un errore di compilazione.
 */
#include &lt;iostream&gt; 

/**
 * La funzione main richiama la funzione raddoppiaStipendio,
 * ma il compilatore ancora non sa che esiste: errore.
 */
int main(int argc, char** argv)
{        
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;    
    return 0;
}

/** 
 * Definizione della funzione raddoppiaStipendio DOPO
 * il suo utilizzo da parte della funzione main. 
 */
float raddoppiaStipendio(float stipendio)
{
    return stipendio * 2;
}

</code></pre>

<pre><code>g++ -c src/cpp/funzioni-stipendio errore.cpp                                                    

src/cpp/funzioni-stipendio-errore.cpp:13:18: error: use of undeclared identifier 'raddoppiaStipendio'
    std::cout &lt;&lt; raddoppiaStipendio(1500) &lt;&lt; std::endl;    
                 ^
1 error generated.

</code></pre>

<p>Quando si scrive un programma in un unico file sorgente, o si definiscono le diverse funzioni prima che vengano utilizzate, mettendo la funzione <code>main</code> in fondo, oppure le si deve dichiarare all’inizio del file. 
(In realtà, non occorre metterle tutte all’inizio del file, basta che la dichiarazione preceda l’utilizzo, ma è più scomodo: mettile all’inizio.)<br />
Avresti ottenuto un errore di compilazione anche se avessi provato a separare in due file distinti la funzione <code>main</code> e la funzione <code>dimensione</code> dell’esempio qui sopra, anche se avessi dichiarato <code>dimensione</code> prima del suo utilizzo nella funzione <code>main</code>:</p>

<pre><code>% g++ src/cpp/funzioni-limiti-main.cpp -c -o src/out/main.o         
src/cpp/funzioni-limiti-main.cpp:19:5: error: use of undeclared identifier 'dimensione'
    dimensione&lt;int&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:19:19: error: expected '(' for function-style cast or type construction
    dimensione&lt;int&gt;();
               ~~~^
src/cpp/funzioni-limiti-main.cpp:19:21: error: expected expression
    dimensione&lt;int&gt;();
                    ^
src/cpp/funzioni-limiti-main.cpp:20:5: error: use of undeclared identifier 'dimensione'
    dimensione&lt;short int&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:20:22: error: expected '(' for function-style cast or type construction
    dimensione&lt;short int&gt;();
               ~~~~~ ^
src/cpp/funzioni-limiti-main.cpp:21:5: error: use of undeclared identifier 'dimensione'
    dimensione&lt;unsigned short&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:21:25: error: expected '(' for function-style cast or type construction
    dimensione&lt;unsigned short&gt;();
               ~~~~~~~~ ^
src/cpp/funzioni-limiti-main.cpp:22:5: error: use of undeclared identifier 'dimensione'
    dimensione&lt;long int&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:22:21: error: expected '(' for function-style cast or type construction
    dimensione&lt;long int&gt;();
               ~~~~ ^
src/cpp/funzioni-limiti-main.cpp:23:5: error: use of undeclared identifier 'dimensione'
    dimensione&lt;unsigned long&gt;();
    ^
src/cpp/funzioni-limiti-main.cpp:23:25: error: expected '(' for function-style cast or type construction
    dimensione&lt;unsigned long&gt;();
               ~~~~~~~~ ^
</code></pre>

<p>Questo avviene perché i <code>template</code> non sono vere funzioni, ma solo degli schemi che il compilatore utilizza per generare la versione corretta del codice.
La dichiarazione delle funzioni template, quindi deve comprendere anche la loro definizione, per dare modo al compilatore di gestire appropriatamente la chiamata<a class="nota" href="/man/note#template"></a>.</p>

<hr />

<p>Prima ti ho detto di <em>valutare</em> la possibilità di isolare in una funzione le istruzioni che si ripetono all’interno del tuo codice, perché non sempre creare una funzione è la scelta corretta.<br />
Il software, come molte attività umane, è il frutto di una serie di compromessi e tu dovrai fare scelte architetturali differenti a seconda del tipo di programma che devi realizzare.
Un buon software, oltre che funzionare correttamente, dovrebbe essere veloce, facile da modificare e richiedere poche risorse di sistema.
Alle volte, però, si deve sacrificare una di queste caratteristiche positive per esaltarne un’altra.
Per esempio, se dovessi scrivere un software estremamente veloce, potrebbe essere meglio avere delle istruzioni duplicate che delle chiamate a funzione, perché richiamare una funzione causa inevitabilmente dei rallentamenti.
<!-- @todo: spiegare perché; o qui o in una nota -->
Però, se replichi delle istruzioni, non solo aumenti le dimensioni del programma, ma lo rendi anche più difficile da leggere e da modificare, che è male.<br />
In questi casi, l’aumento delle dimensioni del codice è inevitabile, ma le <em>funzioni inline</em> ti permettono di mantenere il codice leggibile e modificabile:</p>

<pre><code>/** 
 * @file funzioni-inline-1.cpp
 * Esempio di codice con istruzioni ripetute.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt;

#define S_FILENAME  "src/out/esempio.txt"

using namespace std;

int main(int argc, char** argv)
{        
    /** 
     * Crea una variabile di classe ofstraeam 
     * per gestire il file di output  */
    ofstream doc;

    /** Apre il file di output */
    doc.open (S_FILENAME);
    cout &lt;&lt; "ho aperto il file " &lt;&lt; endl;

    /** Scrive sul file di output */
    doc &lt;&lt; "Testo del documento.\n";
    cout &lt;&lt; "ho scritto sul file" &lt;&lt; endl;

    /** Chiude il file di output */
    doc.close();
    cout &lt;&lt; "ho chiuso il file" &lt;&lt; endl;

    return 0;
}

</code></pre>
<!-- @todo: spiegare cosa sia la classe ofstream  -->
<p>Compilando ed eseguendo il codice qui sopra, ottieni:</p>

<pre><code>% g++ src/cpp/funzioni-inline-1.cpp -o src/out/esempio
% ./src/out/esempio                                   
ho aperto il file 
ho scritto sul file
ho chiuso il file
</code></pre>

<p>Le istruzioni di output nell’esempio si differenziano solo per il testo da visualizzare e potrebbero benissimo essere isolate in una funzione autonoma.</p>

<pre><code>/** 
 * @file funzioni-inline-2.cpp
 * Esempio di codice con funzione di output unica.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

#define S_FILENAME  "src/out/esempio.txt"

using namespace std;

/** Funzione di output unica */
void log(const char* messaggio)
{
    /** Mostra il messaggio a video */
    cout &lt;&lt; messaggio &lt;&lt; endl;
}

int main(int argc, char** argv)
{        
    /** Crea una variabile per gestire il file di output */
    ofstream doc;

    /** Apre il file di output */
    doc.open (S_FILENAME);
    log("ho aperto il file");

    /** Scrive sul file di output */
    doc &lt;&lt; "Testo del documento.\n";
    log("ho scritto sul file");

    /** Chiude il file di output */
    doc.close();
    log("ho scritto il file");

    return 0;
}

</code></pre>

<p>L’output di questo programma è identico a quello dell’esempio precedente, ma se aggiungi la parola chiave <code>inline</code> prima del tipo di ritorno della funzione <code>log</code>:</p>

<pre><code>inline void log(const char* messaggio)
{
    /** Mostra il messaggio a video */
    cout &lt;&lt; messaggio &lt;&lt; endl;
}
</code></pre>

<p>e compili nuovamente il programma, vedrai che la dimensione del file eseguibile è aumentata, perché il compilatore ha sostituito tutte le chiamate a funzione con una copia del codice della funzione stessa.
<!-- @todo: specificare che il compilatore può decidere di non rendere inline la funzione -->
Anche se le dimensioni dell’eseguibile sono aumentate, il codice è ancora facilmente leggibile e modificabile:</p>

<pre><code>/** 
 * @file funzioni-inline-3.cpp
 * Esempio di funzione inline.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

#define LOG_DEBUG   1
#define LOG_AVVISO  2
#define LOG_ERRORE  3

#define S_DEBUG     "debug"
#define S_AVVISO    "avviso"
#define S_ERRORE    "errore"

#define ERR_NO_FILE_NAME  -1
#define ERR_NO_FILE_OPEN  -2

using namespace std;

/** Funzione di output inline */
inline void log(const char* messaggio, int livello)
{
    /** Definisce la spaziatura del primo campo */
    cerr &lt;&lt; setw(7);  
    
    /** Scrive il livello del messaggio */
    switch(livello) {
        case LOG_DEBUG:  cerr &lt;&lt; S_DEBUG ; break;
        case LOG_AVVISO: cerr &lt;&lt; S_AVVISO; break;
        default:         cerr &lt;&lt; S_ERRORE; break;
    }
    
    /** Scrive il testo del messaggio */
    cerr &lt;&lt; ": " &lt;&lt; messaggio &lt;&lt; endl;
}

int main(int argc, char** argv)
{        
    /** Crea una variabile per gestire il file di output */
    ofstream doc;

    /** Puntatore per il nome del file di output */
    const char* filename = NULL;

    /** Se manca il nome del file di output, errore */
    if(argc &lt; 2) {
        log("specificare il path del file", LOG_ERRORE);
        return ERR_NO_FILE_NAME;
    }
    
    /** Legge il nome del file di output */
    filename = argv[1];
    
    /** Prova ad aprire il file di output */    
    doc.open (argv[1]);
    
    /** Se c'è stato un errore, lo segnala ed esce */
    if(!doc.is_open()) {
        log("impossibile aprire il file", LOG_ERRORE);    
        return ERR_NO_FILE_OPEN;    
    }
    
    /** OK, il file è pronto */
    log("ho aperto il file", LOG_AVVISO);

    /** Scrive sul file di output */
    doc &lt;&lt; "Testo del documento.\n";
    log("ho scritto sul file", LOG_DEBUG);

    /** Chiude il file di output */
    doc.close();
    log("ho chiuso il file", LOG_AVVISO);

    return 0;
}

</code></pre>

<p>Se compili il codice e lo esegui, ottieni:</p>

<pre><code>% g++ src/cpp/funzioni-inline-3.cpp -o src/out/esempio

% src/out/esempio                                     
 errore: specificare il path del file

% src/out/esempio /esempio.txt                        
 errore: impossibile aprire il file

% src/out/esempio src/out/esempio.txt                 
 avviso: ho aperto il file
  debug: ho scritto sul file
 avviso: ho chiuso il file
</code></pre>

<p>Per la cronaca: nel secondo caso, il programma fallisce perché l’utente non ha privilegi di scrittura nella <em>root-directory</em>.</p>

<hr />

<p>L’esistenza di una funzione <code>inline</code> ricorda un po’ un passo del <i>Samyutta Nikaya</i>:</p>

<blockquote>
  <p>Non esiste distinzione fra un essere, la sua funzione e il tempo della sua apparizione. Gli esseri appaiono dalla non-esistenza, esistono per un istante e poi cessano di esistere. La loro esistenza, attività e azione sono un’unica cosa. Passato e futuro sono meri nomi.<a class="nota" href="/man/note#samyutta"></a></p>
</blockquote>

<p>In generale, comunque, il ciclo di vita di una funzione prevede tre fasi distinte: la <em>dichiarazione</em>, la <em>definizione</em> e il suo successivo utilizzo:</p>

<pre><code>/** Dichiarazione */
float raddoppiaStipendio(float stipendio);

/** Definizione */
float raddoppiaStipendio(float stipendio)
{
    return stipendio * 2;
}

/** Chiamata */
float importo = raddoppiaStipendio(1500);

</code></pre>

<p>Solo la funzione <code>main</code> fa eccezione a questa regola, perché non richiede una dichiarazione e non viene richiamata da altre funzioni.
<!-- Qui si potrebbe fare un parallelo con gli elementi costitutivi dell'Universo, secondo lo Spazionismo, ma preferisco separare la dottrina dal manuale C++ vero e proprio -->
La variabile <code>float stipendio</code>, che compare fra parentesi sia nella dichiarazione che nella definizione della funzione, viene detta: <em>parametro</em> della funzione.
Il valore <code>1500</code> che viene attribuito al parametro nella chiamata a funzione, è detto: <em>argomento</em>.
Queste variabili sono chiamate anche: <em>parametri formali</em>, nel caso della dichiarazione e della definizione e: <em>parametri attuali</em>, nel caso della chiamata.<br />
Quando richiami una funzione, le puoi passare gli argomenti in tre modi: per <em>valore</em>, per <em>riferimento</em>, per <em>puntatore</em>:</p>

<pre><code>/** 
 * @file funzioni-argomenti.cpp
 * Esempio di gestione degli argomenti di una funzione.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

using namespace std;

/**
*   Chiamata per valore: tutto quello che succede qui
*   alle variabili a e b non influenza le variabili 
*   x e y della funzione chiamante.
*/
void perValore(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
    return;
}

/**
*   Chiamata per reference: tutto quello che succede qui
*   alle variabili a e b è come se fosse fatto alle variabili
*   x e y della funzione chiamante.
*/
void perRiferimento(int &amp;a, int &amp;b)
{
    int tmp = a;
    a = b;
    b = tmp;
    return;
}

/**
*   Chiamata per puntatore: anche qui, quello che succede 
*   alle variabili a e b avviene anche alle variabili x e y 
*   della funzione chiamante, ma il codice è meno chiaro.
*/
void perPuntatore(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
    return;
}

int main(int argc, char** argv)
{        
    int  x = 11; int  y = 22;    
    cout &lt;&lt; setw(20) &lt;&lt; "Valore iniziale: x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; endl;
    
    int* p = &amp;x;
    int&amp; r = x;
    
    cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; ",r=" &lt;&lt; r &lt;&lt; endl;

    /**
    *   Passaggio per valore: l'argomento della chiamata
    *   a funzione è il valore delle variabili x e y:
    */
    perValore(x,y);
    cout &lt;&lt; setw(20) &lt;&lt; "perValore: x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; endl;

    /**
    *   Passaggio per reference: l'argomento della chiamata
    *   a funzione sono le variabili x e y, ma la funzione 
    *   utilizzerà dei loro alias, non il loro valore:
    */
    perRiferimento(x,y);
    cout &lt;&lt; setw(20) &lt;&lt; "perRiferimento: x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; endl;

    /**
    *   Passaggio per puntatore: l'argomento della chiamata
    *   è esplicitamente l'indirizzo delle variabili x e y:
    */
    perPuntatore(&amp;x,&amp;y);
    cout &lt;&lt; setw(20) &lt;&lt; "perPuntatore: x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; endl;
    
    return 0;
}

</code></pre>

<p>L’output di questo programma è:</p>

<pre><code>% g++ src/cpp/funzioni-argomenti.cpp -o src/out/esempio
% src/out/esempio                                      
Valore iniziale: x=11, y=22
      perValore: x=11, y=22
 perRiferimento: x=22, y=11
   perPuntatore: x=11, y=22
</code></pre>

<p>Passare la <em>reference</em> a una variabile come argomento di una funzione equivale a passarle la variabile stessa.
Questo può essere un bene nel caso di funzioni che richiedano in input oggetti di grosse dimensioni o che abbiano la necessità di modificare direttamente il valore delle variabili passategli come parametri, ma va evitato in qualsiasi altro caso, perché permette al programma di modifi­care il valore di una variabile in maniera subdola, che può essere molto difficile da scoprire in caso di errori.<br />
Un’altra cosa da sapere, a proposito dei parametri delle funzioni, è che possono avere dei valori di default:</p>

<pre><code>/** 
 * @file _man/src/funzioni-parametri-default.cpp
 * Esempio di funzione con parametri di default.
 */

#include &lt;iostream&gt;

using namespace std;

/** Funzione con parametri di default  */
void stampaValore(int valore = 0)
{
    /** Stampa a video il valore del parametro */
    cout &lt;&lt; "Valore: " &lt;&lt; valore &lt;&lt; endl;
}

int main(int argc, char** argv)
{        
    /** Richiama la funzione con un argomento */
    stampaValore(123);

    /** Richiama la funzione senza argomenti */
    stampaValore();

    return 0;
}

</code></pre>
<p>L’output di questo programma sarà:</p>

<pre><code>% g++ src/cpp/funzioni-parametri-default.cpp -o src/out/esempio
% src/out/esempio 
Valore: 123
Valore: 0
</code></pre>

<p>Il valore di default del parametro deve essere indicato nella dichiarazione della funzione.
Ricordati però che, quando si assegna un valore di default a uno dei parametri di una funzione, bisogna fare altrettanto con tutti i parametri che lo seguono, se ce ne sono:</p>

<pre><code>void funz1(float f, void * ptr = NULL);        // OK
void funz2(double d, int b = 2, char c = 'c'); // OK
void funz3(int i = 3, int n );                 // ERRORE!
</code></pre>

<p>I valori di default si utilizzano quando a uno o più parametri della funzione è assegnato spesso un determinato valore.
Per esempio, se la funzione <code>log</code> che abbiamo visto nell’esempio precedente fosse richiamata prevalentemente con uno stesso valore per il parametro <code>livello</code>, glielo si potrebbe assegnare come default:</p>

<pre><code>inline void log(const char* messaggio, int livello = LOG_AVVISO);
</code></pre>

<p>rendendo la scrittura del codice più facile e veloce:</p>

<pre><code>log("ho aperto il file");

doc &lt;&lt; "Testo del documento.\n";
log("ho scritto sul file", LOG_DEBUG);

doc.close();
log("ho chiuso il file");
</code></pre>

<hr />

<p>In una delle nostre <a href="/man/programmatore">prime chiacchierate</a>, ti ho detto che il Buon Programmatore, mentre scrive il codice, si chiede sempre se possa esistere sistema più efficiente di fare ciò che sta facendo.
Oggi ne hai avuto una dimostrazione: abbiamo migliorato il primo esempio del paragrafo sulle funzioni <code>inline</code> unificando la gestione dei messaggi in un’unica funzione e poi l’abbiamo migliorato ancora rendendo quella funzione <code>inline</code>. 
C’è un problema, però: l’output del programma:</p>

<pre><code>% ./src/out/esempio                                   
ho aperto il file 
ho scritto sul file
ho chiuso il file
</code></pre>

<p>va bene solo se il file da gestire è uno solo, come nel nostro caso. 
Se però ci fossero due (o più) file di input o di output, sarebbe utile sapere a <em>quale</em> file si riferisca il messaggio.
Per risolvere il problema, potremmo aumentare il numero di parametri formali della funzione <code>log</code>:</p>

<pre><code>void log(int livello, const char* messaggio, const char* file);
</code></pre>

<p>ma il nuovo parametro sarebbe inutile nel caso di chiamate come:</p>

<pre><code>log(LOG_ERRORE, "specificare il path del file");
</code></pre>

<p>In alternativa, potremmo definire il messaggio all’interno della funzione chiamante:</p>

<pre><code>string s1 = "ho chiuso il file: ";
string s2 = filename;
string s3 = s1 + s2;
log(LOG_AVVISO, s3.c_str());
</code></pre>

<p>ma questo renderebbe il codice più pesante, più complicato e più lento; inoltre, trasferirebbe nelle funzioni chiamanti parte delle funzionalità di output che avevamo felicemente isolato nella funzione <code>log</code>.  <br />
La soluzione corretta per questo tipo di problemi sono le <em>funzioni con parametri variabili</em>.<br />
Un esempio tipico di questo tipo di funzioni lo abbiamo visto con la funzione del linguaggio C <code>printf</code>, che ha un primo argomento che serve a determinare il tipo e il numero degli argomenti che seguono:</p>

<pre><code>/** Dichiarazione, nel file stdio.h */
int printf(const char *format, ...) ;

/** Utilizzo */
printf("stringa: %s; intero: %d", "codice errore", -1);

</code></pre>

<p>Per indicare degli argomenti variabili, nella dichiarazione di una funzione, si utilizzano tre punti, dopo i parametri fissi:</p>

<pre><code>void log(int livello, int n_parametri, ...);
</code></pre>

<p>Nella definizione della funzione, per gestire i parametri, è necessario creare un ciclo di lettura utilizzando tre marco definite nel file <code>stdarg.h</code>:</p>

<pre><code>void va_start(va_list ap, lastfix);
type va_arg(va_list ap, type);
void va_end(va_list ap);
</code></pre>

<p><code>va_start</code> inizializza la lista di variabili <code>ap</code> affinché possa ricevere gli argomenti variabili; il parametro <code>lastfix</code> specifica quale sia l’ultimo parametro fisso della funzione.</p>

<p><code>va_arg</code> torna il successivo parametro nella lista <code>ap</code>; il parametro <code>type</code> indica il tipo di dato del parametro.</p>

<p><code>va_end</code> termina l’elaborazione dei parametri e deve essere sempre chiamata prima che la funzione termini.</p>

<pre><code>/** 
 * @file funzioni-variabili.cpp
 * Esempio di funzione con parametri variabili.
 */

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;fstream&gt; 

#define LOG_DEBUG   1
#define LOG_AVVISO  2
#define LOG_ERRORE  3

#define S_DEBUG     "debug"
#define S_AVVISO    "avviso"
#define S_ERRORE    "errore"

#define ERR_NO_FILE_NAME  -1
#define ERR_NO_FILE_OPEN  -2

#define S_ERR_NO_FILE_NAME  "specificare il path del file"
#define S_ERR_NO_FILE_OPEN  "impossibile aprire il file:"

using namespace std;

/** Funzione di output con parametri variabili */
void log(int livello, int n_parametri, ...)
{

    /** Definisce la spaziatura del primo campo */
    cerr &lt;&lt; setw(8);  
    
    /** Scrive il livello del messaggio */
    switch(livello) {
        case LOG_DEBUG:  cerr &lt;&lt; S_DEBUG ; break;
        case LOG_AVVISO: cerr &lt;&lt; S_AVVISO; break;
        default:         cerr &lt;&lt; S_ERRORE; break;
    }

    /** Scrive il carattere di separazione */
    cerr &lt;&lt; " | ";

    /** Dichiara la variabile per la lista dei parametri */    
    va_list lista_parametri;
    
    /** 
     * Inizializza la lista dei parametri e considera
     * tutti gli argomenti dopo n_parametri come variabili.
     */
    va_start(lista_parametri, n_parametri);

    /** Legge tutti i parametri nella lista e li scrive a video */
    for(int p = 1; p &lt;= n_parametri; p++) {        
        cerr &lt;&lt; va_arg(lista_parametri, char*) ;        
    }    

    /** Chiude la lista dei parametri */        
    va_end(lista_parametri);
    
    /** Scrive il testo del messaggio */
    cerr &lt;&lt; endl;

}

int main(int argc, char** argv)
{        
    /** Crea una variabile per gestire il file di output */
    ofstream doc;

    /** Puntatore per il nome del file di output */
    const char* filename = NULL;

    /** Se manca il nome del file di output, errore */
    if(argc &lt; 2) {
        log(LOG_ERRORE, 1, S_ERR_NO_FILE_NAME);
        return ERR_NO_FILE_NAME;
    }
    
    /** Legge il nome del file di output */
    filename = argv[1];
    
    /** Prova ad aprire il file di output */    
    doc.open (argv[1]);
    
    /** Se c'è stato un errore, lo segnala ed esce */
    if(!doc.is_open()) {
        log(LOG_ERRORE, 2, S_ERR_NO_FILE_OPEN, filename);    
        return ERR_NO_FILE_OPEN;    
    }
    
    /** OK, il file è pronto */
    log(LOG_AVVISO, 2, "ho aperto il file: ", filename);

    /** Scrive sul file di output */
    doc &lt;&lt; "Testo del documento.\n";
    log(LOG_DEBUG, 2, "ho scritto sul file: ", filename);

    /** Chiude il file di output */
    doc.close();
    log(LOG_AVVISO, 2,  "ho chiuso il file: ", filename);

    return 0;
}

</code></pre>

<p>L’output di questo codice è:</p>

<pre><code>% g++ src/cpp/funzioni-variabili.cpp -o src/out/esempio

% src/out/esempio                    
  errore | specificare il path del file

% src/out/esempio /esempio.txt 
  errore | impossibile aprire il file:/esempio.txt

% src/out/esempio src/out/esempio.txt
  avviso | ho aperto il file: src/out/esempio.txt
   debug | ho scritto sul file: src/out/esempio.txt
  avviso | ho chiuso il file: src/out/esempio.txt```
</code></pre>

<!-- @todo: Aggiungere un paragrafo sui valori di default per i parametri -->

<hr id="dottrina" />

<p>In un romanzo sulla vita dello spadaccino giapponese Myamoto Musashi c’è una frase che è la logica conseguenza del suggerimento di Jacopone da Todi:</p>

<blockquote>
  <p>Non bisogna interferire nel funzionamento dell’Universo, ma prima è necessario capire quale sia, il funzionamento dell’Universo<a href="/man/note/#musashi" class="nota"></a></p>
</blockquote>

<p>Il problema dei romanzi è che ti dicono spesso cosa fare, ma non ti spiegano quasi mai come farlo, o perché.<br />
Diffida dei maestri che sanno solo insegnare, perché tutto ciò che ti raccontano l’hanno imparato dai libri.
Un buon maestro deve eccellere in qualcosa, che sia la scherma, il tiro con l’arco, la carpenteria o la manutenzione delle motociclette.
Può non essere <em>il</em> migliore, ma deve essere <em>fra i</em> migliori; solo così, saprai che le sue idee sono valide.
Al contrario, i maestri che non sono mai usciti da una scuola, non hanno mai dovuto mettere le loro idee alla prova dei fatti.
Ti insegnano ciò che pensano sia giusto, ma ciò che è giusto o vero in una scuola, non sempre è altrettanto vero o giusto nel mondo reale.<br />
È facile essere dei santi, in un monastero, fra persone che hanno la tua stessa cultura<!-- qui, in senso letterale --> e i tuoi stessi principii; il difficile è restare dei santi anche fuori. 
Il Buddha Shakyamuni predicò la Benevolenza Universale perché visse in India, duemilaseicento anni fa, ma se fosse rimasto imbottigliato nel traffico di una città, dopo una giornata di lavoro, forse le sue idee sarebbero state più simili a quelle di Nietzsche.<br />
Per fortuna, Musashi — quello vero, il Samurai —, fu sempre molto chiaro sia su ciò che è giusto fare che sul modo di ottenerlo. 
Nel <em>Libro dei Cinque Anelli</em>, diede ai suoi discepoli nove regole di vita:
<!-- 
 @todo: verificare la traduzione di questi punti e dei successivi 
 @nota: uso il nome (Musashi) in vece del cognome (Myamoto), così come direi "Raffaello" o "Michelangelo".
--></p>

<blockquote>
  <ul> <li>Non pensare in maniera disonesta. <li>La Via è nel costante allenamento. <li>Pratica molte arti. <li>Conosci la Via e i modi di tutti i mestieri. <li>Distingui vantaggi e svantaggi di ogni cosa. <li>Sviluppa una comprensione intuitiva delle cose. <li>Percepisci anche ciò che non può essere visto con gli occhi. <li>Presta attenzione anche alle cose più insignificanti. <li>Non perdere tempo in attività inutili.
</li></li></li></li></li></li></li></li></li></ul>
</blockquote>

<p>Nel <em>Dokkodo</em>, scritto una settimana prima della sua morte, fu ancora più specifico:</p>

<blockquote>
  <ul> <li>Non agire in maniera contraria al tuo destino. <li>Non ricercare una vita facile. <li>Non avere pregiudizi od ostilità per qualcosa. <li>Pensa a te stesso con leggerezza e in maniera profonda agli altri. <li>Sii distaccato dal desiderio. <li>Non avere rimpianti per ciò che hai fatto. <li>Non essere geloso degli altri. <li>Non avere attaccamento per alcuna cosa. <li>Non portare rancore. <li>Non pensare alla vita sentimentale. <li>Non avere né preferenze né avversioni. <li>Sii indifferente al luogo in cui vivi. <li>Non ricercare il cibo per il suo gusto. <li>Fà che le future generazioni non siano legate ad armi antiche. <li>Evita le superstizioni e i taboo. <li>Utilizza solo gli strumenti necessarii e non conservare ciò che è inutile. <li>Sii preparato a morire. <li>Quando sei vecchio, ciò che possiedi non ha molta importanza. <li>Rispetta Buddha e gli Dei, ma non contare sul loro aiuto. <li>Non abbandonare il tuo onore, anche se ciò significa abbandonare la vita. <li>Non deviare mai dalla Via.
</li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></li></ul>
</blockquote>

<p>Queste regole, che hanno permesso a Musashi di arrivare alla venerabile età di sessant’anni<a href="/man/note/#eta" class="nota"></a>, dopo essere sopravvissuto vittorioso ad altrettanti combattimenti con tutti i migliori spadaccini del suo tempo, possono aiutarti a capire quale sia il funzionamento dell’Universo e cosa fare per non perturbarlo.<br />
La pratica delle arti, siano esse intelletuali o marziali, e la conoscenza dei mestieri, unite all’attenzione per tutto ciò che ti circonda, aumenteranno il tuo bagaglio di esperienza e ti permetteranno di distinguere i pro e i contro di ogni situazione.
Questo ti libererà dal demone dell’invidia, perché imparerai che tutte le  condizioni, anche quelle apparentemente idilliache, hanno dei lati negativi.
Il passo successivo sarà affrancarsi dal desiderio e dall’attaccamento alle cose: così come la funzione <code>log</code> ha bisogno di sapere quali siano i parametri fissi e quali siano quelli variabili, tu dovrai imparare a distinguere i tuoi desiderii dalle tue necessità, per sfuggire all’influsso dell’Annosa Dicotomia.<br />
La Via, con la “V” maiuscola è simile a una via con la “v” minuscola.
Lungo la via, incontri dei cartelli stradali, che ti indicano la direzione in cui procedere o la velocità da tenere, e dei cartelloni pubblicitarii, che ti segnalano delle attrazioni nelle vicinanze e ti invitano a deviare dal tuo cammino per andarle a visitare.
Allo stesso modo, lungo la Via, troverai delle necessità, che ti instraderanno verso la tua destinazione e dei desiderii, che ti dis-trarranno dal tuo percorso e ti at-trarranno verso destinazioni alternative.
Se tu agirai in base alle necessità, saprai sempre che ti stai muovendo nella direzione giusta, anche quando sarai costretto a rallentare o a percorrere strade che non gradisci.
Se tu, invece, agirai in base ai desiderii andrai di qua e di là, come <em>un asino privo di briglie</em><!-- @todo: cercare la citazione da Attar --> e quando alla fine tornerai sulla strada giusta, potresti non avere più il tempo per arrivare alla tua destinazione.</p>

<hr />

<p>Ti ho parlato delle regole di Musashi non perché siano le uniche disponibili, ma perché sono estremamente personali.
Attingono ai principii di altre discipline, come il Buddismo, il Bushido o il Tao, ma sono <em>something else</em>, come direbbe Eddie Cochran.<br />
Tu dovrai fare altrettanto: imparare tutto ciò che puoi, tanto dai buoni quanto dai cattivi maestri, e poi definire le tue regole di vita, che potranno essere uguali, simili o del tutto differenti da quelle che ti sono state insegnate. <br />
<!-- 
    @todo: aggiugere testo su Maestro Canaro e 10C 
-->
La Via, così come la Verità, è una modella, che ciascuno di noi ritrae dal suo punto di vista, cercando di intuire il corpo che si cela dietro alle pieghe del drappeggio. 
Ritrarla nello stesso modo in cui l’ha fatto un altro sarebbe sbagliato, perché il tuo punto di vista non è uguale al suo, ma guardarla da più punti di vista può aiutarti a capire meglio la sua forma.
Musashi dice di prestare attenzione anche alle cose insignificanti, Nan-in e Tenno sviluppano il loro Zen di Ogni Istante, Wittgenstein nei suoi <em>Diari</em>, scrive:</p>

<blockquote>
  <p>Solo una cosa, è necessaria: essere capace di osservare tutto ciò che ti accade. Concentrarsi! Dio mi aiuti!</p>
</blockquote>

<p>È chiaro che stanno tutti dipingendo la stessa immagine, anche se ciascuno lo fa con il suo stile.
È per questo motivo, che Musashi prescrive di conoscere la Via degli altri mestieri: perché c’è sempre qualcosa da imparare, da chi fa bene il suo lavoro. 
Questo, per esempio, è il parallelo che lui fa fra lo stratega e il carpentiere:</p>

<blockquote>
  <p>Per edificare una casa è necessaria un’accurata scelta dei materiali. Per i pilastri esterni si sceglieranno dei tronchi diritti e senza  nodi, mentre per quelli interni si possono usare dei tronchi diritti  con qualche piccolo difetto. Per le soglie, gli architravi, gli infissi e  le porte scorrevoli si useranno i legni migliori per l’aspetto, anche  se non sono troppo robusti, e così via. Per le parti strutturali non è  importante l’aspetto estetico quanto la robustezza. Il legname meno pregiato e con molti nodi viene invece utilizzato per i ponteggi e, alla fine, viene bruciato.<a href="/man/note/#5anelli" class="nota"></a></p>
</blockquote>

<p>Ciò che è vero per il carpentiere, cambiando il punto di vista, è vero anche per lo stratega e potrà esserlo anche per te, se ti troverai ai gestire un progetto o un gruppo di lavoro.
Anche come programmatore, comunque, dovrai tenerti costantemente aggiornato sulle tecniche e sui linguaggi di programmazione e dovrai conoscere il modo in cui lavora chi si occupa delle basi-dati o dei sistemi.
Dovrai essere capace di identificare i malfunzionamenti anche se non hanno effetti sull’interfaccia grafica e potrai riuscirci solo se presterai attenzione anche al più piccolo dettaglio.<br />
Cambiano i nomi, perché sono passati quattro secoli, ma i problemi restano gli stessi, così come le soluzioni.</p>

<!-- 
Fare un esempio di funzione valida per tutti i linguaggi.

Va aggiunto un paragrafo sulle funzioni ricorsive, o qui o nel testo tecnico, sfruttandolo come esempio di dogma autoreferenziale, tipo: "la Bibbia è stata scritta da Dio; è vero perché è scritto nella Bibbia"

-->


            </section>
            
        

        
        </main>

        <footer>
    <nav>
        
        
        <a href="/man/memoria" 
           title="Vai a: Gestione della memoria" 
           class="left">
            <i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>
        </a>
        
        
        <a href="#top" 
           title="Torna all'inizio" >
           <i class="fa fa-angle-double-up fa-2x" aria-hidden="true"></i>
        </a>

        
        <a href="/man/istruzioni-condizionali" 
           title="Vai a: Istruzioni condizionali" 
           class="right" >
                <i class="fa fa-chevron-right  fa-2x" aria-hidden="true"></i>
        </a>
                

    </nav>

</footer>


    </div>

  </body>

</html>
