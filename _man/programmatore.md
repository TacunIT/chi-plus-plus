---
status:     pubblicato
layout:     manuale
title:      Il buon programmatore
class:      capitolo
permalink:  /man/programmatore
quote:      "È stata una giornata estenuante: questa mattina ho tolto una virgola dal mio codice e stasera ce l'ho rimessa"
---

Le principali discipline dell'informatica sono: la gestione del personale, la gestione dei progetti, la gestione dei sistemi e la programmazione.
Un buon maestro deve essere abile in tutte le discipline, ma può eccellere solo in una di esse, perché per arrivare all'eccellenza dovrà dedicare a quella disciplina tutta la sua vita e nessuno ha più di una vita.  
È fondamentale che il maestro conosca e pratichi tutte le discipline, perché solo conoscendo le problematiche connesse a ciascuna fase e a ciascuna disciplina, potrà raggiungere l'eccellenza in una di esse.
La disciplina più alta é la programmazione, perché non ha a che fare con entità reali, ma solo con concetti astratti.  
Non c'è differenza fra lo scrivere codice e il gestire un'azienda: è come osservare una medesima città su carte di diversa scala.
Se il rapporto di scala è basso, si avrà una buona visione di insieme, ma pochi dettagli; se il rapporto di scala è alto, si avranno molti dettagli, ma una visione di insieme limitata. 
La città, però, sarà sempre la stessa.  
Nella *Bhagavad Gita* si dice:

> {{ site.data.citazioni.gita.azione }}<a id="azione" href="/man/note/#azione" class="nota"></a>

È così che opera il buon programmatore: scrive del buon codice, anche se non beneficerà mai dei suoi effetti. Scrive del buon codice perché non può farne a meno.  
Scrivere codice non è un mestiere, è una deformazione mentale.
Il <span id="buon-programmatore">buon programmatore</span> è un disadattato che ha la fortuna di essere retribuito per dare sfogo ai lati peggiori della sua personalità.
Mentre scrive il codice, la mente del buon programmatore lavora su tre livelli: il primo livello decide la sequenza delle istruzioni necessarie a far funzionare il programma; il secondo livello ne controlla costantemente la correttezza sintattica e semantica; il terzo livello verifica se ci sia un sistema più efficiente per fare la stessa cosa.
I buoni programmatori sono paranoici ed è giusto che sia così.
Le istruzioni di un programma sono eseguite milioni di volte nel corso
della loro vita e anche una probabilità minima di errore è
inammissibile.
Ricòrdati: il codice funziona come vuoi tu solo se non gli lasci altra scelta.  
Nei tempi andati ci fu chi sostenne una teoria bizzarra secondo la quale i programmi, per essere veramente efficaci, sarebbero dovuti essere rapidi, ridondanti e imprecisi.
L'idea di fondo era che, essendo impossibile, sopra un certo livello di complessità, produrre del codice privo di errori, sarebbe stato meglio produrre molti programmi mediamente imprecisi e valutare l'insieme dei loro risultati.
L'unica cosa che posso dire a loro discolpa è che a quei tempi si pensava alla produzione di codice come a un'attività di tipo industriale e non come a una disciplina mistica.  
Anche il buon sistemista è paranoico, ma un buon programmatore difficilmente potrà essere un buon sistemista.
Il buon sistemista ricerca la ridondanza, perché la ridondanza aumenta l'affidabilità del sistema.
Il buon programmatore rifugge la ridondanza, perché la ridondanza diminuisce l'efficienza del codice.
Il programmatore è Mercurio, il sistemista è Vulcano.

---

Un buon programmatore dovrebbe conoscere più di un linguaggio di programmazione.
Che si conosca a fondo solo un particolare linguaggio è ammissibile, ma una visione di insieme è sempre necessaria per operare delle scelte.
Quelli che al giorno d'oggi si definiscono “programmatori” non sono nient'altro che dei forzati di un determinato linguaggio.
Allevati in batteria come i polli, conoscono soltanto quello, lo ritengono il migliore e si interessano degli altri linguaggi solo allo scòpo di evidenziarne le pecche.
Questo è improduttivo e pericoloso perché, quando con il passare del tempo, questi "programmatori" diventeranno analisti, gestiranno i progetti e le persone a loro affidate con la stessa miopia, producendo sistemi instabili, costosi e difficili da mantenere.
Ciò è immorale.  
All'estremo opposto stanno coloro i quali dedicano il loro tempo e le loro energie allo studio dei linguaggi e delle metodologie di progettazione del passato.
Sono capaci di citare costrutti in LISP, Ada o Eiffel con grande precisione, ma non hanno mai scritto una riga di codice originale in vita loro.
I più abili riescono a modificare i programmi di esempio che trovano nei libri di testo o nei manuali, sostituendo gli algoritmi con altri brani di codice classico, ma senza alcun apporto creativo.
Fra questi individui e i veri programmatori c'è la stessa differenza che passa fra un sessuologo e un pornodivo.

<hr id="dottrina">

{{ site.data.canaro.paranoici }} 

<!--
    @todo applicare le categorie caratteriali aristoteliche al SW.
    (cfr. Etica Nicomachea)
-->
