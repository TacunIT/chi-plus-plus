­

C\'hi++

  ------------ -------------------------------------
  Autore:      
  Revisione    
  Data         
  Indirizzo:   Via dei Polacchi, 42 - 00187 - Roma
  Telefono:    +39 346.500.8962
  E-mail:      r.canaro\@canaro.net
  Sito Web:    http://canaro.net
  ------------ -------------------------------------

Dedicato a Wayne Martini,

che mi diede il libro e disse:

"Read it, it changed my life."

Io pensai:

"Sempre esagerati, 'sti americani!"

Premessa
========

Nacqui da famiglia ricca, ma troppo tardi.

Secondogenito, vidi la florida impresa paterna andare in dote - per
diritto di nascita, ma anche per naturale inclinazione - ai miei
monozigotici fratelli maggiori e, com\'è consuetudine per i figli
cadetti, fui avviato alla vita monastica: entrai in seminario all'età di
nove anni e presi i voti il giorno del mio sedicesimo compleanno.

Conobbi il Maestro sei anni dopo. Fui mandato da lui perché un vecchio
programma, dopo quasi un decennio di attività ininterrotta, aveva avuto
dei problemi e non c'era nessuno nel monastero che sapesse come porvi
rimedio.

Pur avendo trascorso in quello stesso edificio due terzi della mia vita,
non avevo mai incontrato il Maestro, prima di allora. Sapevo poco di
lui, principalmente che non era bene saperne molto e non l'avevo mai
visto né nel refettorio, né in occasione di celebrazioni o emergenze.
Era, per tutti noi giovani, una sorta di figura mitologica, maligna o
benigna a seconda dei racconti che su di lei si ascoltavano.

Bussai alla sua porta con cautela, quasi mi aspettassi terribili
rappresaglie per quell\'indebita intromissione nella sua vita e con
altrettanta cautela accettai il suo l'invito a entrare.

L'arredamento delle nostre stanze era semplice ed essenziale, ma in
confronto a quello della cella del Maestro, appariva sfarzoso. Non
c'erano finestre alle pareti e le uniche due fonti di luce erano una
piccola lampada e lo schermo di quello che sembrava un vecchio computer
risalente alla fine del XX secolo.

In un angolo c'era un curioso divano-letto, simile alle panchine dei
parchi, che doveva essere il suo giaciglio per la notte; al lato opposto
della stanza, una sorta di libreria realizzata con mattoni e assi di
legno grezzo sorreggeva i suoi pochi effetti personali. Nulla copriva la
pietra del pavimento.

\- Il mio programma sta dando degli errori.

Risposi di sì, anche se la sua era stata un\'affermazione.

\- Era stato istruito a farlo. Adesso lo mettiamo a posto.

Cominciò a battere sulla tastiera del suo computer e io mi avvicinai
incuriosito. Quando arrivai a vedere l'immagine proiettata dallo schermo
capii perché nessuno all'interno del convento sapesse intervenire sul
suo programma.

\- Sì, è C++ - disse il Maestro, intuendo la mia curiosità - Un tempo si
pensava che fosse il linguaggio del futuro. Come di tutti i linguaggi,
del resto.

Chiesi cosa volesse dire che il programma era stato istruito a dare
errori.

\- Questa è una domanda sciocca. D'altro canto, il fatto che stessi
dicendo la verità è evidente, visto che non ti ho nemmeno chiesto che
genere di difetto fosse stato rilevato. Bene, puoi andare a dire al tuo
superiore che il vecchio pazzo ha corretto l\'errore.

Non riuscivo a distogliere lo sguardo dallo schermo, ero come
ipnotizzato da quello strano codice che potevo capire solo in parte. In
quelle sequenze di istruzioni c'era qualcosa che non avevo mai visto
prima: un ritmo, una sorta di indefinibile bellezza di cui mi ero
innamorato a prima vista. Chiesi al Maestro di insegnarmi il C++.

\- E perché mai? ci sono linguaggi molto più facili da usare.

Gli spiegai che non si trattava di un interesse tecnologico, ma estetico
e lui restò in silenzio per qualche secondo, considerando quello che
avevo detto.

\- Qual'è il dovere di un programmatore? - chiese poi.

Lo pregai di definire meglio la sua domanda.

\- Torna qui domani, se mi saprai dire qual\'è il dovere di un
programmatore, ti insegnerò il C++.

Passai tutta la notte a meditare su quella strana domanda e la mattina
dopo mi presentai al Maestro. Dissi che secondo me il dovere di un
programmatore era quello di scrivere del buon codice. Il Maestro non
distolse nemmeno lo sguardo dallo schermo e disse:

\- Torna qui domani, se mi saprai dire cosa vuol dire scrivere del buon
codice, io ti insegnerò il C++.

Com\'è facile intuire, anche il giorno dopo e per diversi giorni a
seguire il Maestro trovò il modo di rimandare l'inizio del mio tirocinio
con domande ancora più specifiche che andavano a colpire un'imprevista
lacunosità delle mie risposte.

Analizzai ogni possibile aspetto della produzione del software,
dall'utilizzo delle risorse di sistema alle implicazioni sociali
dell'incremento dell\'occupazione derivante dall'evoluzione dei
programmi, ma non ci fu nulla da fare: ogni volta il Maestro riuscì a
trovare una scappatoia per venire meno al suo impegno.

Alla fine non ne potei più. Esasperato, dissi che ne avevo abbastanza di
quella sua ostinata capziosità: per quanto io potessi essere specifico
nelle mie risposte, ci sarebbe sempre stato un margine di
indeterminazione. Se voleva insegnarmi il C++ doveva iniziare quel
giorno stesso. Il Maestro mi fissò e, sorridendo, spense il suo
computer.

\- No, per oggi basta. Vieni domani per la seconda lezione.

Negli ultimi mesi la salute del Maestro è peggiorata e così gli ho
chiesto il permesso di trascrivere i suoi insegnamenti per poterli
trasmettere a mia volta ad altri discepoli.

Con mia grande sorpresa, ha accettato.

In C pit
========

Quello che stai facendo è inutile.

Voglio che tu lo scriva all\'inizio del tuo libro, così la gente non
perderà tempo a leggerlo.

Tutto ciò che si fa con uno scopo è inutile.

In particolare i libri, perché sono stupidi: non si accorgono di quando
sbagliano e anche se se ne accorgessero non ci potrebbero fare nulla,
seguiterebbero a dire una cosa sbagliata.

Tu stai per scrivere una nuova Bibbia: sei sicuro di volerlo fare?

Tutti i libri sacri partono da un presupposto sbagliato: che valga la
pena scriverli, perché l\'Umanità può essere salvata e, soprattutto,
merita di essere salvata.

Non è così.

Credi che se gli autori della Bibbia o dei Vangeli avessero potuto per
un prodigio pre-vedere le conseguenze ultime delle loro opere, le
guerre, le morti, le sofferenze, li avrebbero scritti lo stesso?

I libri sacri sono sempre stati strumentalizzati dai potenti, cosa ti fa
pensare che per il tuo non succederà lo stesso?

Tu proietti su questo linguaggio ormai morto delle aspettative
personali, speri che possa far rivivere il tempo passato e ti illudi che
il tempo passato sia meglio di quello presente, ma non è così.

Il passato è una vecchia amante che, col suono della sua voce, ci
ricorda i piaceri vissuti insieme, ma che bada a restare alle nostre
spalle per nasconderci il suo volto rugoso.

Io ti insegnerò il Chi++, non ti indicherò la Via.

Quando qualcuno ti indica la Via, ricordati sempre che una via la si può
percorrere in due direzioni. Una direzione ci avvicina alla nostra méta;
una direzione ce ne allontana.

La direzione è importante, non la via.

Se un uomo conosce la direzione, la via non ha più alcuna importanza.

Le nuvole che oscuravano il cielo questa mattina sono scomparse, il
cielo della notte trabocca di stelle.

Sono cose che si notano, a mano a mano che si invecchia.

Io le noto da quando ero bambino.

Quello che ti insegnerò non è illegale, ma è come se lo fosse.

Mitopoietica del C\'hi++
========================

Il settimo giorno, Dio fece il backup

Su di me ci sono due teorie. Qualcuno pensa che io sia impazzito
cercando di fare il *debug* dell\'Universo, altri pensano invece che io
abbia deciso di fare il *debug* dell\'Universo perché sono pazzo.

Anche il Maestro Canaro fu accusato di essere pazzo quando disse di
essere stato incaricato da Dio di fare il *porting* dell\'Universo dal
COBOL al C++, ma non era pazzo.

Ho conservato questi documenti: sono l'ultima pagina del suo diario e le
relazioni che furono inviate alla società per cui lui lavorava mentre
era distaccato dal "Cliente".

Mettili all\'inizio del tuo libro, così tutto ciò che diremo poi, non
sarà che una ripetizione.

Ultima pagina del diario del Maestro Canaro (8 Aprile)

Sono in ufficio e sto lavorando quando squilla il telefono.

La voce che mi risponde è piuttosto bassa e ha un'eco curiosa.

Mi fa:

\- Canaro, sono Dio, ho bisogno di te.

\- Marco, ho da fare, ci sentiamo dopo.

Riattacco. Un attimo dopo il telefono squilla di nuovo. Stavolta faccio
caso al tipo di squillo e deduco che si tratta di una telefonata
esterna.

\- Canaro, non sono il tuo collega, sono davvero Dio. Devi aiutarmi a
fare il porting dell'universo in C++.

Non posso fare a meno di sorridere.

\- Carina. E anche il sintetizzatore vocale mi sembra che funzioni
piuttosto bene. Senti, finisco questa relazione e ti offro un caffé, ma
adesso lasciami lavorare.

Riattacco di nuovo e di nuovo il malefico oggetto fa sentire la sua
voce. È un'esterna, non posso rischiare: potrebbe essere un cliente, ma
so già che\...

\- Canaro, ascoltami una buona volta: sono davvero Dio e ho bisogno che
tu mi risolva un problema.

Sto per dirgli qualcosa di cui poi mi pentirò, ma la voce continua:

\- Se non mi credi, stacca la spina del telefono.

\- Ma per favore\...

\- Staccala!

Più per curiosità che altro, vado a vedere il suo bluff. Stacco la
spina.

\- Adesso mi credi?

Devo dire che per un attimo il mio scetticismo vacilla. Cerco una
possibile spiegazione.

\- Hai messo una ricevente nella cornetta.

\- Testardo eh? Va bene: scegli un oggetto a caso.

\- Per fare cosa?

\- Per utilizzarlo come cornetta, uno che il tuo collega non possa aver
manomesso.

\- Marco, per favore\...

\- Avanti, cosa ti costa? Visto che sei così sicuro\...

\- La mia pipa va bene?

\- Quello che vuoi: avvicinala all'orecchio.

Vediamo dove vuole andare a parare: tiro fuori la mia pipa dall'astuccio
di pelle e avvicino il fornello all'orecchio.

\- Fatto, - dico e intanto mi guardo intorno in attesa dello scherzo.

\- Lo so,- la voce è nel fornello di radica. - Adesso, se per favore
potessimo riprendere la nostra conversazione telefonica\... Non vorrei
che entrasse qualcuno e ti vedesse parlare con una pipa.

\- Premetto che io di queste cose di computer non ci capisco niente,
- mi dice appena ho riattaccato la spina del telefono. - Mio figlio,
invece, i computer li sa usare e mi ha detto che sarebbe meglio fare il
porting dell'universo in un linguaggio a oggetti, suggerendomi questo
C++. Ora, vedi, io vado forte in scienze naturali, non in informatica, e
tutti questi termini tecnici, per me, sono misteriosi: cosa vuol dire
fare il porting di qualcosa? e cosa sono i linguaggi orientati agli
oggetti?

"Bella domanda\..."[]{#anchor}, pensai. Anni prima avevo scritto un
manuale di C++ e il paradigma a oggetti era l'argomento del primo
capitolo. Se solo lo avesse letto\...

\- Ho anche dato una scorsa al tuo libro, ma non ci ho capito niente:
scrivi di schifo, lasciatelo dire. E poi, mi sono detto, chissà quante
cose sono cambiate nel frattempo, così ho deciso di chiamarti.

\- Innanzitutto la ringrazio per i complimenti, poi, per venire alla sua
domanda, fare il porting di qualcosa vuol dire riscrivere
un'applicazione con un linguaggio di programmazione differente da quello
in cui era stata scritta inizialmente.

\- E questo a quale scopo?

\- Di solito per sfruttare le potenzialità del nuovo linguaggio o per
poter utilizzare l'applicazione in un sistema per cui il vecchio
linguaggio non sia valido.

\- Come tradurre i dieci comandamenti dall'Ebraico al Latino?

\- Qualcosa di simile.

\- E questo "C++"? Cosa vuol dire "linguaggio orientato agli oggetti"?

\- Che invece di tipi di dato astratti come numeri e caratteri, permette
di utilizzare dei tipi di dato simili a quelli reali.

\- Non ho capito.

\- I vecchi linguaggi di programmazione costringevano il programmatore a
utilizzare solo dei tipi di dato predefiniti: numeri, lettere, date.
Questo va bene per un certo tipo di applicazioni, ma rende difficile
scrivere applicazioni più complesse dove può essere utile sfruttare un
linguaggio che sia capace di gestire anche dei nuovi tipi di dato,
definiti dall'utente. In C++, il linguaggio che suo figlio le ha
consigliato, questo si ottiene per mezzo delle classi.

\- Come in zoologia?

\- Una specie. Per classe si intende un tipo di dato non standard, del
quale si può definire il comportamento.

\- Fammi un esempio, che non capisco. E poi basta con questo lei,
passiamo al "tu", che è più semplice.

\- Mettiamo che tu abbia due stringhe\...

\- Non porto scarpe con le stringhe, uso i Birkenstock.

\- Intendevo delle sequenze di caratteri. Ora, per come un computer
gestisce i dati normalmente, non ha senso addizionare due stringhe, dato
che non si tratta di un tipo di dato numerico, ma si può definire una
classe "Stringa" che, se sottoposta ad addizione, faccia qualcosa di
sensato.

\- Del tipo?

\- Poniamo che tu abbia una stringa A qualsiasi.

\- "Pippo" va bene?

\- Originale. E che tu voglia unirla ad un'altra stringa B.

\- "Pluto".

\- Anche questa bella originale. Comunque, tu scriverai l'istruzione: C
= A + B e nella stringa C ci sarà scritto: "PippoPluto".

\- Lo terrò a mente la prima volta che mi capiterà di dover scrivere
"PippoPluto".

\- Era un esempio.

\- Seguito a non capire perché si chiamino "linguaggi orientati agli
oggetti".

\- Perché non gestiscono dati grezzi, ma oggetti con un loro
comportamento ben definito.

\- Devo vederlo in pratica. Comunque, quali sarebbero i vantaggi di
questa traduzione?

\- Nel caso del C++, una maggior facilità di analisi.

\- Ma l'analisi dell'applicazione già c'è.

\- E una maggiore facilità di debug.

\- Prego?

\- Di correzione degli errori.

\- L'applicazione attuale è in funzione da un'eternità e non ha mai dato
nessun problema.

\- Aumenta anche le possibilità di riutilizzare il codice in altre
applicazioni.

\- Questo mi sembra utile quanto la stringa "PippoPluto".

\- Il processo produttivo ha una certificazione di qualità?

\- Io ho visto che era buono: direi che può bastare.

\- Be', allora non vedo che necessità ci sia di riscriverla.

\- Esattamente quello che ho detto a mio figlio, ma lui ha cominciato a
parlare di questo C++ e di quell'altro, quello col nome di un'isola,
come si chiama\...

\- Java? Non si riferisce a un'isola, ma a un tipo di miscela per il
caffé.

\- Quello che sia. Il discorso è: che bisogno c'è di riscrivere tutto?

\- Per quello che ne posso capire, direi nessuno\...

\- Bene, ti ringrazio.

Attacca (o quello che è), ma dopo un po' richiama.

\- Canaro, ho parlato con mio figlio e lui dice che sono un retrogrado,
che l'applicazione attuale è obsoleta, che gli utenti si lamentano e che
questo porting è necessario. Io non ci capisco più niente, cosa devo
fare?

Sto per rispondere "Lo sa Iddio", ma fortunatamente mi trattengo e
ricorro alla risposta standard in questi casi:

\- Potremmo fare uno studio di fattibilità e poi decidere\...

\- Mi sembra una buona idea. Quando puoi cominciare?

\- Non lo so, devo chiederlo al mio responsabile.

\- D'accordo: chiediglielo e poi fammi sapere.

Riattacca senza dirmi come potrò "farglielo sapere", ma questo è
l'ultimo dei miei problemi. Il primo, al momento, è in che modo
raccontare questa cosa al mio capo senza farmi prendere per pazzo.

\- Se speri di rimediare un periodo di convalescenza per esaurimento
nervoso, scordatelo. Hai detto (e soprattutto fatto) cose molto più
strane.

\- Lo so che è pazzesco, ma è vero: Dio mi ha telefonato e mi ha chiesto
di riscrivere l'Universo in C++.

\- Canaro, piantala e vai a finire l'analisi, che la dobbiamo portare al
cliente nel pomeriggio.

\- E se mi richiama, cosa gli devo dire?

\- Raccontagli di quanto hai sbagliato le stime dell'ultimo progetto,
così si rivolgerà a un altro.

Scornato, me ne torno al mio loculo dove mi preparo in anticipo la
seconda pipa della giornata. Mentre armeggio con il tabacco, il telefono
squilla per l'ennesima volta, ma non è chi mi aspetto che sia, bensì il
mio capo che mi richiama nel suo ufficio.

"Chiamata di re, tanto buona non è\...", penso, ma quando arrivo nella
ben nota stanza dall'inequivocabile odore di sigaro toscano, mi trovo di
fronte un uomo d'umore molto diverso da quello che mi ha allontanato
poco prima. La voce è pacata, i modi gentili e mostra la massima
comprensione e disponibilità nei miei confronti.

\- Passa le cose che stai seguendo a Igino e Paolo e dedicati
completamente allo studio di fattibilità per il porting dell'Universo.

Stupito per il repentino voltafaccia, chiedo la prima cosa che mi passa
per la testa.

\- Su quale commessa devo scaricare le ore?

\- Ancora non lo so, ma non te ne preoccupare. Oh, se ti serve un
portatile puoi prendere il mio.

\- Va bene, grazie. C'è nient'altro?

\- Tieni, - mi porge un foglietto con qualcosa scritto sopra - ha detto
che puoi richiamarlo a questo numero.

Rientro nel mio ufficio, chiudo la porta e compongo il numero: una voce
registrata mi avvisa che l'utente è al momento occupato, ma che è stato
inviato l'avviso di chiamata. Non passa un attimo che sento la Sua voce
dire:

\- Sì, pronto?

\- Scusami, io ti ho richiamato subito, ma se sei al telefono\...

\- Non ti preoccupare, stavamo chiudendo. Allora?

\- Sono a tua disposizione, ma prima di iniziare c'è una cosa che devo
dirti.

\- Vuoi sapere come ho fatto a convincere il tuo capo? È stato facile,
gli ho detto che a prendere le cose sul serio e ad arrabbiarsi ci si
accorcia la vita.

\- Questo credo che lo sapesse già\...

\- Probabile, ma io gli ho detto di quanto.

\- Tu sai quando morirà?

\- Teoricamente sì, ma chi se lo ricorda\... Ho sparato una data a caso
entro la fine dell'anno. Gli ho detto anche che questa era la sua ultima
possibilità per far sì che quel doloretto che ha sentito al torace
stamattina appena sveglio fosse solo un doloretto. È bastato.

\- Almeno così sembra. Comunque non è questo che volevo chiederti.

\- Oh! Tu probabilmente vuoi sapere perché ho scelto proprio te, avendo
a disposizione i migliori.

\- Io avrei detto "fra i migliori", ma comunque\....

\- Te lo dirò se farai un buon lavoro. Noi ci vediamo domani mattina
all'indirizzo che ti ha dato il tuo capo. Cerca di essere puntuale e non
passare dal centro perché ci sarà una fila per un tamponamento.

\- Me ne ricorderò.

Prima relazione sull'andamento del progetto "U++" (19 Aprile)

Le cose vanno meglio di quello che sperassi: malgrado i suoi impegni, il
Cliente trova sempre del tempo da dedicarmi e il mio lavoro procede
spedito. Inoltre, a dispetto di una malcelata ritrosia iniziale, credo
che finalmente si sia convinto dell'utilità di una revisione del codice
e adesso è Lui stesso, e non più il Figlio, a spingere per una rapida
conclusione.

Due sono state finora le scoperte di maggior rilievo: la prima è che
l'applicazione attuale è scritta in COBOL (il Cliente mi ha spiegato che
l'ipotesi iniziale di utilizzare il FORTRAN era stata abbandonata dopo
un primo tentativo e che in quel linguaggio è stato scritto solo il
cervello degli ingegneri); la seconda è che Mandelbrot aveva ragione:
l'Universo ha una struttura frattale (scelta, questa, che semplifica di
molto la gestione di situazioni complesse tipo l'interazione fra gli
agenti atmosferici, il rumore dei pedalò e gli incontri casuali con ex
amanti nei grandi magazzini).

Una mia proposta che ha incontrato l'approvazione del Cliente è di
procedere per gradi, stendendo un'analisi generale completa, ma
riscrivendo l'applicazione poco per volta, in modo da produrre il minimo
disturbo possibile agli utenti e semplificando il lavoro di affinamento
delle procedure.

Ho scritto una relazione preliminare (che allego) e l'ho consegnata al
Cliente: domani mi farà avere una sua opinione al riguardo.

Seconda relazione sul progetto "U++" (20 Aprile)

Nella mattinata odierna ho discusso la mia relazione preliminare con il
Cliente, che nel complesso mi è sembrato soddisfatto dell'impostazione
prescelta. Dopo qualche tentennamento, si è anche convinto che non è
possibile fare dei paragoni fra i tempi di sviluppo dell'applicazione
precedente e di quella nuova, sia per l'impossibilità di paragonare
analisi strutturata e analisi orientata agli oggetti, sia per la
difficoltà di comparare la misurazione attuale, in giorni/uomo, con
quella precedente, in giorni/Dio.

Al momento ho solo una preoccupazione, ovvero che qualcuno, da dietro le
quinte, piloti gli umori del Cliente con fini non chiari. Dico ciò,
perché tutti i dubbi e le perplessità da lui espresse finora sono
largamente al disopra delle sue conoscenze tecniche. Se inizialmente
pensavo che dietro a tutto questo ci fosse quel Figlio di cui ho già
fatto menzione nella memoria inviatavi prima della mia partenza (il che
mi avrebbe posto in una situazione oltremodo delicata in quanto, come
tutti ben sappiamo, la mia stessa presenza qui è dovuta proprio ad un
suo suggerimento e metterne in discussione la competenza sarebbe
controproducente), ora sono ragionevolmente certo che si tratti di
qualcun'altro, anche se non so proprio né chi possa essere né quali
possano essere i suoi scopi.

Terza relazione sul progetto "U++" (28 Aprile)

Mi scuso per il prolungato silenzio, ma le riunioni degli ultimi giorni
sono state letteralmente massacranti e non ho avuto il tempo di
mantenervi aggiornati sui più recenti sviluppi della situazione.

Di contro, va detto che finalmente comincio ad avere un'idea un po' più
chiara delle diverse esigenze funzionali e dei ruoli coinvolti nel
progetto, il che è sicuramente un bene, specie perché il terreno, qui,
comincia a scottarmi sotto i piedi. E non faccio per dire.

Come certo ricorderete, nella mia precedente comunicazione avevo
paventato l'esistenza di ingerenze occulte e, comunque, un dubbio che
avevo avuto sin dall'inizio era: dato che il Cliente ha più volte
affermato di non possedere grosse cognizioni tecniche in campo
informatico, chi ha scritto a suo tempo la prima applicazione? Non certo
il Figlio (il quale altro non è che uno smanettone con quattro
conoscenze d'accatto mutuate dalle riviste del settore), né tanto meno
il terzo membro del consiglio di amministrazione, che è quasi sempre in
viaggio. Quindi, chi?

Bene: adesso ho una risposta ad entrambi i quesiti e buone ragioni per
sospettare che le due figure (quelle del manovratore occulto e
dell'autore del codice) coincidano, ma non so se esserne contento o
spaventato.

Comunque è meglio raccontarvi tutto dall'inizio.

Il Cliente decide di realizzare un'applicazione per la gestione
dell'Universo (che sarebbe quella attualmente in produzione), così si
mette a tavolino, butta giù l'analisi funzionale, aggiunge alcune regole
di business (tipo: l'acqua va sempre in basso, di mamma ce n'è una sola,
i negri hanno la musica nel sangue e via dicendo), poi passa
all'implementazione.

Parte con qualcosa di piccolo e di facile, ma il risultato che ottiene
non lo soddisfa; inoltre, come molti creativi, non è particolarmente
attratto dalla realizzazione pratica di quello che ha elaborato
concettualmente, perciò decide di subappaltare il lavoro a terze parti e
le crea contestualmente. I nuovi arrivati studiano l'analisi,
definiscono il disegno della base dati, stabiliscono alcuni criteri di
implementazione (si passa dal FORTRAN al COBOL) e finalmente cominciano
a scrivere il codice.

L'analisi, va da sé, è estremamente precisa e tutto andrebbe nel
migliore dei modi se a un certo punto uno dei programmatori non
cominciasse a inserire delle backdoor nel programma.

Inizia quasi per scherzo (modifica il codice in modo da garantirsi
l'imbattibilità a briscola e il possesso di Viale dei Giardini e Parco
della Vittoria a Monopoli), ma poi ci prende gusto e comincia ad
aggiungere modifiche sempre più sostanziali, coinvolgendo
nell'operazione di inquinamento anche alcuni suoi colleghi. Alla fine, i
suoi privilegi sono di poco inferiori a quelli dell'Amministratore del
sistema.

Reso spavaldo dall'impunità di cui ha goduto fino ad allora, si mette
alla testa del suo gruppo di cialtroni e tenta di esautorare il Cliente
con un colpo di mano, ma senza successo: il suo piano è subito scoperto
e sia lui che i suoi seguaci sono trasferiti per punizione in una sede
secondaria, un open space senza aria condizionata, dove d'estate fa un
caldo assurdo. Li salva da un destino peggiore (la presenza,
nell'ufficio, di colleghe di sesso femminile) una curiosa circostanza:
c'è bisogno di loro per la manutenzione del programma.

Infatti, anche se la congiura è sventata, i danni al codice rimangono e
non c'è né il tempo di ricontrollare tutto né chi, a parte loro, lo
passa fare. Si decide perciò di mettere in produzione l'applicazione
così com'è e di procedere all'eliminazione delle anomalie a mano a mano
che verranno alla luce: una scelta tanto rischiosa quanto necessaria,
che porta ben presto ad una situazione paradossale in cui i congiurati
diventano il punto di riferimento del Cliente per la correzione degli
errori che loro stessi hanno generato e che seguitano a generare (un po'
per vendetta, un po' per accrescere il proprio potere contrattuale)
sfruttando i privilegi illegali che si sono garantiti.

É facile capire con quanta poca gioia questi personaggi abbiano salutato
il mio arrivo: anche se apparentemente masochista, la scelta del Cliente
di riscrivere tutta l'applicazione si rivela adesso l'unica possibilità
rimasta di eliminare il Male dal Creato.

Ecco spiegate le ingerenze esterne, ecco spiegato il motivo.

Fatemi gli auguri.

Quarta relazione sul progetto "U++" (1 Maggio)

Credete a me: i clienti buoni esistono solo per i commerciali; per i
tecnici esistono solo clienti che non hanno (ancora) creato problemi.

Ero così eccitato dall'idea di essere lo Strumento Divino che avrebbe
eliminato il Male dall'universo ed invece eccomi qui, sprofondato nella
più tetra depressione per colpa del Cliente e delle sue assurde
fissazioni.

Io pensavo, anzi, ero certo che nella nuova versione dell'applicazione
la parola d'ordine sarebbe stata "Bene": con quale sorpresa ho scoperto
invece che, anche in questa versione, l'esistenza sarà un'altalena fra
le colline della moderata contentezza e gli abissi oceanici della
malinconia.

Stamattina ne ho parlato con il Cliente, ho cercato di farlo ragionare.
Addirittura, visto che erano qui e che non avevano niente da fare, mi
sono perfino fatto dare una mano da Schopenhauer e Bergson, ma invano.
Mi ha risposto, seccato, di fare il mio lavoro e di non impicciarmi di
questioni che vanno oltre la mia comprensione (per poi blandirmi perché
lo aiutassi con i backup dopo che aveva cancellato per sbaglio due
galassie).

Nel pomeriggio sono tornato alla carica, convinto com'ero che le
cospicue quantità di vin santo ingurgitate nel post-prandiale avessero
favorevolmente influito sulla sua disponibilità, ma mi sbagliavo: mi ha
ripetuto quanto aveva già detto nella mattina e, in più, mi ha attaccato
un pistolotto di sapore vagamente taoista, il cui fine dichiarato era
quello di illuminarmi sulla soggettività dei concetti di bene e di male.

In un ultimo, disperato tentativo, ho ribattuto che la presenza del Male
nel Creato è uno degli argomenti preferiti di coloro che tentano di
dimostrare che Dio non esiste, ma è equivalso a darsi la zappa sui
piedi: mi ha confessato di essere stato proprio lui a infondere simili
pensieri nella mente dei suoi detrattori nella speranza, frustrata, che
la gente si trovasse qualcun' altro da bestemmiare.

Una volta di più, mi trovo a dover fronteggiare l'annosa dicotomia fra
ciò che il cliente desidera e quello di cui realmente ha bisogno e, una
volta di più, sarà ingrato compito dell'uomo informatico quello di
venire apparentemente meno ai propri doveri al fine di produrre qualcosa
di consono alle reali esigenze del committente.

Fax del Cliente (19 Maggio)

La presente per informarvi della nostra decisione di interrompere
l'opera di porting del nostro sistema gestionale in linguaggio C++; una
decisione sofferta, ma irrevocabile, cui siamo giunti avendo constatato
che i principali difetti dell'applicazione precedente non avevano
trovato una cura in questa nuova versione.

Stando così le cose, abbiamo deciso di focalizzare i nostri sforzi
piuttosto che su una rischiosa operazione di revisione, su un programma
organico di formazione degli utenti, nella speranza che una maggiore
consapevolezza delle problematiche di fondo del contesto di utilizzo
possa correggere quelle che, a questo punto, consideriamo delle
idiosincrasie congenite del sistema.

Quale ricompensa dell'impegno da Voi profuso in questo progetto abbiamo
pensato di risparmiare l'edificio in cui ha sede la Vostra società dal
terremoto del 24 luglio p.v., ma siamo aperti a qualsiasi soluzione di
Vostro gradimento, a patto che non contravvenga alle nostre politiche
aziendali.

Sfortunatamente, il Vostro personale distaccato presso di noi, è rimasto
vittima dell'annosa dicotomia fra ciò che gli utenti di un sistema
desiderano e ciò di cui realmente hanno bisogno e siamo certi che non
avrete nulla in contrario se lo utilizzeremo come cavia per il nostro
programma di rieducazione.

Attualmente, comunque, gode di ottima salute e sembra non avere
difficoltà ad integrarsi con il nuovo gruppo di lavoro cui è stato
assegnato, nella sede distaccata del nostro CED.

Finito il corso di riqualificazione, il maestro Canaro non fu più lo
stesso. Tornò alla sua società, ma vi rimase solo il tempo di dare le
dimissioni. Fondò il nostro Ordine e cominciò a predicare la mistica
della programmazione, ottenendo subito un grosso seguito.

I tempi erano maturi per il cambiamento: c\'era stata la crescita
prodigiosa di fine millennio e c'era stata la rovinosa caduta dell\'11
marzo 2000. La vecchia guardia era stanca di dover dipendere dalle bizze
della borsa e del marketing; i giovani volevano la Terra Promessa per
cui avevano abbandonato gli studi classici; gli utenti volevano che la
posta elettronica funzionasse.

La dottrina del maestro Canaro era semplice: riportare l\'informatica in
una torre d\'avorio, accettarne la componente imponderabile ed elevarla
da attività produttiva ad attività mistica.

Basta con l\'improvvisazione, basta con il *time to market*, basta con i
prodotti inaffidabili: chi voleva scrivere codice doveva entrare in un
ordine monastico e seguire un lungo percorso di iniziazione, prima di
poter cominciare a lavorare.

Furono in molti a vedere nel maestro Canaro *\"il vento che spazzerà via
il fango\"*: la vecchia guardia fu ben felice di veder riconosciuto il
suo status di casta eletta; i giovani, che cercavano un riparo, lo
trovarono all\'interno dei monasteri; gli utenti seppero che le loro
posta elettronica avrebbe funzionato e furono felici.

Ci fu anche una componente politica, a favorire il successo della
dottrina predicata dal maestro Canaro. La società dipendeva ormai
totalmente dai computer, e i computer dipendevano dagli informatici. Se
un giorno avessero deciso di coalizzarsi e di scioperare, avrebbero
messo il Paese, se non il mondo intero, in ginocchio.

Le psicopatologie tipiche degli informatici, la loro incapacità di
gestire, se non addirittura di *concepire* una vita sociale, rendevano
questa ipotesi molto poco probabile, ma era comunque un rischio troppo
grosso per essere ignorato. Al contrario, l'indottrinamento degli
informatici, la loro segregazione in una casta con forti componenti
mistico-religiose, li avrebbero tenuti lontani dalle lusinghe dei
sindacati e avrebbero reso l'ipotesi di uno sciopero improbabile quanto
l'ipotesi di uno sciopero dei sacerdoti.

Gli insegnamenti del maestro Canaro non uscirono mai dall\'ambito del
software, egli non nominò mai l\'*hardware*, in nessuno dei suoi
scritti.

Diceva che se un uomo configura un *firewall* è un informatico, se
attacca due cavi è un elettricista.

Una volta chiesi al maestro Canaro perché non avesse mai dato delle
indicazioni sull\'affidabilità fisica dei server.

"Se è per questo," mi rispose "non nemmeno prodotto tabelle per il
calcolo del cemento armato." Solo anni dopo capii cosa intendesse dire.

Malgrado il suo disinteresse per ciò che lui chiamava: "le cose reali",
la rivoluzione culturale provocata dal maestro Canaro ebbe delle
conseguenze anche per i produttori di computer.

La maggior parte di loro fu lenta a percepire i cambiamenti in atto e
pagò duramente la sua disattenzione, gli altri prosperarono.

Anche se il Maestro Canaro non prese mai una posizione definita nella
disputa che contrappose i sostenitori della dottrina del "grande
veicolo" (i *mainframe*) e quelli che erano invece favorevoli al
"piccolo veicolo" (i PC casalinghi), alcuni alti prelati si dichiararono
favorevoli al monoteismo dei *mainframe* e, alla fine, i sostenitori del
politeismo furono sconfitti.

Negli uffici e nelle case, i PC vennero sostituiti da terminali e gli
edifici ebbero tutti, oltre al garage e al locale caldaie, un\'area CED.
Il territorio fu suddiviso in diocesi, e ciascuna diocesi fu affidata a
un diacono che aveva il compito di sovrintendere al corretto
funzionamento dei diversi sistemi.

Sebbene noi, che gli eravamo vicini fin dall\'inizio della sua
predicazione, sapessimo che era il C++ il suo linguaggio di
programmazione preferito, il maestro Canaro lasciò che fosse Java a
diventare il linguaggio ufficiale della comunità, subendo senza
replicare gli attacchi di coloro che lo accusavano di essersi venduto
alla Sun([^1]). Le procedure esistenti furono tutte riscritte; gli
ordini monastici che insegnavano il C++ divennero sempre di meno e alla
fine non ce ne furono più.

Fu solo allora che il maestro Canaro mi parlò per la prima volta del
*C\'hi++*.

Il buon programmatore
=====================

Non chiederti cosa può fare per te il sistema operativo,

chiediti cosa puoi fare tu, per il sistema operativo

Le principali discipline dell\'informatica sono:

-   la gestione del personale;
-   la gestione dei progetti;
-   la gestione dei sistemi;
-   la programmazione.

Un buon maestro deve essere abile in tutte le discipline, ma può
eccellere solo in una di esse, perché per arrivare all\'eccellenza dovrà
dedicare a quella disciplina tutta la sua vita e nessuno ha più di una
vita.

È fondamentale che il maestro conosca e pratichi tutte le discipline,
perché solo conoscendo le problematiche connesse a ciascuna fase e a
ciascuna disciplina, potrà raggiungere l\'eccellenza in una di esse.

La disciplina più alta é la programmazione, perché non ha a che fare con
entità reali, ma solo con concetti astratti.

Nella *Bhagavad Gita*([^2]) si dice:

"Tu hai diritto solo all'azione, mai ai suoi frutti: che il tuo movente
non sia il frutto dell'azione, né vi sia in te attaccamento
all'inattività"

E' così che opera il buon programmatore.

Scrive del buon codice, anche se non beneficerà mai dei suoi effetti.

Scrive del buon codice perché non può farne a meno.

Scrivere codice non è un mestiere, è una deformazione mentale.

Il buon programmatore è un disadattato che ha la fortuna di essere
retribuito per dare sfogo ai lati peggiori della sua personalità.

Mentre scrive il codice, la mente del buon programmatore lavora su tre
livelli: il primo livello decide la sequenza delle istruzioni necessarie
a far funzionare il programma; il secondo livello ne controlla
costantemente la correttezza sintattica e semantica; il terzo livello
verifica se ci sia un sistema più efficiente per fare la stessa cosa.

I buoni programmatori sono paranoici ed è giusto che sia così.

Le istruzioni di un programma sono eseguite milioni di volte nel corso
della loro vita e anche una probabilità minima di errore è
inammissibile.

Il codice funziona come dovrebbe solo se non gli si lascia altra scelta.

Nei tempi andati ci fu chi sostenne una teoria bizzarra secondo la quale
i programmi, per essere veramente efficaci, sarebbero dovuti essere
rapidi, ridondanti e imprecisi.

L'idea di fondo era che, essendo impossibile, sopra un certo livello di
complessità, produrre del codice privo di errori, sarebbe stato meglio
produrre molti programmi mediamente imprecisi e valutare l'insieme dei
loro risultati.

L'unica cosa che posso dire a loro discolpa è che a quei tempi si
pensava alla produzione di codice come a un'attività di tipo industriale
e non come a una disciplina mistica.

Anche il buon sistemista è paranoico, ma un buon programmatore
difficilmente potrà essere un buon sistemista.

Il buon sistemista ricerca la ridondanza, perché la ridondanza aumenta
l'affidabilità del sistema.

Il buon programmatore rifugge la ridondanza, perché la ridondanza
diminuisce l'efficienza del codice.

Il programmatore è Mercurio, il sistemista è Vulcano.

Una volta chiesi al maestro Canaro: \"Maestro, cosa facevano i paranoici
prima che fosse inventata l\'informatica?\" il maestro Canaro ci pensò
un po\' su, poi rispose: \"Ormeggiavano le barche.\".

Un buon programmatore dovrebbe conoscere più di un linguaggio di
programmazione.

Che si conosca a fondo solo un particolare linguaggio è ammissibile, ma
una visione di insieme è sempre necessaria per operare delle scelte.

Quelli che al giorno d\'oggi si definiscono programmatori non sono
nient\'altro che dei forzati di un determinato linguaggio.

Allevati in batteria come i polli, conoscono soltanto quello, lo
ritengono il migliore e si interessano degli altri linguaggi solo allo
scopo di evidenziarne le pecche.

Questo è improduttivo e pericoloso perché, quando con il passare del
tempo, questi "programmatori" diventeranno analisti, gestiranno i
progetti e le persone a loro affidate con la stessa miopia, producendo
sistemi instabili, costosi e difficili da mantenere.

Ciò è immorale.

All\'estremo opposto stanno coloro i quali dedicano il loro tempo e le
loro energie allo studio dei linguaggi e delle metodologie di
progettazione del passato.

Sono capaci di citare costrutti in LISP, Ada o Eiffel con grande
precisione, ma non hanno mai scritto una riga di codice originale in
vita loro.

I più abili riescono a modificare i programmi di esempio che trovano nei
libri di testo o nei manuali, sostituendo gli algoritmi con altri brani
di codice classico, ma senza alcun apporto creativo.

Fra questi individui e i veri programmatori c\'è la stessa differenza
che passa fra un sessuologo e un pornodivo.

Non c'è differenza fra lo scrivere codice e il gestire un'azienda. È
come osservare una medesima città su carte di diversa scala. Se il
rapporto di scala è basso, si avrà una buona visione di insieme, ma
pochi dettagli; se il rapporto di scala è alto, si avranno molti
dettagli, ma una visione di insieme limitata. La città, però, sarà
sempre la stessa.

applicare le categorie caratteriali aristoteliche al SW. (Etica
Nicomachea)

I sistemi di numerazione
========================

Ci sono 10 tipi di persone: quelli che capiscono la

numerazione binaria e quelli che non la capiscono.

Per dissuadere i pochi ostinati che sono arrivati a leggere fin qui,
voglio parlarti dei sistemi di numerazione.

Secondo antiche leggende, la razza umana sarebbe il frutto di un
esperimento di ingegneria genetica operato da alieni esadattili arrivati
sulla Terra trecentomila anni prima di Cristo.

Che sia vero o no, immagina di avere intorno a un tavolo uno di questi
alieni, uno dei tuoi confratelli e un uomo che abbia solo un dito. Se
poggiassi una dozzina di uova sul tavolo e chiedessi a ciascuno di loro
di numerarle, cosa otterresti?

Il tuo amico, che conta in base alle dieci dita delle sue mani, direbbe
che le uova sono pari a una volta tutte le sue dita più due. Se
esprimessimo questa risposta con potenze del numero delle dita delle
mani del tuo confratello, otterremmo che:

1x10^1^ + 2x10^0^ = 12

L\'alieno, abituato a contare in base alle sue dodici dita, direbbe che
le uova sono:

1x12^1^ + 0x12^0\ ^= 10

Il disgraziato con un dito, che può considerare solo le due possibilità:
*un dito/nessun dito, *sarebbe costretto a fare un calcolo più lungo:

1x2^3^ + 1x2^2^ + 0x2^1^ + 0x2^0^ = 1100

Questi tre risultati, per quanto differenti, non sono sbagliati, perché
ciascuno dei tre conta le dodici uova in base al numero delle proprie
dita e risponde di conseguenza. Le uova rimangono le stesse: cambia solo
il sistema di numerazione.

Del resto, è naturale che sia così: i numeri sono solo concetti
astratti; simboli che si utilizzano per identificare delle quantità.
Potresti sostituire i numeri da 0 a 9 con le prime dieci lettere
dell\'alfabeto e non cambierebbe nulla:

  --- --- --- --- --- --- --- --- --- ---
  0   1   2   3   4   5   6   7   8   9
  a   b   c   d   e   f   g   h   i   l
  --- --- --- --- --- --- --- --- --- ---

a + b = b

b + c = d

d \* e = bc

Il metodo di calcolo resterebbe lo stesso: quando la quantità da
valutare è maggiore del numero delle cifre disponibili, si riporta la
differenza a sinistra, nella colonna di ordine superiore. Il valore *bc*
dell\'ultima operazione, significa infatti:

b\*(numero di cifre)^1^ + c\*(numero di cifre)^0^

ovvero, visto che il numero di cifre a nostra disposizione è 10:

b\*10 + c\*1

Se sostituiamo le lettere con i numeri, otteniamo:

1\*10 + 2\*1 = 3 \* 4

Ma non tutti i sistemi di numerazione funzionano allo stesso modo.

Se tu chiedessi a un antico romano di calcolare il numero delle uova, ti
risponderebbe:

XII

e anche questo sarebbe un risultato corretto, anche se diverso dai
precedenti.

Il sistema di numerazione romano è un po\' più complicato dei sistemi in
base 10, 12 e 2 che abbiamo visto finora.

Nella numerazione romana, il valore di una cifra (I, V, X, L, C, D, M)
non dipende dalla sua posizione assoluta, ma dalla sua posizione in
rapporto alle altre cifre.

Il Maestro Canaro nacque il 29 febbraio 1964; in cifre romane, questa
data è:

XXIXIIMCMLXIV

ovvero:

10+10+(10-1) 1+11000+(1000-100)+50+10+(5-1)

I numeri romani possono andar bene per un popolo di conquistatori: sono
facili da scolpire nel marmo, a memoria di una battaglia vittoriosa e
non considerano lo zero, la nullità, ma per il commercio e per i calcoli
in generale sono piuttosto scomodi.

Quando gli arabi diffusero nel bacino del Mediterraneo il sistema di
numerazione che avevano a loro volta imparato dagli indiani, la sua
diffusione fu tanto rapida quanto inevitabile.

Ma i computer non sono né egocentrici come un imperatore romano, né
astuti come un mercante fenicio; al contrario, sono veloci, ma tonti:
bisogna spiegar loro le cose in maniera semplice, perché le possano
portare a termine.

La numerazione romana, quindi, non fa per loro, perché richiede troppi
simboli e troppe regole per essere messa in pratica.

La numerazione decimale è già un po\' meglio, ma richiede comunque la
definizione di dieci simboli diversi, uno per ciascuna cifra da 0 a 9.

Paradossalmente, il sistema di calcolo che un calcolatore può capire più
facilmente è quello per noi più complicato, ovvero il sistema binario.

Questo sistema richiede solo la definizione di due simboli:1e 0; dei
concetti che possono capire facilmente sia un transistor che una scheda
perforata.

inserire esempî di calcolo binario?

Qualcuno potrebbe dirti che ci sono sistemi di calcolo migliori del
binario.

Qualcuno, probabilmente uno di quei disgraziati individui che
amministrano le basi di dati, potrebbe dirti che il sistema ternario
bilanciato funziona molto meglio e semplifica i calcoli.

Ciò corrisponde al vero.

La ragione per cui il Maestro Canaro non approvava i sistemi ternarî era
filosofica, non tecnica. I due valori del sistema binario possono essere
identificati con i valori logici sì/no, vero/falso; ovvero con le due
condizioni di esistenza e non esistenza, per esempio, di un buco in una
scheda perforata o di una corrente in un circuito.

Al contrario, i sistemi con basi superiori a due, richiedono la
definizione di un terzo stato che non può essere né sì, né no; né vero,
né falso; né esistente, né in-esistente.

Questo terzo stato intermedio può essere definito solo per mezzo di una
valutazione che non può essere più logica, ma quantitativa.

Mettiamo che su una scheda perforata il valore 0 sia associato
all\'assenza di fori e il valore 1 sia associato alla presenza di un
foro; un terzo valore, differente da 0 e da 1, potrebbe essere
identificato o da un foro di dimensioni differenti o da una concavità.

Quale che sia la soluzione scelta, saremmo costretti a definire un
valore in base a una grandezza fisica, ovvero, a basare il calcolo
digitale su una misurazione analogica.

Il Maestro Canaro pensava che ciò fosse empio.

C\'è qualcosa, in tutto questo, sulla quale vorrei che tu soffermassi la
tua attenzione.

I numeri *descrivono* una quantità, non *sono* una quantità.

La quantità di fiammiferi che vedi qui sul mio tavolo, rimane la stessa
sia che tu la chiami 4, 100 o IV, così come rimarrebbe la stessa se tu
la chiamassi *five* o *cinco*.

La quantità esisteva da prima che esistessero i numeri e gli
sopravviverà.

I numeri, li abbiamo inventati noi.

La quantità, no.

I linguaggi di programmazione
=============================

Chi vuole capire il computer

deve andare nella terra del computer

I linguaggi di programmazione servono a spiegare ai computer com'è fatto
il mondo reale.

Ci sono molti linguaggi di programmazione.

Ciascun linguaggio sa spiegare bene certe cose e meno bene certe altre.

Noi percepiamo il mondo reale come un insieme di eventi che coinvolgono
una o più entità.

Ciascuna entità è identificabile per le sue caratteristiche fisiche e ha
un suo modo particolare di reagire agli stimoli esterni.

Per descrivere le entità, i linguaggi di programmazione hanno i tipi di
dato; per descrivere gli eventi, hanno istruzioni e operatori.

Un linguaggio di programmazione è tanto più efficace quanto più i suoi
tipi di dato e i suoi costrutti sintattici riescono a descrivere le
entità che il programma dovrà gestire.

Tutti i linguaggi hanno una sintassi; tutti i linguaggi hanno dei tipi
di dato.

Solo pochissimi linguaggi hanno anche dei principî.

\[Qui va inserita una nota sull\'importanza dei principii e sulle
conseguenze della loro eliminazione (il caos). I riferimenti filosofici
sono a Timone; quelli storici alla Grecia quando nacque lo scetticismo.
Il riferimento a Timone ci dovrebbe stare piuttosto bene perché si lega
al discorso sui tipi di dato e operatori: Timone negò i principii che è
come negare i tipi di dato e i costrutti.\]

Bjarne Stroutsup, o forse Brian Kernigan, disse: "*L'unico modo di
apprendere un linguaggio di programmazione è quello di utilizzarlo per
scrivere programmi"*. Il maestro Canaro sosteneva che anche scrivere un
manuale su un linguaggio di programmazione è un buon sistema per
impararlo.

Un programmatore che conosce a fondo un certo linguaggio di
programmazione può utilizzarlo efficacemente per scrivere qualsiasi
programma, ma a quale prezzo?

Se il linguaggio di programmazione è inadatto a descrivere gli eventi
che interesseranno il programma, il programmatore dovrà preoccuparsi di
piegare o gli eventi o il linguaggio o entrambi per ottenere il
risultato atteso.

Scegliendo invece un linguaggio i cui tipi di dato e i cui costrutti
siano più affini alla realtà da descrivere, si risparmiano tempo e
fatica e si scrive un codice più affidabile.

\[v. nota 55 a SDFO\]

Un giorno un discepolo chiese al maestro Canaro: "Maestro, con quale
tipo di arco si tira meglio?".

Il maestro rispose: "Con quello che utilizzi tutti i giorni".

Il discepolo chiese allora: "Maestro, questo vuol dire che si può
utilizzare uno strumento inadatto, purché si raggiunga lo scopo?".

Il maestro sorrise benevolmente e disse: "Ti prego, vai a meditare
sull\'insensatezza delle tue domande mentre pulisci le latrine comuni."

Per molto tempo non riuscii a capire il comportamento del maestro
Canaro. Per un po\', credetti che l\'errore fosse quel "meglio" nella
prima domanda e che il maestro avesse dato una risposta volutamente
imprecisa allo scopo di portare alle estreme conclusioni un ragionamento
male impostato, ma mi sbagliavo.

La verità era che il maestro Canaro, come ebbe modo di confessarmi in
seguito lui stesso, stava cercando di scaricare su qualcuno il suo turno
di pulizia latrine e il giovane e impetuoso discepolo gliene aveva dato
occasione.

Il C++
======

È stata una giornata estenuante: stamattina

ho tolto una virgola dal mio codice

e stasera ce l'ho rimessa

*Il C++ è un linguaggio orientato agli oggetti, questo vuol dire che le
sue regole interne discendono da dei principî di ordine superiore, il
cosiddetto paradigma a oggetti.*

Il C++ rappresenta le entità reali per mezzo degli oggetti.

Le caratteristiche delle entità sono descritte dagli attributi degli
oggetti.

Il modo in cui gli oggetti reagiscono agli stimoli esterni è descritto
dai metodi.

Perché un linguaggio di programmazione possa dirsi orientato agli
oggetti deve possedere tre caratteristiche: le classi, l'ereditarietà e
il polimorfismo.

*Le classi sono i prototipi degli oggetti e ne definiscono le
caratteristiche distintive. Le caratteristiche fisiche degli oggetti
sono quantificate dagli attributi della classe; le caratteristiche
comportamentali sono descritte dai metodi.*

Grazie alle classi, il programmatore può creare dei nuovi tipi di dato e
utilizzarli all\'interno del suo programma nello stesso modo in cui
utilizzerebbe i tipi di dato primitivi del linguaggio.

*L'ereditarietà permette di definire dei nuovi tipi di dato come
estensione dei tipi di dato esistenti. *

L'ereditarietà può essere o singola o multipla.

*Quando una nuova classe deriva da un'unica classe base, l'ereditarietà
viene detta singola*; se invece una classe deriva da due o più classi*
base, l'ereditarietà viene detta multipla. *

Alcuni linguaggi di programmazione permettono solo l'ereditarietà
singola; il C++ permette entrambe le tipologie.

Per polimorfismo si intende la capacità di una funzione o di un
operatore di svolgere il proprio compito indipendentemente dal tipo di
dato che deve gestire.

Quando il programmatore definisce un nuovo tipo di dato per mezzo di una
o più classi, può allo stesso tempo istruire le funzioni e gli operatori
del linguaggio ad utilizzarlo correttamente.

Suppongo che a questo punto tu sia un po\' confuso, ma non dipende dalla
complessità dalle mie enunciazioni.

Il problema è che ti stai concentrando sull\'effetto e non sulla sua
causa.

Tipi di dato
============

???

Il C++ possiede molti tipi di dato.

Ogni tipo di dato, però, non è altro che il nome di una quantità di
memoria.

Ricordatelo, perché questo è la chiave di tutto.

La dimensione di un dato determina il numero massimo di valori che quel
dato può assumere.

Un *char* è composto da otto bit e può assumere per ciò 256^\ ^valori.

Un *int* è composto da sedici bit e può assumere per ciò
65536^\ ^valori.

Un *long int* è composto da trentadue bit e può assumere per ciò
4294976296^\ ^valori.

Espressioni e operatori
=======================

Nel futuro, ognuno sarà famoso per 15 megabytes

commenti
--------

I commenti sono la cosa più importante, quando si programma.

Un commento è un breve brano di testo che descrive in linguaggio comune
il funzionamento o lo scopo del codice seguente.

Pur essendo all'interno del codice, il commento viene ignorato in fase
di compilazione.

È importante commentare bene il proprio codice.

Il buon codice produce programmi che durano nel tempo e, col tempo, si
tende a dimenticare.

Anche se si ha la fortuna di possedere una buona memoria, bisogna
considerare la possibilità che il proprio codice sia utilizzato da un
collega. Non solo non è educato costringerlo ad analizzare ogni singola
riga di codice per capirne il funzionamento, ma è anche improduttivo.

Così come la penuria, anche l'eccesso di commenti è un errore da
evitare.

Il programmatore inesperto non commenta il proprio codice perché pensa
che sia una perdita di tempo. È davvero un atteggiamento poco
responsabile.

Il neofita zelante riempie il proprio codice di commenti, o perché
ritiene che chi lo andrà a leggere sarà meno esperto di lui o perché
vuole in questo modo esaltare le sue poche conoscenze.

Il programmatore esperto commenta solo ciò che non è di per sé evidente
e indica i possibili punti deboli del suo programma in modo che chi si
trova a riutilizzarlo o a correggerlo vi presti la dovuta attenzione.

Il programmatore Perfetto non commenta il suo codice, perché non è
necessario.

Spesso gli opposti coincidono.

È ammissibile che i commenti abbiano una sfumatura umoristica, può
essere utile per scaricare un po' della tensione in chi legge, così come
scambiarsi una battuta mentre si lavora, ma anche in questo non si deve
esagerare.

È buona norma anteporre a ogni funzione un breve commento che ne
illustri il funzionamento, ma se si ha cura di scegliere dei nomi
auto-esplicativi per le funzioni questo può non essere necessario.
Sarebbe un'inutile ridondanza aggiungere un commento se il nome della
funzione basta da solo a chiarirne la ragione e l'uso.

Il C++ prevede due modi distinti per commentare il codice: due caratteri
// affiancati o la sequenza /\* \*/, che il Linguaggio ha mutuato dal
suo predecessore, il C.

Nel primo caso, il compilatore ignora i caratteri dal simbolo fino alla
fine della riga; nel secondo caso, ignora tutto ciò che è compreso fra
le due sequenze di caratteri.

Entrambe le soluzioni hanno dei pro e dei contro che con l\'esperienza
risultano evidenti. Scegliere l\'uno o l\'altro è spesso una questione
di convenienza, altre volte una questione di stile, ma se si capisce la
vera essenza del Linguaggio, è solo una questione di ritmo.

Una volta, il maestro Canaro mostrò ai suoi allievi un brano di codice e
gli chiese di spiegare che cosa facesse:

> /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

> \#include \<iostream.h\>

> \#define ERR\_NOFILE 1

> int errore( int errore );

> void leggi\_file( char \* nomefile );

> void crea\_matrice(void);

> int inizializza(void);

> void imposta\_probabilita(void);

> void attrattore(void);

> int chiudi(void);

> int main(int argc, char \* argv\[\])

> {

> int esito = 0 ;

> if(argc \< 2) {

> esito = errore(ERR\_NOFILE);

> } else {

> leggi\_file(argv\[1\]);

> crea\_matrice();

> if(inizializza()) {

> const char \* valore = imposta\_probabilita();

> attrattore(valore);

> esito = chiudi();

> }

> }

> return esito ;

> }

> \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

Gli allievi studiarono gli algoritmi e diedero le loro risposte, ma
sbagliarono tutti, perché il codice era compreso fra un /\* e un \*/ e,
di fatto, non faceva nulla.

I commenti sono un po\' come la letteratura: se si scrive troppo poco è
male; se si scrive troppo, dilungandosi in descrizioni inutili, è
altrettanto sbagliato.

Il paragone vale anche all\'inverso: i libri, le opere letterarie, sono
i commenti al codice della vita. Si scrive ciò che si desidera
ricordare.

operatori
---------

### operatore di negazione

\[la negazione e il paradosso come metodo per comprendere ciò che non è
di per sé evidente\]

### operatori logici

È impossibile definire in maniera assoluta i concetti di *vero* e di
*falso*.

Possiamo definire "falso" il contrario di "vero", ma non potendo
definire il concetto di "vero", non possiamo sapere cosa sia il suo
contrario.

La ragione per cui non possiamo definire il concetto di "vero" è che
farlo implica una ricorsione: quale che sia la definizione prescelta,
prima di poterla prendere per buona dovremo poterla considerare vera, ma
ciò è impossibile perché non sappiamo (ancora) cosa sia, effettivamente,
"vero".

Tutto ciò non vuol dire che non esistano il vero e il falso, ma solo che
i nostri strumenti dialettici sono inadeguati a descriverli.

I computer sono più fortunati: nel loro mondo, il vero e il falso sono

Istruzioni condizionali
-----------------------

Le istruzioni condizionali sono la parte più importante del codice.

Ogni programma deve saper reagire correttamente al variare delle
condizioni di utilizzo; per far ciò, si utilizzano le istruzioni
condizionali.

Le istruzioni condizionali permettono di definire il comportamento del
sistema a seconda che una determinata condizione si riveli vera o falsa.

Ci sono due istruzioni condizionali: le sequenze *if-else* e
l\'istruzione *switch*.

### Istruzioni *if-else*

La forma generale di questa istruzione è la seguente:

if ( *condizione* )

{

// istruzioni da eseguire se la condizione è vera

}

else

{

// istruzioni da eseguire se la condizione è falsa

}

Se l'espressione condizionale all\'inizio del codice è vera (nell\'unica
accezione di *vero* che un programma può comprendere, ovvero, se ha un
valore diverso da zero), il programma eseguirà il primo blocco di
istruzioni; se no, eseguirà il secondo blocco di istruzioni.

Se la condizione \"falso\" non richiede alcuna azione specifica, il
secondo blocco di istruzioni può essere omesso:

if ( *condizione* )

{

// istruzioni da eseguire se la condizione è vera

}

Similmente, le parentesi graffe possono essere omesse se il blocco
istruzioni che racchiudono è costituito da una singola istruzione:

if ( *condizione* )

valore = 1;

else

> valore = 0;

D\'altro canto, se le condizioni da valutare sono più di due, si possono
concatenare più istruzioni condizionali utilizzando l\'istruzione *else
if*, che permette di definire una condizione alternativa alla prima e di
associarle un blocco di codice.

> if ( *condizione 1* )

{

// *istruzioni per caso 1*

}

else if ( *condizione 2* )

{

// *istruzioni per caso 2*

}

else if ( *condizione 3* )

{

// *istruzioni per caso 3*

}

Anche in questo caso, si può chiudere la sequenza con un\'istruzione
*else*, definendo un blocco di istruzioni da eseguire se non si verifica
nessuna delle condizioni previste.

> if ( *condizione 1* )

{

// *istruzioni per caso 1*

}

else if ( *condizione 2* )

{

// *istruzioni per caso 2*

}

else if ( *condizione 3* )

{

// *istruzioni per caso 3*

}

else

{

// *istruzioni per tutti gli altri casi*

}

Il programma esamina queste istruzioni in sequenza e, se ne trova una
vera, esegue il codice associato.

Le istruzioni *if-else* influenzano la leggibilità del codice; è una
cosa di cui il buon programmatore deve sempre tenere conto.

Il C++ è un linguaggio indipendente dalla formattazione, quindi, una
stessa istruzione può essere scritta in molte maniere diverse:

if ( *condizione* )

{

\...

}

else

{

\...

}

o, pure:

if ( *condizione* ) {

\...

} else {

\...

}

o perfino:

if ( *condizione* ) { \...} else { \... }

Se le istruzioni sono poche e semplici, una forma vale l\'altra (fatte
salve le questioni di stile, ovviamente), ma se il flusso del programma
prevede, come di solito avviene, delle condizioni annidate, è necessario
fare in modo che la forma dell\'istruzione semplifichi tanto la
scrittura che la lettura che un\'eventuale correzione del codice.

Immagina un brano di codice che debba fare una verifica all\'inizio
dell\'elaborazione e, a seconda dell\'esito, eseguire una sequenza di
istruzioni o inviare un messaggio di errore:

> if ( *condizione* )

{

// codice da eseguire in caso

// la condizione sia vera

}

else

{

// messaggio di errore

}

Se le istruzioni da eseguire in caso di buon successo della verifica
sono poche e semplici, questa sequenza non darà problemi, ma se, al
contrario, le istruzioni fossero tante e complesse, leggendo il codice
potresti arrivare all\'istruzione *else* e non ricordarti più a quale
condizione fosse associata.

Per questo motivo, è preferibile la forma:

> if ( *errore* )

{

// messaggio di errore

}

else

{

// codice da eseguire in caso

// tutto vada bene

}

Dato che la gestione dell\'errore non richiederà mai più di qualche riga
di codice, a colpo d\'occhio potrai capire tutto il flusso del
programma, indipendentemente dalla lunghezza del secondo blocco di
istruzioni.

Questo, ovviamente, non vuole essere né un invito né una giustificazione
per la scrittura di istruzioni complesse.

A meno che non sia necessario evitare le chiamate a funzione per
garantire un\'alta velocità di esecuzione, è sempre meglio scomporre il
flusso del programma in una serie di funzioni distinte.

Questo renderà il programma un po\' più lento (o, meglio: un po\' meno
veloce), ma renderà il codice molto più facile da leggere e da
modificare o correggere.

Immagina adesso un brano di codice che richieda molte condizioni *if
*concatenate:

> esito = 0;

> if ( *condizione 1* )

> {

esito = 1

> }

> else if ( *condizione 2* )

{

esito = 2

}

else if ( *condizione 3* )

{

esito = 3

}

else

{

esito = 9

}

return esito

Questa forma, per quanto corretta e canonicamente ineccepibile, potrebbe
rivelarsi difficile da gestire se le condizioni da considerare fossero
molto complesse o numerose.

Il buon programmatore, allora, può decidere di contravvenire alla
(giusta) norma che prescrive di non inserire delle istruzioni *return*
all\'interno del codice, e scrivere la sequenza in questo modo:

> esito = 0;

> if ( *condizione 1* )

> {

return 1

> }

> if ( *condizione 2* )

{

return 2

}

if ( *condizione 3* )

{

return 3

}

\...

return 9

Non ti sto dicendo che sia giusto scrivere così e vedi da solo che il
codice è rozzo e inelegante, ma ci potrebbero essere dei casi in cui sia
questa, la forma più efficiente.

Per esempio, per un sistema che generi del codice in maniera automatica,
è molto più semplice gestire delle istruzioni *if* isolate che delle
condizioni *if-else* concatenate.

Pensa a una *stored-procedure* che debba controllare l\'integrità
referenziale dei parametri ricevuti:

> CREATE FUNCTION utente\_insert (

> \_id\_classe INTEGER

> , \_id\_gruppo INTEGER

> , \_username VARCHAR(255)

> , \_cognome VARCHAR(80)

> , \_nome VARCHAR(80)

> )

> RETURNS INTEGER DETERMINISTIC

> BEGIN

> DECLARE \_id INTEGER DEFAULT -1;

> DECLARE \_count INTEGER DEFAULT 0;

> SELECT count(\*) INTO \_count FROM classe WHERE (id = \_id\_classe);

> IF \_count = 0 THEN

> RETURN -2;

> END IF;

> SELECT count(\*) INTO \_count FROM gruppo WHERE (id = \_id\_gruppo);

> IF \_count = 0 THEN

> RETURN -3;

> END IF;

> IF (\_username IS NULL) OR (\_username = \'\') THEN

> RETURN -4;

> END IF;

> IF (\_cognome IS NULL) OR (\_cognome = \'\') THEN

> RETURN -5;

> END IF;

> IF (\_nome IS NULL) OR (\_nome = \'\') THEN

> RETURN -6;

> END IF;

> \...

Se scrivi il codice in questa maniera, puoi inserire o rimuovere un
parametro (e i relativi controlli) senza alterare il resto del codice,
cosa che non avverrebbe se tu concatenassi le istruzioni *if*.

Attento, però: mettere in sequenza delle semplici istruzioni *if* è cosa
ben diversa dal creare una catena di istruzioni *else-if* .

\[specificare la differenza e la necessità del return per bloccare i
controlli; chiudere con l\'aneddoto del Maestro Canaro e il sacerdote
buddista\]

cicli
-----

### ciclo for

### ciclo while

### ciclo do-while

### 

Le Funzioni
===========

Dopo di me, il reboot

Funzioni ricorsive
------------------

Nella Lettera agli artisti, Giovanni Paolo II utilizza i termini
\'buono\' e \'bello\', ma li definisce in maniera ricorsiva, l\'uno in
funzione dell\'altro. Stesso discorso per il concetto di \'Arte\'

Bizzarro, perché la stessa cosa avviene, in condizioni diametralmente
opposte, in "Un'etica senza Dio" di Lecaldano, dove ci si appella a
concetti di 'buono' e 'giusto' senza definirli.

Differenza con i manuali SW (in cui i termini utilizzati sono tutti
definiti) e le le classi C++

Nota 7 (S.Gregorio++)

Le classi
=========

Non accetterei mai di far parte di una rete

che abbia un server come me fra i suoi nodi

Mettere radici non è male, ma è pericoloso, c'è sempre qualcuno pronto a
coprirtele di letame.

Funzioni di interfaccia
-----------------------

Lévy-Bruhl, citato da Coomaraswamy (*Grande Brivido*, pag. 227) «Per
questa ragione il selvaggio non ama dire il suo nome o farsi
fotografare, perché per mezzo del suo nome o del ritratto egli è
accessibile, e può quindi ricevere danno da chi con questi mezzi è in
grado di raggiungerlo.»

Classi astratte
---------------

\[cfr. *Breve storia dell'infinito*, pagg. 30-40\]

Si può dire che esista qualcosa che non ha dimensioni?

Il punto non ha dimensioni.

La retta è costituita da punti.

La circonferenza è costituita da punti.

Apparentemente, tutta la geometria euclidea è basata sul nulla.

Se una circonferenza fosse costituita da punti privi di dimensione, noi
non la potremmo vedere.

Per vederla, e quindi per poterla in qualche modo utilizzare, dobbiamo
dare uno spessore ai punti che la compongono, siano essi dei minuscoli
residui di grafite o dei pixel.

Allo stesso modo, se disegnassimo con la massima precisione due aree
contigue e, con la stessa precisione, le colorassimo in maniera
differente, la linea di demarcazione fra al fine di un'area e l'inizio
dell'altra non sarebbe rettilinea, ma seguirebbe l'andamento del foglio,
o dei pixel.

Da lontano potrà anche sembrare rettilinea, ma a mano a mano che
avviciniamo lo sguardo, le irregolarità diventeranno sempre più
evidenti.

Questo non vuol dire che le forme geometriche siano delle menzogne.

Esse esistono, ma hanno un valore puramente simbolico, e non possono
essere utilizzate in contesti reali.

È la stessa differenza che passa fra l'Adamo celeste e l'Adamo
terrestre. L'Adamo celeste è l'emanazione del Pensiero di Dio ed è per
ciò immortale; l' Adamo terrestre è l'incarnazione del modello celeste
nella materia ed è quindi soggetto al ciclo di nascita e morte.

E tu certamente saprai cosa vuol dire *ādām*, in ebraico.

Le *classi astratte* del C++ sono delle classi generiche che possono
essere utilizzate come capostipite per una discendenza di classi
specializzate, ma che non possono essere utiliz­zate direttamente.

Le regole che si applicano alle classi astratte sono:

-   viene considerata *astratta* qualunque classe che abbia almeno una
    funzi­one virtuale pura;
-   non si possono utilizzare classi astratte come argomenti o come tipi
    di ritorno di funzioni ;
-   le classi astratte non possono essere il tipo di un oggetto o di una
    con­versione esplicita.

Quindi, se definissimo una classe astratta Circonferenza, tutte le
istruzioni seguenti darebbero luogo ad errori di compilazione:

> void funz(Circonferenza);

> Circonferenza funz();

> Circonferenza piatto;

> Circonferenza\* ptr = (Circonferenza\*)disco;

Ciò che i teorici definiscono "paradossi" altro non sono che degli
errori di compilazione.

Lo prova il fatto che i paradossi esistono solo nella teoria, nella
pratica esistono solo le cose possibili e le cose impossibili \[come un
quadrato la cui area non sia proporzionale al diametro del cerchio
inscritto\], perché i paradossi non possono essere compilati.

"Breve storia dell'Infinito" cap. II, pag. 32-33

Quadratura del cerchio secondo Antifonte e confutazione di Aristotele.

Entrambe le affermazioni sono vere, ma in contesti differenti.

Nella realtà, esiste sempre un limite che blocca la ricorsione
all'infinitesimo.

All'interno di uno schermo, ha ragione Antifonte, perché non potremo
disegnare poligoni i cui lati siano più piccoli di un pixel.

Su uno schermo, un cerchio è di fatto un poligono con tanti lati quanti
sono i pixel che ne costituiscono la circonferenza.

Quindi, la circonferenza euclidea esiste, ma è una classe astratta.

Per poterla trasformare in una ruota di carro o in un piatto dobbiamo
creare una nuova classe

> class Ruota : public Circonferenza

> {

> \...

> };

Nessuna di queste istruzioni darà luogo a errori di compilazione:

> void funz(Ruota);

> Ruota funz();

> Ruota r;

> punt = (Circonferenza\*) ptr ;

> Ruota\* anteriore = new Ruota();

Possiamo dichiarare un puntatore o un riferimento ad una classe
astratta, così come è possibile assegnare un'istanza della classe
derivata ad un puntatore ad oggetti della classe base:

> Circonferenza\* ptr = anteriore;

> Circonferenza& rif(anteriore);

E del resto, sarebbe stato assurdo il contrario: a cosa sarebbe servito
definire una classe a cui non è possibile accedere in nessun modo?

Funzioni virtuali pure
----------------------

A questo punto è giusto che tu sappia cosa sia, una *funzione virtuale
pura*.

Come ti ho detto, la sintassi delle funzioni virtuali pure dev'essere:

> virtual \<*tipo*\> nomefunzione(\[*argomenti*\]) = 0 ;

\...

> \#include\<iostream\>

> \#include\<string\>

> using namespace std;

> class Circonferenza {

> public:

> Circonferenza(float r): \_raggio(r) {}

> float diametro() { return (\_raggio + \_raggio); }

> virtual string descrizione() = 0;

> private:

> float \_raggio;

> };

> class Piatto : public Circonferenza {

> public:

> Piatto(float r): Circonferenza(r) {}

> string descrizione() { return \"supporto in ceramica per i cibi\";}

> };

> int main() {

> Piatto p(12);

> Circonferenza& c = p;

> cout \<\< p.descrizione() \<\< \", diam. \" \<\< p.diametro() \<\< \"
> cm \" \<\< endl;

> cout \<\< c.descrizione() \<\< \", diam. \" \<\< c.diametro() \<\< \"
> cm \" \<\< endl;

> return 0;

> }

Il polimorfismo
===============

Noi viviamo prevalentemente sulla terraferma e riteniamo perciò che la
normalità sia questa. Se però si trascorre un lungo periodo di tempo su
una nave o in un'isola, si ha modo di capire come la normalità sia
l'acqua e la terra sia solo un'eccezione.

Similmente, noi diamo grande importanza al ciclo di nascita,
riproduzione e morte che chiamiamo "vita" e in essa vediamo il fine
ultimo dell'universo, dimenticandoci che la vita è solo un caso
particolare di esistenza e che un universo di sassi sarebbe comunque
prodigioso.

Ciascuna forma di vita consociata, per poter sopravvivere, richiede la
legittimazione di alcune follie biologiche.

Il rispetto di queste follie, essendo in-naturale, richiede
l'istituzione di un livello superiore di costrizione, ovvero un corpo di
regole formali ancora più distante del precedente dal comportamento
biologico degli esseri viventi.

Con il passare del tempo, molte di queste convenzioni nate in seguito a
esigenze contingenti, finiscono inevitabilmente per contrastare con il
senso comune di giustizia e devono essere o abolite o modificate, solo
che ciascuna modifica o adattamento invece di renderle più "giuste", le
allontana ulteriormente dal loro scopo iniziale e le rende soggette a
interpretazioni errate o addirittura opposte a quelle che era il loro
fine primario.

Sant'Agostino ha detto la stessa cosa, ma molto meglio di quanto stia
facendo io adesso.

Si vede che era sobrio.

La specializzazione come un male.

Un tempo, l'uomo virtuoso sapeva fare molte cose, più o meno bene.

Ora se ne sa fare solo una, benissimo.

Si cerca l'eccesso, il continuo superamento del limite.

Lo sport (citare Arlìa?), da attività formativa è diventato una forma di
intrattenimento e, come tale, deve essere sempre più spettacolare.

Lo sportivo è visto come un costoso strumento usa e getta.

È però importante che il polimorfismo non dia luogo ad anfibologie.

Non ti dirò cosa vuol dire, cercalo sul vocabolario come ho fatto io.

L'ereditarietà
==============

Il debug
========

question = 2b \| ( ! 2b );

B. Croce -- Breviario di estetica -- Laterza, Bari 1928 -- p.12

Un sistema è una casa che, subito dopo costruita e adornata, ha bisogno
(soggetta com'è all'azione corroditrice degli elementi) di un lavorio
più o meno energico, ma assiduo, di manutenzione, e che a un certo
momento non giova più restaurare e puntellare, e bisogna gettare a terra
e ricostruire dalle fondamenta. Ma con siffatta differenza capitale:
che, nell'opera del pensiero, la casa perpetuamente nuova e sostenuta
perpetuamente dall'antica, la quale, quasi per opera magica, perdura in
essa.

Chiediti una cosa: come mai, i manuali di programmazione non parlano mai
del *debug*?

Si sono scritte migliaia di pagine sui diversi linguaggi di
programmazione; non c\'è primavera che non veda fiorire un nuovo
paradigma di programmazione - strutturata, object-oriented, agile,
fuzzy.. - eppure, nessuno si è mai preoccupato di formalizzare il
processo di correzione del codice.

O, se lo ha fatto, nessuno se n\'è accorto.

Fare degli errori è inevitabile, ed è importante sapere come porvi
rimedio.

Ancora più importante, però, è sapersi accorgere degli errori.

Trascurare il debug è come affermare che non si faranno mai errori.

Dire che un programmatore non farà mai errori è come pensare che un
principe e un\'orfanella povera (che è cosa ben peggiore di una povera
orfanella) possano sposarsi e vivere per sempre felici e contenti.

Non importa quanto sia efficiente il linguaggio di programmazione; non
importa quanto sia astuto e vigile il compilatore; non importa nemmeno
quanto sia bravo il programmatore: o prima o poi, la stanchezza o un
evento esterno permetteranno a un errore di intrufolarsi nel codice.

Un puntatore utilizzato impropriamente, un ciclo in più o in meno in
un\'istruzione FOR o una virgola dimenticata fra i parametri di una
printf: qualunque cosa sia, se il compilatore non sarà in grado di
riconoscerla, finirà nel programma è lì resterà in attesa di produrre i
suoi effetti dannosi.

Magari per anni il programma funzionerà a meraviglia, poi, un bel
giorno, di colpo, smetterà di funzionare e a quel punto bisognerà
analizzare il codice per trovare l\'errore.

Il codice ha smesso di funzionare bene quando le stampanti laser hanno
soppiantato le vecchie stampanti ad aghi.

Il codice non si può leggere su un A4: a meno che non sia un programma
banale, non c\'entrerà né in altezza né in larghezza.

Il modulo in continuo di una stampante ad aghi a 136 colonne, al
contrario, ti permette di stampare tutto il tuo codice e di rileggerlo
con calma; correggerlo, se necessario e migliorarlo se possibile.

E\' così che si facevano, le revisioni di codice, quando ancora c\'era
il tempo di fare le revisioni del codice.

Così come l\'Ikebarba inizia nel negozio, il debug comincia nel momento
in cui si scrive il codice.

Il modo migliore per evitare che il codice contenga degli errori è
scrivere del buon codice.

Gli errori possono essere di due tipi: gli errori che si manifestano
durante la fase di compilazione e gli errori che si manifestano durante
l'esecuzione del programma.

Errori di compilazione
----------------------

Quando si compila del codice non corretto, si possono ottenere o degli
errori o degli avvisi, o *warning*.

Gli errori sono causati da costrutti incorretti, che bloccano la
compilazione e impediscono la creazione del programma.

I *warning*, al contrario, sono causati da anomalie che non bloccano la
compilazione e consentono la generazione dell'eseguibile.

In questo, i *warning* sono più dannosi degli errori, perché possono
essere degli errori potenziali, ma possono venir trascurati.

Se compilassi questo codice, otterresti un avviso perché la variabile
*buffer* non è utilizzata:

> int main() {

> char \*str = \"byte occupati inutilmente: \";

> double buffer\[8000\];

> cout \<\< str \<\< (sizeof(double)\*8000) \<\< endl;

> return 0;

> }

Il fatto che *buffer* non sia utilizzata, in sé, non causa alcun
problema al codice, ma oltre ad essere una sciatteria, causa un'inutile
occupazione della memoria e può dare luogo a errori, quindi l'avviso non
deve essere ignorato.

Nessun avviso deve essere ignorato.

Errori di esecuzione
--------------------

Solo un programma formalmente ineccepibile può dare luogo ad errori di
esecuzione. Se non fosse formalmente ineccepibile, infatti, non sarebbe
stato compilato e non potrebbe essere eseguito.

Gli errori di esecuzione sono tanto più pericolosi quanto più i loro
effetti sono lievi.

Un errore che causi il blocco del sistema non passerà mai inosservato.

Di contro, un leggero errore di calcolo potrebbe passare inosservato e
quindi causare grandi problemi.

Gli errori di esecuzione possono essere di due tipi: quelli che si
manifestano in maniera deterministica e quelli che si manifestano in
maniera casuale.

Il C\'hi++
==========

Non è necessario che crediate in Dio,

ma dovete credere nel Codice.

Il C\'hi++ è allo stesso tempo un linguaggio di programmazione, un
atteggiamento mentale e un modo di vivere.

Chi pratica il C\'hi++ scrive codice come se stesse vivendo e vive come
se stesse scrivendo del codice.

Vivere è come scendere in canoa lungo un fiume.

Affannarsi a risalire la corrente è inutile e infruttuoso, perché il
fiume è più forte di noi e non si stanca mai.

Lasciarsi andare alla corrente è pericoloso, perché ci si potrebbe
parare davanti un ostacolo e noi non avremmo modo di evitarlo.

È necessario quindi remare solo quel tanto che ci permette di essere più
veloci della corrente e di schivare gli ostacoli che, di volta in volta,
si presentano sul nostro cammino.

Similmente, scrivere del buon codice significa scrivere solo il codice
necessario a raggiungere lo scopo che ci si è prefissi. Aggiungere una
sola virgola in più è sbagliato, perché rende più difficile il debug e
più lento il programma.

Chi pratica il C\'hi++ applica lo stesso principio alla sua vita, e
compie solo le azioni necessarie, ignorando tutto ciò che è superfluo.

Capire quali sono le azioni necessarie è semplice, così com'è semplice,
quando si naviga su un fiume, capire qual è la direzione della corrente.

Tutte le cosmogonie che sono state formulate nel corso dei secoli hanno
una caratteristica comune: richiedono una certa dose di fede in qualcosa
di cui non è possibile provare l'esistenza; uno o più elementi fittizi e
sovra-naturali, che si introducono nel sistema per spiegare ciò che non
è possibile dimostrare praticamente.

Credere in queste entità richiede un'abiura più o meno marcata delle
nostre capacità cognitive e, spesso, l'accettazione di condizioni più
paradossali di quelle che si cercava di spiegare originariamente.

Ma, come diceva sempre il Maestro Canaro: "la Verità è semplice".

Qualunque spiegazione che richieda dei parametri correttivi, è inesatta.

Una volta, poco prima di morire, il Maestro Canaro mi disse che,
utilizzando i costrutti tipici del C\'hi++, si poteva scrivere la
dimostrazione dell'ultimo teorema di Fermat su una bustina di
fiammiferi.

*Chi*, in giapponese, vuol dire "respiro".

L'Universo è scritto in C\'hi++.

L'Universo respira.

Ciò che noi percepiamo come eternità altro non è che un singolo respiro
dell'Universo, una delle innumerevoli eternità che si sono succedute
dall'inizio dei tempi.

Ogni respiro dell'Universo comporta una fase di espansione e una fase di
contrazione.

I punti terminali di ciascuna fase prevedono l'annichilimento di ogni
forma di vita senziente.

Al contrario, nei periodi intermedi nascono e muoiono innumerevoli
mondi.

Su ciascuno di questi innumerevoli mondi nascono e muoiono innumerevoli
esseri

Ciascuno di questi innumerevoli esseri, nel corso della sua vita, compie
una serie di azioni che influenzano la sua esistenza e quella dei suoi
simili.

Le possibili permutazioni di queste innumerevoli azioni per questi
innumerevoli esseri per questi innumerevoli mondi sono quasi illimitate.

Quasi.

Il tempo, al contrario, è illimitato, quindi può capitare che una
determinata sequenza di eventi, già avvenuta in un precedente respiro
dell'Universo, si ripeta, con condizioni simili, in un respiro
successivo.

Ciò vuol dire che, con buone probabilità, io e te abbiamo già avuto
questa conversazione in una o in migliaia delle nostre esistenze
precedenti.

In Borges, *Finzioni*: lo scrittore che vuole riscrivere Don Chisciotte
dice che potrebbe farcela, se solo fosse immortale (v. *Breve storia
dell'Infinito*). La stessa cosa vale per l'Universo: avendo a
disposizione un tempo infinito, la ripetizione è inevitabile.

Chi pensa che io voglia fare il debug dell'Universo non sa nulla del
*C\'hi++*.

Rispetto agli altri linguaggi di programmazione, ha una peculiarità: non
consente errori di programmazione, ma solo di esecuzione.

Ciascun ciclo di vita dell'Universo è una sessione di debug.

Il codice è perfetto, siamo noi a fare gli errori.

Paul Erdós sosteneva che Dio possedeva un libro transfinito (più grande
dell'infinito) nel quale erano raccolte le migliori dimostrazioni di
tutti i teoremi matematici, dimostrazioni eleganti e perfette.

Non esiste l'anima: siamo solo epifenomeni, aggregazioni temporanee di
materia.

Come variabili all'interno di un programma, esistiamo solo all'interno
del blocco di codice in cui siamo dichiarate.

Nasciamo, svolgiamo il nostro compito e infine scompariamo, liberando la
memoria che avevamo allocato.

Tao-Tê-Ching, XVI (J.J.L. Duyvendak, Fabbri Editori): *Infatti gli
esseri fioriscono e (poi) ognuno torna alla propria radice. Tornare alla
propria radice si chiama la tranquillità; ciò vuol dire deporre il
proprio compito. Deporre il proprio compito è una legge costante. Colui
che conosce questa legge costante si chiama illuminato. Colui che non
conosce questa legge costante agisce da stolto e attira su di sé la
disgrazia.*

Fintanto che il programma gira, quella stessa memoria sarà utilizzata
più e più volte per creare nuove variabili.

Poco importa se saremo di nuovo noi, oppure altre entità, perché il
programma continuerà a girare per sempre e anche se ci fosse solo una
probabilità su un miliardo che tornino a verificarsi le condizioni che
hanno portato alla nostra esistenza, prima o poi quelle stesse
condizioni si verificheranno ancora, e noi saremo di nuovo qui a vivere
la nostra vita.

La questione a questo punto è: esiste un disco rigido dell'Universo, o
gira tutto in memoria RAM?

Coloro che si sforzano, in questa vita, di eseguire i precetti della
loro religione perché pensano che gliene verrà reso merito dopo la
morte, sbagliano due volte.

Non esiste il Paradiso e non esiste nessuna vita eterna, ma solo
un'eternità di vite.

L\'Universo *è* il Paradiso: siamo noi che lo utilizziamo
impropriamente.

Ci sono due forze, contrapposte. Come dice Poe, una è la gravità, che
tende a riunire tutto nell\'Uno; l\'altra è l\'elettricità, che separa e
disperde.

Servono tutte e due: se ci fosse solo la gravità, ci sarebbe solo
l\'Uno, se ci fosse solo l\'elettricità, ci sarebbe l\'entropia.

Alla lunga (molto lunga), una condizione simile porterebbe a un Universo
piuttosto noioso, quindi, devono esserci entrambe, in continua
opposizione.

È questo che permette l\'esistenza.

Ciò che le religioni non dicono è che non si può andare in Paradiso da
soli: o ci andiamo tutti, o non ci va nessuno.

Non c\'è nient\'altro da capire.

Epilogo
=======

\[prima di questo, il Maestro, prossimo alla dipartita, deve ordinare al
discepolo di uscire fuori; il discepolo replica che piove, ma il Maestro
insiste.\]

Uscii fuori, sotto la pioggia, e guardai in alto, come mi era stato
ordinato di fare.

La luna e le stelle erano nascoste dalle nuvole e comunque, la pioggia
colpiva i miei occhi e impedendomi di vedere con chiarezza.

Ciò non ostante, o forse proprio per questo motivo, non abbassai lo
sguardo e lasciai che le gocce di pioggia si confondessero con le
lacrime.

Fu così che capii.

Quelle gocce di acqua che adesso erano pioggia, erano state, prima,
vapore acqueo e mare e fiume e prima ancora, per quello che ne potevo
sapere, sangue, sudore, orina, ghiaccio, vino, muscoli, piante, saliva
fango, calce o cemento.

A qualunque cosa si fossero legate, nella loro esistenza precedente,
adesso erano di nuovo acqua, ed erano pronte per un altro ciclo di vita.

Il calore del sole le aveva portate in alto, ora la gravità le riportava
in basso, verso il mare.

Bibliografia
============

  --------------------------------------------------------
  A book of five rings
  Bahagavad Gita
  *Breve storia dell\'infinito** ***
  Eureka
  Fiabe e storie giapponesi
  Goedel, Escher, Bach
  Hagakure
  I Ching
  Gli oggetti frattali
  I Vangeli apocrifi
  Il Cristianesimo
  Il fuzzy-pensiero
  Il Grande Brivido
  Il Tao della fisica
  Japanese ghosts and demons
  La filosofia dei Simpson
  La porta senza porta
  Le metamorfosi
  Lettera agli Artisti
  Lezioni americane
  Lila
  Lo Zen e l\'arte del tiro con l\'arco
  Lo Zen e l\'arte della manutenzione della motocicletta
  Musashi
  Principi di calcolo infinitesimale
  *Tao-tê-ching*
  The Art of Zen
  Un'etica senza Dio
  L'uomo che amava solo i numeri
  --------------------------------------------------------

\[nota: questi appunti per ora li metto qui, ma poi dovranno essere
suddivisi per i diversi capitoli\]

Il diluvio universale era solo il passaggio dalla versione beta alla
1.0. La venuta di Cristo, invece, era un aggiornamento della
documentazione.

La filosofia é il *reverse engineering* dell\'Universo.

L\'analisi del sistema può avvenire a più livelli, dall\'interfaccia
utente al codice binario.

Analizzare a livelli bassi è più difficile e porta tutt\'al più alla
conoscenza delle meccaniche di funzionamento, non delle regole di
business.

Potere educativo della letteratura in confronto alla filosofia.

Cfr Simpson, 243 e Nussbaum citato

Gli interventi divini possono avvenire solo in fase di debug, poi il
software deve essere in grado di funzionare autonomamente.

La generazione dei numeri casuali è un\'attività troppo importante per
essere lasciata al Caso

Secondo l'etimologia classica, il termine: "religione" deriva dal latino
*relegere*, e denota interesse e riguardosa considerazione per il
numinoso; la derivazione di *religio* da *religare* (legare a qualcosa)
è dovuta ai Padri della Chiesa.

Come si accettano le mutazioni del destino, si devono saper accettare
anche le mutazioni dell'amore.

Le persone si aspettano che l'amore sia sempre al massimo, come gli
atleti, e si sentono offese, derubate o tradite quando l'intensità
scema.

Le loro reazioni peggiorano la situazione in un escalation che spesso
porta alla fine del rapporto o dell'amore.

Ma anche qui è tutta una questione di equilibrio fra forze contrapposte:
fedeltà e devozione, amore e odio, vicinanza e lontananza.

Ti è mai passato per la testa, che tutta questa teoria potrebbe essere
sbagliata?

Che potrei essere davvero pazzo, come dicono i tuoi confratelli?

Wittgenstein a trent\'anni, definì una filosofia che egli stesso, dieci
anni dopo, rinnegò a favore di un nuovo credo. Se fosse vissuto per
altri trent\'anni, avrebbe cambiato ancora idea?

\[le teorie di W., secondo cui la metafisica è un uso pervertito del
linguaggio, tocca che me la studio\]

La storia dell\'Umanità è costellata di fedi bizzarre, ciascuna con il
suo bravo seguito di fedeli.

Cosa ti fa pensare, che lo Spazionismo sia diverso?

Il fatto che possa dare una risposta razionale e coerente ad alcuni
fenomeni che altrimenti sarebbero senza spiegazione non vuol dire
necessariamente che corrisponda a verità.

\[differenza fra verità epistemica e verità realista in Filosofia di
House, pag. 100 e seguenti\]

I suoi assiomi sembrano trovare conferma nella realtà, ma questo cosa
conta?

Potremmo essere noi, che non ci accorgiamo degli errori.

Abbiamo creduto per centinaja di anni che il Sole girasse intorno alla
terra e anche quella era un\'ipotesi confortata dai fatti, almeno
apparentemente.

L\'Esistenza potrebbe essere un sistema per smaltire l\'energia
dell\'Universo (o di quello che ha intorno), così come le perturbazioni
sono un sistema per smaltire l\'energia dell\'atmosfera?

\[Riguardando il saggio sul Buddismo in Tempo ed Eternità di Ananda K.,
mi sono venute in mente due cose: la prima è che non è chiaro quali
siano le prove a sostegno delle affermazioni riportate: d\'accordo,
stiamo parlando di testi sacri, o quasi, ma chi ci dice che abbiano
ragione?

È un terreno insidioso, perché sto di fatto affermando e negando allo
stesso tempo la validità del metodo scientifico. Mi spiego meglio, così
mi capisco anche domani mattina: dire che qualcosa è vero perché è
scritto in un libro importante, è ciò che permette da duemila anni alla
chiesa cattolica di vendere per buone le sue bugie. In opposizione a
questo modo di \"provare\" c\'è il metodo scientifico, che richiede la
replicabilità sperimentale.

Deve essere chiaro, quando critico la fede nella scienza, che il
problema non è il metodo in sé, che è corretto, ma la sua applicazione
forzata. Quando mi dici che la teoria delle superstringhe funziona, ma
solo in un universo a undici dimensioni, mi viene da chiedere che
differenza ci sia, fra questa affermazione e la fantascienza. Com\'è
possibile sperimentare uno spazio a undici dimensioni se ne abbiamo a
disposizione solo tre? Dice: *teoricamente*. Ho capito, ma allora,
teoricamente, potrebbero avere ragione anche i cattolici; anzi, visto
che per fare un Aldilà servono solo tre dimensioni, ne risparmieremmo
cinque rispetto alle super-stringhe (undici meno tre di qua e tre
al-di-là).

La seconda, collegata per certi versi alla prima, è la distinzione fra
ciò che è temporaneo e mortale e ciò che non lo è; fra chi è
*illuminato* e chi non lo è, il che, presuppone due stati diversi di
esistenza, ma compenetrati.

Per esempio, a pag. 42, quando si dice che la freccia scoccata *diventa*
il bersaglio, si assume che una cosa sia la freccia, una cosa sia il
bersaglio, sia in termini pratici che metafisici.

Il C\'hi++ è sostanzialmente concorde nella sostanza, ma non nella
forma.

Freccia e bersaglio sono già la stessa cosa, o meglio, manifestazioni
differenti (e transeunti) della stessa cosa (eterna). Il fatto che
l\'una diventi l\'altra è solo l\'ennesima illusione.

Ritornando al primo punto, quest\'ultima affermazione non è provabile al
momento, ma potrebbe esserlo, in questo stesso universo tridimensionale,
senza inventarci niente: se l\'universo fosse composto di spazioni e la
materia di spazioni carichi (d\'accordo: tocca capire da dove viene
l\'Energia\...), l\'affermazione che la freccia, il bersaglio e lo
stesso arciere SONO la stessa cosa, sarebbe provata.\]

[^1]: Gli stessi che precedentemente lo avevano accusato di essersi
    venduto all\'IBM

[^2]: Cap. II, verso 47
